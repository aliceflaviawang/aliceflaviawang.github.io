
 <!DOCTYPE HTML>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
  
    <title>笑呵呵</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Alice">
    

    
    <meta name="description" content="You Never Know Who You Can Be">
<meta property="og:type" content="website">
<meta property="og:title" content="笑呵呵">
<meta property="og:url" content="https://aliceflaviawang.github.io/page/3/index.html">
<meta property="og:site_name" content="笑呵呵">
<meta property="og:description" content="You Never Know Who You Can Be">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="笑呵呵">
<meta name="twitter:description" content="You Never Know Who You Can Be">

    
    <link rel="alternative" href="/atom.xml" title="笑呵呵" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.png">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="笑呵呵" title="笑呵呵"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="笑呵呵">笑呵呵</a></h1>
				<h2 class="blog-motto">We were moving mountains long before we knew we could</h2>
			</div>
			
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">首页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/about">关于</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="Search" />
						<input type="hidden" name="q" value="site:aliceflaviawang.github.io">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/07/11/跨站脚本攻击/" title="跨站脚本攻击" itemprop="url">跨站脚本攻击</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Alice" target="_blank" itemprop="author">Alice</a>
		
  <p class="article-time">
    <time datetime="2017-07-11T08:44:29.000Z" itemprop="datePublished"> Published 2017-07-11</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="跨站脚本攻击（XSS）"><a href="#跨站脚本攻击（XSS）" class="headerlink" title="跨站脚本攻击（XSS）"></a>跨站脚本攻击（XSS）</h3><p>跨站脚本攻击（cross-site script，为了和CSS区分，缩写XSS）。发生的原因是网站将用户输入的内容输出到页面上，在这个过程中可能有恶意代码被浏览器执行。</p>
<h3 id="XSS的种类"><a href="#XSS的种类" class="headerlink" title="XSS的种类"></a>XSS的种类</h3><h4 id="1-反射型XSS"><a href="#1-反射型XSS" class="headerlink" title="1.反射型XSS"></a>1.反射型XSS</h4><p>它是通过诱使用户打开一个恶意链接，服务端将链接中参数的恶意代码渲染到页面中，再传递给用户由浏览器执行，从而达到攻击的目的。</p>
<h4 id="2-持久型XSS"><a href="#2-持久型XSS" class="headerlink" title="2.持久型XSS"></a>2.持久型XSS</h4><p>持久型xss将恶意代码提交给服务器，并且存储在服务器端，当用户访问相关内容时再渲染到页面中，以达到攻击的目的，它的危害更大。</p>
<h3 id="XSS防御"><a href="#XSS防御" class="headerlink" title="XSS防御"></a>XSS防御</h3><h4 id="1-输入检查"><a href="#1-输入检查" class="headerlink" title="1.输入检查"></a>1.输入检查</h4><p>对输入数据做检查，比如用户名只允许是字母和数字，一定要在后台做检查，否则数据可能绕过前端检查直接发给服务器。一般前后端都做检查，前端能过滤掉大部分无效数据。</p>
<h4 id="2-输出检查"><a href="#2-输出检查" class="headerlink" title="2.输出检查"></a>2.输出检查</h4><p>对渲染到html中内容执行htmlEncode。</p>
<h2 id="其他攻击方式"><a href="#其他攻击方式" class="headerlink" title="其他攻击方式"></a>其他攻击方式</h2><h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><p>SQL注入与XSS类似，用户提交的数据被当成命令来执行而造成的。</p>
<h3 id="SQL注入防御"><a href="#SQL注入防御" class="headerlink" title="SQL注入防御"></a>SQL注入防御</h3><p>防止SQL注入最好的方法是使用预编译语句。不同的语言的预编译方法不同，但基本都可以处理。<br>如果无法使用预编译方法，只能像防止XSS那样对参数进行检查和编码。</p>
<h3 id="点击劫持"><a href="#点击劫持" class="headerlink" title="点击劫持"></a>点击劫持</h3><p>点击劫持是从视觉上欺骗用户。攻击者使用一个透明的iframe覆盖到网页上，诱使用户在该网页上操作，而实际点击却是点在透明的iframe页面。<br>点击劫持延伸出很多攻击方式，有图片覆盖攻击、拖拽劫持等。</p>
<h3 id="点击劫持的防御"><a href="#点击劫持的防御" class="headerlink" title="点击劫持的防御"></a>点击劫持的防御</h3><p>针对iframe的攻击，可使用一个http头：X-Frame-Options，它有三种可选值：</p>
<ul>
<li>DENY：禁止任何页面的frame加载</li>
<li>SAMEORIGIN:只有同源页面的frame可加载</li>
<li>ALLOW-FROM:可定义允许frame加载的地址<br>针对图片覆盖攻击，则注意使用预防XSS的方法，防止HTML和JS注入。</li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/07/11/CSRF攻击与防御/" title="CSRF攻击与防御" itemprop="url">CSRF攻击与防御</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Alice" target="_blank" itemprop="author">Alice</a>
		
  <p class="article-time">
    <time datetime="2017-07-11T06:39:07.000Z" itemprop="datePublished"> Published 2017-07-11</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h3><p>CSRF:跨站点请求伪造(cross-site request forgery)。攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说是完全合法的，但是却完成了攻击者所期望的一个操作。</p>
<h3 id="CSRF攻击的原理及过程"><a href="#CSRF攻击的原理及过程" class="headerlink" title="CSRF攻击的原理及过程"></a>CSRF攻击的原理及过程</h3><p><img src="http://i.imgur.com/DO9WNOY.png" alt=""></p>
<ol>
<li>用户打开浏览器，访问网站A，输入用户名和密码请求登陆网站A</li>
<li>在用户信息验证通过之后，网站A产生cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；</li>
<li>用户未退出网站A之前，在同一个浏览器中，打开一个Tab页访问网站B</li>
<li>网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A</li>
<li>浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带cookie信息，向网站A发出请求。网站A并不知道请求其实是由B发起的，所以会根据用户的cookie信息以用户的权限处理该请求，导致来自B的恶意被代码执行。<h3 id="CSRF漏洞检测"><a href="#CSRF漏洞检测" class="headerlink" title="CSRF漏洞检测"></a>CSRF漏洞检测</h3>检测CSRF是一项比较繁琐的工作，最简单的方法是抓取一个正常请求的数据包，去掉Referer字段后再重新提交，如果该提交有效，那么基本可以确定CSRF漏洞存在。<h3 id="CSRF攻击防御"><a href="#CSRF攻击防御" class="headerlink" title="CSRF攻击防御"></a>CSRF攻击防御</h3><h4 id="1-验证码"><a href="#1-验证码" class="headerlink" title="1.验证码"></a>1.验证码</h4>验证码不单单用来防止注册机的暴力破解，还可以有效防止CSRF的攻击。<br>不过随着html5的发展，利用canvas标签，前端也能识别验证码的字符，让CSRF生效。<h4 id="2-referer-check"><a href="#2-referer-check" class="headerlink" title="2.referer check"></a>2.referer check</h4>referer记录了该http请求的来源地址，http referer是request header的一部分，当浏览器向web服务器发出请求的时候，一般会带上referer，告诉服务器从哪个站点链接过来。<br>服务器通过判断请求头中的referer，也能避免CSRF攻击。<h4 id="3-token"><a href="#3-token" class="headerlink" title="3. token"></a>3. token</h4>CSRF攻击之所以成功是因为黑客可以在不知道验证信息的情况下直接利用用户的cookie来通过安全验证。可以在http请求中以参数的形式加入一个随机产生的token。（比如get方式放拼接到url，post方式以参数方式）<h4 id="4-在http头中自定义属性并验证"><a href="#4-在http头中自定义属性并验证" class="headerlink" title="4.在http头中自定义属性并验证"></a>4.在http头中自定义属性并验证</h4>也是使用token并进行验证，但是不是以参数的形式置于http请求中，而是把它放在http头中自定义的属性里。</li>
</ol>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/07/10/ready-与window-onload的区别/" title="$.ready()与window.onload的区别" itemprop="url">$.ready()与window.onload的区别</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Alice" target="_blank" itemprop="author">Alice</a>
		
  <p class="article-time">
    <time datetime="2017-07-10T14:33:43.000Z" itemprop="datePublished"> Published 2017-07-10</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>区别有三点：</p>
<h3 id="1、执行时机"><a href="#1、执行时机" class="headerlink" title="1、执行时机"></a>1、执行时机</h3><p>$.ready()是网页的所有DOM结构绘制完毕后就执行，可能DOM元素关联的东西还没加载完<br>window.onload必须等网页里所有的内容都加载完毕后（包括图片）才执行</p>
<h3 id="2、编写个数"><a href="#2、编写个数" class="headerlink" title="2、编写个数"></a>2、编写个数</h3><p>$.ready()可以编写多个，每个都执行<br>window.onload不能编写多个（编写多个时，只执行最后一个）</p>
<h3 id="3、简化写法"><a href="#3、简化写法" class="headerlink" title="3、简化写法"></a>3、简化写法</h3><p>$.ready实际上是$(document).ready的简写，而window.onload没有简写</p>
<h3 id="后记：DOM文档的加载过程"><a href="#后记：DOM文档的加载过程" class="headerlink" title="后记：DOM文档的加载过程"></a>后记：DOM文档的加载过程</h3><ol>
<li>解析HTML结构</li>
<li>加载外部脚本和样式文件</li>
<li>解析并执行脚本代码</li>
<li>DOM树构建完成 //DOMContentLoaded</li>
<li>加载图片等外部文件</li>
<li>页面加载完 //load<br>所以$.ready()是在第4步后执行，window.onload是在第6步后执行</li>
</ol>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/07/10/javascript是单线程/" title="javascript是单线程" itemprop="url">javascript是单线程</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Alice" target="_blank" itemprop="author">Alice</a>
		
  <p class="article-time">
    <time datetime="2017-07-10T11:51:27.000Z" itemprop="datePublished"> Published 2017-07-10</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>首先看下面的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function foo()&#123;</div><div class="line">   console.log(&apos;first&apos;);</div><div class="line">   setTimeout(function()&#123;console.log(&apos;second&apos;)&#125;,5);</div><div class="line">&#125;</div><div class="line">for(var i=0;i&lt;100;i++)&#123;</div><div class="line">  foo();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>执行结果会首先输出first，然后全部输出second；尽管中间结果会超过5ms，为什么？</p>
<h3 id="javascript是单线程的"><a href="#javascript是单线程的" class="headerlink" title="javascript是单线程的"></a>javascript是单线程的</h3><p>因为<strong>JS运行在浏览器中，是单线程的，每个window一个JS线程</strong>，既然是单线程，在某个特定时刻只有特定的代码能够背执行，并阻塞其他代码。而浏览器是<strong>事件驱动（Event driven）</strong>的，浏览器中很多行为是异步（Asynchronized）的，会创建事件并放在执行队列中。javascript引擎是单线程处理它的任务队列，你可以理解成就是普通函数和回调函数构成的队列。当异步事件发生时，如鼠标点击事件、定时器触发事件、XMLHttpRequest完成回调触发等，将它们放入执行队列，等待当前代码执行完成。</p>
<h3 id="异步事件驱动"><a href="#异步事件驱动" class="headerlink" title="异步事件驱动"></a>异步事件驱动</h3><p>浏览器是事件驱动的，浏览器中很多行为是异步的。当一个异步事件发生时，它就进入事件队列。浏览器有个内部大消息循环，EventLoop(事件循环)，会轮询大的事件队列并处理事件。</p>
<h3 id="浏览器不是单线程的"><a href="#浏览器不是单线程的" class="headerlink" title="浏览器不是单线程的"></a>浏览器不是单线程的</h3><p>虽然JS运行在浏览器中，是单线程的，每个window一个JS线程，但浏览器不是单线程的，例如Webkit或是Gecko引擎，都可能有如下线程：</p>
<ul>
<li>javascript引擎线程</li>
<li>界面渲染线程</li>
<li>浏览器触发线程</li>
<li>Http请求线程<br>很多人搞不清，如果js是单线程的，那么谁去轮询大的Event Loop事件队列？答案是浏览器会有单独的线程去专门处理这个队列<h3 id="Ajax异步请求是否是真的异步"><a href="#Ajax异步请求是否是真的异步" class="headerlink" title="Ajax异步请求是否是真的异步"></a>Ajax异步请求是否是真的异步</h3>Ajax请求确实是异步的，这请求是由浏览器新开一个线程请求，事件回调的时候放入Event loop单线程事件队列等候处理。<h3 id="setTimeout-func-0-的作用"><a href="#setTimeout-func-0-的作用" class="headerlink" title="setTimeout(func,0)的作用"></a>setTimeout(func,0)的作用</h3>setTimeout(func,0)非常有用，单丝不是模拟多线程，前面已经说过一个window一个js线程，setTimeout(func,0)主要是告诉js引擎，在0ms后把func放在主事件队列中，等待当前的代码执行完毕后再执行。<br>注：重点是改变了代码的流程，把func的执行放到了等待当前的代码执行完毕后再执行。<h3 id="非阻塞js的实现"><a href="#非阻塞js的实现" class="headerlink" title="非阻塞js的实现"></a>非阻塞js的实现</h3>js在浏览器中需要被下载、解释并执行这三步。尽管浏览器可以实现多线程并行下载，但是必须依次执行。要实现非阻塞js有两个方法：</li>
</ul>
<ol>
<li><p>html5中的defer和async关键字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;test/javascript&quot; defer src=&quot;foo.js&quot;&gt;&lt;/script&gt;</div><div class="line">//没有defer或async，浏览器会立即加载并执行指定的脚本，“立即”的意思是指不等待后续载入的文档元素，读到就立即执行</div><div class="line">&lt;script type=&quot;test/javascript&quot; async src=&quot;foo.js&quot;&gt;&lt;/script&gt;</div><div class="line">//有async，加载和渲染后续文档元素的过程将和foo.js的加载与执行并行进行（异步）</div><div class="line">&lt;script type=&quot;test/javascript&quot; defer src=&quot;foo.js&quot;&gt;&lt;/script&gt;</div><div class="line">//有defer，加载后续文档元素的过程将和foo.js的加载并行进行(异步)，但是foo.js的执行要在所有元素解析完成之后，DOMContentLoaded事件触发之前完成</div></pre></td></tr></table></figure>
</li>
<li><p>动态加载js（比如：使用setTimeout方法）</p>
<h3 id="后记：setTimeout和setInterval"><a href="#后记：setTimeout和setInterval" class="headerlink" title="后记：setTimeout和setInterval"></a>后记：setTimeout和setInterval</h3><p>setTimeout和setInterval都是指过一段时间，再进行某项操作。<br>setTimeout是让一段代码在指定时间运行（次数是一次），而setInterval是让一段代码每过指定时间就运行一次<br>setInterval的坑：如果间隔时间可能小于定时调用的代码的执行时间，而js是单线程，将定时调用的代码插入到队列中，但是代码中如果已经有了一份没有执行的同意的代码，<strong>时间间隔或许会被跳过</strong>。</p>
</li>
</ol>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/07/10/Web语义化/" title="Web语义化" itemprop="url">Web语义化</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Alice" target="_blank" itemprop="author">Alice</a>
		
  <p class="article-time">
    <time datetime="2017-07-10T08:53:48.000Z" itemprop="datePublished"> Published 2017-07-10</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="web语义化的含义"><a href="#web语义化的含义" class="headerlink" title="web语义化的含义"></a>web语义化的含义</h3><p>web语义化是指在进行html结构、表现、行为设计时，尽量使用语义化标签，使程序简洁明了，易于进行web操作和网站SEO，方便团队协作的一种标准，以期实现一种“无障碍”的web开发。<br>SEO:搜索引擎优化，指对网站进行站内优化和站外优化，从而提高网站关键词排名以及公司产品的曝光度。</p>
<h3 id="web语义化的作用"><a href="#web语义化的作用" class="headerlink" title="web语义化的作用"></a>web语义化的作用</h3><ol>
<li>有利于机器识别，方便SEO</li>
<li>代码简洁明了，利于阅读和维护，方便以后扩展</li>
<li>有利于团队协作，减少出错率，使工作有个统一标准<h3 id="web语义化分类"><a href="#web语义化分类" class="headerlink" title="web语义化分类"></a>web语义化分类</h3><h4 id="1、HTML标签语义化"><a href="#1、HTML标签语义化" class="headerlink" title="1、HTML标签语义化"></a>1、HTML标签语义化</h4>HTML为网页文档提供上下文结构和含义。对于HTML体系而言，<strong>Web语义化是指使用恰当的标签，是页面有良好的结构，让页面元素有含义，便于被浏览器、搜索引擎解析</strong>。<br>一个经典的页面结构：<br><img src="http://i.imgur.com/PCFZNzK.png" alt=""><h4 id="2、ARIA无障碍web规范"><a href="#2、ARIA无障碍web规范" class="headerlink" title="2、ARIA无障碍web规范"></a>2、ARIA无障碍web规范</h4>应用于HTML的ARIA有两部分组成：role和aria-*<br>其中role标识了一个元素的作用，aria-描述了与之有关的事物特征及状态<br>比如：<div class="navigation">作用是导航<h4 id="3、CSS命名语义化"><a href="#3、CSS命名语义化" class="headerlink" title="3、CSS命名语义化"></a>3、CSS命名语义化</h4>css语义就是class和id命名的语义，用易于理解的名称对html标签附加class和id命名。<strong>如果说html语义化是给机器看的，那么css命名的语义化就是给人看的</strong>。良好的css命名减少沟通调试成本。<h4 id="4、URL语义化"><a href="#4、URL语义化" class="headerlink" title="4、URL语义化"></a>4、URL语义化</h4>url语义化，可以使得<strong>搜索引擎或者爬虫更好的理解当前url所在目录所需要表达的内容</strong>；而对于用户来说，<strong>通过url也可以判断上一级目录或者下一级目录想要表达的内容</strong>，可以提高用户体验。</div></li>
</ol>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/07/10/Bootsstrap实现原理/" title="Bootsstrap实现原理" itemprop="url">Bootsstrap实现原理</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Alice" target="_blank" itemprop="author">Alice</a>
		
  <p class="article-time">
    <time datetime="2017-07-10T06:30:43.000Z" itemprop="datePublished"> Published 2017-07-10</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="1、整体架构"><a href="#1、整体架构" class="headerlink" title="1、整体架构"></a>1、整体架构</h3><p>下图为bootstrap整体架构图，共分为六大部分<br><img src="http://i.imgur.com/DBICY3e.png" alt=""></p>
<h4 id="1-1、12栅格系统"><a href="#1-1、12栅格系统" class="headerlink" title="1.1、12栅格系统"></a>1.1、12栅格系统</h4><p>12栅格系统就是把网页的总宽度平分为12份，我们可以自由组合。栅格系统使用的总宽度可以不固定，Bootstrap是按百分比进行平分。<br>12栅格系统是整个Bootstrap的核心功能，也是响应式设计核心理念的一个实现形式。</p>
<h4 id="1-2、jQuery"><a href="#1-2、jQuery" class="headerlink" title="1.2、jQuery"></a>1.2、jQuery</h4><p>Bootstrap所以的javascript插件都依赖于jQuery 1.10+，如果要使用这些插件，那就必须引入jquery库。如果只使用css组件，那就可以不引用它了。</p>
<h4 id="1-3、响应式设计"><a href="#1-3、响应式设计" class="headerlink" title="1.3、响应式设计"></a>1.3、响应式设计</h4><p>响应式是一个理念而非功能，Bootstrap的内容都是以响应式设计为设计理念来实现的。<br>响应式设计的目的：让页面有能力自动响应用户的设备环境。响应式网页设计就是一个网站兼容多个终端，而不是为每个终端做一个特定的版本。<br>实践方式：由多方面决定，包括弹性网格和布局、图片、css媒体查询的使用等</p>
<h3 id="2、栅格系统"><a href="#2、栅格系统" class="headerlink" title="2、栅格系统"></a>2、栅格系统</h3><h4 id="2-1-实现原理"><a href="#2-1-实现原理" class="headerlink" title="2.1 实现原理"></a>2.1 实现原理</h4><p>通过定义容器，平分12份（默认），再调整内外边距，最后结合媒体查询，就制作出了强大的响应式的栅格系统。</p>
<h4 id="2-2-工作原理"><a href="#2-2-工作原理" class="headerlink" title="2.2 工作原理"></a>2.2 工作原理</h4><ol>
<li>一行数据（row）必须包含在.container中，以便为其赋予合适的对其方式和内边距</li>
<li>使用行（row）在水平方向创建一组（column）</li>
<li>具体内容应放置于（column）内，而且只有列（column）可以作为行（row）的直接子元素</li>
<li>使用像.row和.col-xs-4这样的方式来快速创建栅格布局</li>
<li>通过设置padding从而创建列（column）之间的间隔，然后通过第一列和最后一列设置负值的margin从而抵消掉padding的影响</li>
<li>栅格系统中的列是通过指定1到12的值来表示其跨越的范围<h5 id="container的作用"><a href="#container的作用" class="headerlink" title="container的作用"></a>container的作用</h5></li>
</ol>
<ul>
<li>提供宽度限制。container随着页面宽度变化而变化，由于column的宽度是基于百分比的，所以它们的宽度不用去管。</li>
<li>提供左右padding，以至于文本内容不会触及浏览器边缘。<h5 id="Row"><a href="#Row" class="headerlink" title="Row"></a>Row</h5></li>
<li>Row是column的存放容器，Row中最多能放12个左浮动的column</li>
<li>Row有个特殊的地方就是左右-15px的margin，这样刚好抵消了父容器container中的15px的padding<h5 id="Column"><a href="#Column" class="headerlink" title="Column"></a>Column</h5>column有左右15px的padding，所以位于两边的column有15px的padding，可以是内容不会碰到container的边界<h5 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h5>由于container和column都有15px的padding，所以嵌套时column就相当于container了，这样可以实现任意嵌套</li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/07/03/前端面试准备/" title="前端面试准备" itemprop="url">前端面试准备</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Alice" target="_blank" itemprop="author">Alice</a>
		
  <p class="article-time">
    <time datetime="2017-07-03T09:03:08.000Z" itemprop="datePublished"> Published 2017-07-03</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="1、cookie的优点及弊端"><a href="#1、cookie的优点及弊端" class="headerlink" title="1、cookie的优点及弊端"></a>1、cookie的优点及弊端</h3><p><img src="http://i.imgur.com/NU4tepj.png" alt=""><br>如果步骤5携带的是过期或者错误的cookie，那么将认证失败，返回至要求身份认证页面。</p>
<h4 id="优点：极高的扩展性和可用性"><a href="#优点：极高的扩展性和可用性" class="headerlink" title="优点：极高的扩展性和可用性"></a>优点：极高的扩展性和可用性</h4><p>1、通过良好的编程，控制保存在cookie中的session对象的大小<br>2、通过加密和安全传输技术（SSL），减少cookie被破解的可能性<br>3、只在cookie中存放不敏感数据，即使被盗也不会有重大损失<br>4、控制cookie的生命期，使之不会永远有效。</p>
<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><p>1、cookie数量和长度的限制。每个domain最多只能有20条cookie，每个cookie长度不能超过4KB，否则会被截掉。<br>2、安全性问题。如果cookie被拦截了，就可以获取所以的session信息。即使加密也于事无补，因为拦截者不需要知道cookie的意义，只需要原样转发cookie就行了。<br>3、有些状态不可能保存在客户端。如：为了防止重复提交表单，在服务器端保存计数器，如果计数器放在客户端就起不了任何作用。</p>
<h4 id="session"><a href="#session" class="headerlink" title="session"></a>session</h4><p>session是一种服务器端机制，服务器类似于散列表的结构来保存信息。当程序需要为客户端请求创建一个session时，服务器首先检查这个客户端的请求是否包含了session标志（session id），如果已包含则说明服务端曾经为用户创建过session，服务器就按照session id将session检索处理（检索不到会新建），如果不包含则会新建session并生产与之关联的session id（既不重复也不容易被找到规律仿造），找个session id将在本次响应中返回给客户端保存（保存这个session id的方式可以用cookie，另外还有两种方式：基于url path parameter默认支持的，基于SSL，默认不支持）。</p>
<h4 id="cookie与session的区别"><a href="#cookie与session的区别" class="headerlink" title="cookie与session的区别"></a>cookie与session的区别</h4><ol>
<li>cookie有大小和个数的限制，单个cookie大小不超过4kb，很多浏览器限制一个站点最多保存20个cookie</li>
<li>cookie保存在客户端，session保存在服务器端</li>
<li>cookie不是很安全，别人可以分析存放在本地的cookie并进行欺骗；因此建议将登陆等重要信息保存在服务器端，其他信息放在cookie中</li>
<li>session会在一定时间内保存在服务器上，当访问增多，会比较占用服务器的性能，考虑到减轻服务器的负担应当使用cookie<h3 id="2、浏览器的本地存储（web-storage）"><a href="#2、浏览器的本地存储（web-storage）" class="headerlink" title="2、浏览器的本地存储（web storage）"></a>2、浏览器的本地存储（web storage）</h3>js提供了sessionStorage和globalStorage。在HTML5中提供了localStorage取代了globalStorage。<br>sessionStorage用于本地存储一个会话（session）中的数据，这些数据只在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁，sessionStorage不是一种持久化的本地存储。<br>而localStorage用于持久化的本地存储，除非主动删除数据，否则数据永远不会过期。<h3 id="3、web-storage和cookie的区别"><a href="#3、web-storage和cookie的区别" class="headerlink" title="3、web storage和cookie的区别"></a>3、web storage和cookie的区别</h3>web storage与cookie类似，但是它是为更大容量存储设计的。cookie的大小受限，并且每次请求一个新的页面的时候cookie都会被发送过去，这样无形浪费了带宽，另外cookie还指定了作用域，不可以跨域调用。<br>除此之外，web storage拥有setItem, getItem, removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie,getCookie。<br>但是cookie也是不可或缺的：cookie的作用是与服务器交互，作为HTTP规范的一部分而存在，而web storage仅仅作为本地存储数据而生。</li>
</ol>
<h2 id="CSS相关问题"><a href="#CSS相关问题" class="headerlink" title="CSS相关问题"></a>CSS相关问题</h2><h3 id="1、display-none和visibility：hidden的区别"><a href="#1、display-none和visibility：hidden的区别" class="headerlink" title="1、display:none和visibility：hidden的区别"></a>1、display:none和visibility：hidden的区别</h3><p>display:none  隐藏对应的元素，不给它分配空间，周围元素会合拢<br>visibility:hidden  隐藏对应的元素，但是在文档布局空间仍保留原来的空间</p>
<h3 id="2、css中link和-import的区别"><a href="#2、css中link和-import的区别" class="headerlink" title="2、css中link和@import的区别"></a>2、css中link和@import的区别</h3><p>1）link属于HTML标签，@import是css提供的<br>2）页面加载时，link同时被加载，而@import页面加载完后被加载的<br>3）link无兼容问题<br>4）link的样式权重高于@import</p>
<h3 id="3、position的absolute和fixed"><a href="#3、position的absolute和fixed" class="headerlink" title="3、position的absolute和fixed"></a>3、position的absolute和fixed</h3><p>共同点：<br>1、改变行内元素的呈现方式，display被设置为block<br>2、让元素脱离普通流，不占空间<br>3、默认会覆盖到非定位元素上<br>不同点：<br>absolute是相对于它最近的非static定位的祖先元素来定位的<br>fixed是根据屏幕视窗来定位的，屏幕滚动时位置不变</p>
<h3 id="4、清除浮动的三种方式"><a href="#4、清除浮动的三种方式" class="headerlink" title="4、清除浮动的三种方式"></a>4、清除浮动的三种方式</h3><p>首先说下浮动与绝对定位的区别。float是一种不彻底的脱离文档流的方式，绝对定位是彻底的。float脱离文档流的时候，其他盒子会无视这个元素，但其他盒子内的文本依然会为这个元素让出位置，环绕在周围；而绝对定位，其他盒子内的文本都会无视它（不会让出位置）。<br>比如：A为绝对定位，如果A使用的绝对定位，元素B会占据B之前的位置，与元素A重合在一起，并被元素A覆盖。<br>若A为float：left，B内的文本跑到了A的右边，即实现了文字环绕浮动元素的功，元素B的背景和元素A的背景重合了一部分，这就是浮动元素脱离了正常的文档流但还是会影响布局。<br>清楚浮动的三种方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;outer&quot;&gt;</div><div class="line">   &lt;div class=&quot;div1&quot;&gt;1&lt;/div&gt;</div><div class="line">   &lt;div class=&quot;div2&quot;&gt;2&lt;/div&gt;</div><div class="line">   &lt;div class=&quot;div3&quot;&gt;3&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>css样式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">.outer&#123;</div><div class="line">border:1 px solid #ccc;</div><div class="line">background:#fc9;</div><div class="line">color:#fff;</div><div class="line">margin:50px auto;</div><div class="line">padding:50px;&#125;</div><div class="line">.div1&#123;</div><div class="line">width:80px;height:80px;background:red;float:left;</div><div class="line">&#125;</div><div class="line">.div2&#123;</div><div class="line">width:80px;height:80px;background:blue;float:left;</div><div class="line">&#125;</div><div class="line">.div3&#123;</div><div class="line">width:80px;height:80px;background:green;float:left;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://i.imgur.com/gjAQ4Pu.png" alt=""></p>
<h4 id="方法一：增加新元素，应用clear：both"><a href="#方法一：增加新元素，应用clear：both" class="headerlink" title="方法一：增加新元素，应用clear：both"></a>方法一：增加新元素，应用clear：both</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;outer&quot;&gt;</div><div class="line">   &lt;div class=&quot;div1&quot;&gt;1&lt;/div&gt;</div><div class="line">   &lt;div class=&quot;div2&quot;&gt;2&lt;/div&gt;</div><div class="line">   &lt;div class=&quot;div3&quot;&gt;3&lt;/div&gt;</div><div class="line">   &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<p>CSS:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">.clear&#123;clear:both;&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://i.imgur.com/qTCFLjP.png" alt=""><br>在.outer的最后加入一个空的<div>（只要是块就行，因为只有块才可以撑满），因为它在.outer的最下面，并且不是float的，它的存在定义了.outer的高度。必须有clear：both，不然只是标准流，会紧贴在第一行的底部，不能涵盖其他div。<br>注：<br>clear的取值如下：<br>none：默认值，允许两边都可以浮动<br>left：不允许左边浮动对象<br>right：不允许右边有浮动对象<br>both：不允许有浮动对象<br>清除浮动只能影响清除的元素本身，不能影响其他元素，比如，div1的右边有浮动元素div2,在div1的css样式中加入clear：right不起任何作用，只能在div2的css样式中加clear：left。要想让上述三个div垂直排列，可以增加css样式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">.div2&#123;</div><div class="line">clear:left;</div><div class="line">&#125;</div><div class="line">.div3&#123;</div><div class="line">clear:left;</div><div class="line">&#125;</div></pre></td></tr></table></figure></div></p>
<p><img src="http://i.imgur.com/iE6kNtk.png" alt=""></p>
<h4 id="方法二：overflow"><a href="#方法二：overflow" class="headerlink" title="方法二：overflow"></a>方法二：overflow</h4><p>float元素的父元素设置overflow:hidden|auto|scroll(不能使用visible)，overflow不是清除float而是新建BFC，BFC类似于编程语言里的作用域，作用域变了，float就影响不到了，只有clear可以取消float的影响。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.outer&#123;</div><div class="line">overflow:auto;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="方法三：伪元素：after"><a href="#方法三：伪元素：after" class="headerlink" title="方法三：伪元素：after"></a>方法三：伪元素：after</h4><p>利用:after在元素内部插入一个元素块，从而达到清除浮动的效果，其实现原理类似于clear：both。区别在于：clear是在html插入一个div.clear标签，而outer利用其伪类:after在元素内部增加了一个类似于div.clear的效果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">.outer:after&#123;</div><div class="line">  content:&quot;.&quot;;</div><div class="line">  display:block;</div><div class="line">  clear:both;</div><div class="line">  visibility:hidden;</div><div class="line">  height:0;</div><div class="line">  width:0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="5、CSS的盒子模型：W3C盒子模型和IE盒子模型"><a href="#5、CSS的盒子模型：W3C盒子模型和IE盒子模型" class="headerlink" title="5、CSS的盒子模型：W3C盒子模型和IE盒子模型"></a>5、CSS的盒子模型：W3C盒子模型和IE盒子模型</h3><p>盒模型：content（内容）、padding（填充）、border（边框）、margin（边界）<br>IE的width包含padding和border，而W3C仅包含content。<br><img src="http://i.imgur.com/tE6VGpj.png" alt=""></p>
<h3 id="6、CSS选择符有哪些？哪些属性可以继承？优先级算法如何计算？CSS3新增的伪类？"><a href="#6、CSS选择符有哪些？哪些属性可以继承？优先级算法如何计算？CSS3新增的伪类？" class="headerlink" title="6、CSS选择符有哪些？哪些属性可以继承？优先级算法如何计算？CSS3新增的伪类？"></a>6、CSS选择符有哪些？哪些属性可以继承？优先级算法如何计算？CSS3新增的伪类？</h3><h4 id="一"><a href="#一" class="headerlink" title="一"></a>一</h4><p>1、id选择器 #id<br>2、类选择器 .classname<br>3、标签选择器 p，span<br>4、相邻选择器 div+p<br>5、子选择器 ul&gt;li<br>6、后代选择器 li a<br>7、通配符选择器 *<br>8、属性选择器 a[rel=”external”]<br>9、伪类选择器 a:hover, li:nth-child</p>
<h4 id="二"><a href="#二" class="headerlink" title="二"></a>二</h4><p>可继承的样式（大部分针对字体）：font-size,font-family,color,text-indent<br>不可继承的样式：border，padding，margin，width，height</p>
<h4 id="三"><a href="#三" class="headerlink" title="三"></a>三</h4><p>CSS优先级由四个级别和四个级别出现的次数决定，四个级别分别为：行内选择符、ID选择符、类选择符、元素选择符。CSS specificity是一个四位数用来衡量优先级。<br>如：div #id {font-size:12px;}<br>1个div元素，specificity为0,0,0,1<br>一个id选择符，specificity为0,1,0,0<br>最终：specificity为0,1,0,1<br>注意：</p>
<ol>
<li>！important的优先级是最高的，但出现冲突时则需比较四位数</li>
<li>优先级相同时采取就近原则</li>
<li>继承得来的属性，优先级最低</li>
<li>specificity从左到右比较，大的优先级越高<h4 id="四"><a href="#四" class="headerlink" title="四"></a>四</h4>CSS伪元素：</li>
</ol>
<ul>
<li>:after匹配该元素的一个虚拟的最后子元素，配合content使用，默认为行内元素</li>
<li>:before匹配该元素的一个虚拟的最先子元素，与:after类似</li>
<li>:first-line匹配元素的第一行</li>
<li>:first-letter匹配元素的第一个字符</li>
<li>:selection匹配用户鼠标选中的部分（只应用background、color、cursor、outline属性）<br>CSS伪类：</li>
<li>:link未被访问的链接</li>
<li>:visited被访问过的链接</li>
<li>:hover用户鼠标移至其上方</li>
<li>:active被激活的元素，通常指鼠标按下到松开的那段时间</li>
<li>:focus元素成为焦点</li>
<li>:first-child元素为其父元素的第一个子元素</li>
<li>:last-child元素为其父元素的最后一个子元素</li>
<li>:nth-child(an+b)匹配为其父元素的第an+b个子元素的元素</li>
<li>:nth-last-child(an+b)同上但是顺序相反</li>
<li>:first-of-type匹配所有子元素类型第一个出现的元素</li>
<li>:last-of-type匹配元素中所有子元素类型最后一个出线的元素</li>
<li>:enabled :disabled 控制表单控件的禁用状态</li>
<li>：checked 单选框或是复选框被选中<br>注意：first-child和first-of-type的区别，first-child匹配的是其父元素的第一个子元素，而first-of-type匹配到的是该类型的第一个。举个例子：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt;</div><div class="line">   &lt;p&gt;第一个子元素&lt;/p&gt;</div><div class="line">   &lt;h1&gt;第二个子元素&lt;/h1&gt;</div><div class="line">   &lt;span&gt;第三个子元素&lt;/span&gt;</div><div class="line">   &lt;span&gt;第四个子元素&lt;/span&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>p:first-child 匹配到p元素，因为p是div的第一个子元素<br>h1:first-child 匹配不到任何元素，因为h1不是第一个子元素<br>同理span:first-child也匹配不到<br>p:first-of-type 匹配到p元素，因为p元素是div所有为p的子元素的第一个<br>h1:first-of-type 匹配到h1元素，因为h1元素是div所有为h1的子元素的第一个<br>span:first-of-type 匹配到第三个子元素span，这里div有两个为span的元素，匹配到的是第一个</p>
<h3 id="7、列出display的值，说明他们的作用。position的值，relative和absolute分别是对于谁进行定位。"><a href="#7、列出display的值，说明他们的作用。position的值，relative和absolute分别是对于谁进行定位。" class="headerlink" title="7、列出display的值，说明他们的作用。position的值，relative和absolute分别是对于谁进行定位。"></a>7、列出display的值，说明他们的作用。position的值，relative和absolute分别是对于谁进行定位。</h3><ol>
<li></li>
</ol>
<ul>
<li>none 此元素不会被显示</li>
<li>block 此元素会显示为块级元素，前后会带有换行符</li>
<li>inline 此元素会被现实为内联元素，前后没有换行符</li>
<li>inline-block 行内块元素</li>
<li>list-item 此元素作为列表显示<br>2.</li>
<li>static 默认值，元素处于正常的文档流之中，top,right,bottom,left,z-index（设置元素的堆叠顺序）属性无效</li>
<li>relative 元素相对原本正常位置的定位，不改变布局，这样会在此元素原本所在的位置留下空白，对display为表格型的元素无效</li>
<li>absolute 不为元素预留空间，元素相对于与它最近的非static定位的祖先元素来定位。元素可以设置外边距（margin），并且不会与其他边距合并（即形成一个BFC）</li>
<li>fixed 不为元素预留空间，相对屏幕视窗定位，屏幕滚动时位置不变</li>
<li>sticky （新属性，目前仅firefox实现）平时为relative，在特定条件下变为fixed，类似于实现浮动条<br>-inherit 从父元素继承position属性的值<h3 id="8、对BFC规范的理解"><a href="#8、对BFC规范的理解" class="headerlink" title="8、对BFC规范的理解"></a>8、对BFC规范的理解</h3>BFC，块级格式上下文，一个创建了新的BFC的盒子是独立布局的，盒子里面的子元素的样式不会影响到外面的元素。在同一个BFC中的两个毗邻的块级盒在垂直方向的margin会发生折叠。<h3 id="9、CSS-spirite"><a href="#9、CSS-spirite" class="headerlink" title="9、CSS spirite"></a>9、CSS spirite</h3>CSS spirite把网页中的背景图片整合到一张图片文件中，再利用CSS的background-image, background-rep<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><h3 id="1、DOCTYPE"><a href="#1、DOCTYPE" class="headerlink" title="1、DOCTYPE"></a>1、DOCTYPE</h3>&lt;!DOCTYPE&gt;位于html文档的第一行，它并不是一个html标签。它的作用是告诉浏览器以哪种模式来解析文档。<br>HTML 5只有一种DOCTYPE声明，&lt;!DOCTYPE html&gt;<br>HTML 4.01有三种：strict、transitional、frameset。<h3 id="2、HTML5新特性"><a href="#2、HTML5新特性" class="headerlink" title="2、HTML5新特性"></a>2、HTML5新特性</h3></li>
<li>语义化标签（header、nav、footer、aside、article、section）</li>
<li>拖放事件（drag类事件）</li>
<li>跨文档消息传递（postMessage）</li>
<li>媒体元素（audio、video标签）</li>
<li>地理位置定位（navigator、geolocation）API</li>
<li>历史状态管理（更新history对象，pushstate等）<h4 id="HTML5离线存储技术"><a href="#HTML5离线存储技术" class="headerlink" title="HTML5离线存储技术"></a>HTML5离线存储技术</h4>用户离线时，可以正常访问站点时，联网可以更新缓存，使用方法就是在html标签中加入manifest属性，如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html manifest=&quot;cache.manifest&quot;&gt;</div><div class="line">...</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>cache.manifest文件格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">CACHE MANIFEST</div><div class="line"></div><div class="line">CACHE:</div><div class="line"></div><div class="line">js/app.js</div><div class="line">css/style.css</div><div class="line"></div><div class="line">NETWORK:</div><div class="line"></div><div class="line">resource/logo.png</div><div class="line"></div><div class="line">FALLBACK:</div><div class="line">/ /offline.html</div></pre></td></tr></table></figure></p>
<p>离线缓存的manifest一般由三个部分组成：</p>
<ol>
<li>CACHE:表示需要离线存储的资源列表</li>
<li>NETWORK:表示在它下面列出来的资源只有在有线的情况下才能访问，他们不会被离线存储</li>
<li>FALLBACK:(实例里’/ /‘不是注释）表示如果访问第一个资源失败，那么就使用第二个资源来替换它，比如上面这个文件表示的就是如果访问根目录下任何一个资源失败了，那么就去访问offline.html。<h3 id="3、iframe的优缺点"><a href="#3、iframe的优缺点" class="headerlink" title="3、iframe的优缺点"></a>3、iframe的优缺点</h3><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4></li>
</ol>
<ul>
<li>重载页面时不需要重载整个页面，只需要重载页面中的一个框架页（减少了数据的传输，加快了网页下载速度</li>
<li>技术容易掌握，使用方便，可主要应用于不需搜索引擎来搜索的页面</li>
<li>方便制作导航栏<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4></li>
<li>最大的缺点四搜索引擎无法解读这种页面</li>
<li>框架结构让人迷惑</li>
<li>浏览器后退按钮失效（之呢个针对当前光标所在页面的前进和后退）<h3 id="4、如何实现浏览器多个标签页之间的通信"><a href="#4、如何实现浏览器多个标签页之间的通信" class="headerlink" title="4、如何实现浏览器多个标签页之间的通信"></a>4、如何实现浏览器多个标签页之间的通信</h3>调用localStorage、cookie等本地存储方式<h3 id="5、WebSocket如何兼容低浏览器"><a href="#5、WebSocket如何兼容低浏览器" class="headerlink" title="5、WebSocket如何兼容低浏览器"></a>5、WebSocket如何兼容低浏览器</h3><h4 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">//创建WebSocket实例</div><div class="line">var socket=new WebSocket(&quot;ws://licalhost:8080&quot;);</div><div class="line"></div><div class="line">//打开WebSocket</div><div class="line">socket.onopen=function(event)&#123;</div><div class="line">  //发送一个初始化消息</div><div class="line">  socket.send(&apos;I am a client and i am listening&apos;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//监听消息</div><div class="line">socket.onmessage=function(event)&#123;</div><div class="line">  console.log(&apos;Client received a message&apos;);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">//监听关闭</div><div class="line">socket.onclose=function(event)&#123;</div><div class="line">  console.log(&apos;WebSocket closed&apos;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//关闭socket</div><div class="line">//socket.close();</div></pre></td></tr></table></figure>
</li>
</ul>
<p>WebSocket是HTML5出的协议，是一个持久化的协议，相对于http这种非持久化的协议来说。WebSocket是基于http协议的，在握手阶段是一样的，不同的是http每个request接收一个response，这个response是被动的，不能主动发起。<br>在讲WebSocket之前，先说long poll和ajax轮询。<br>ajax轮询：让浏览器每隔几秒就发送一次请求，询问服务器是否有新消息。<br>long pull:跟ajax轮询差不多，不过采取的是阻塞模型（不收到消息就不发response给客户端，知道有消息才返回，返回完后再次建立连接，周而复始）。<br>这两种方式都是不断建立http连接，然后等待服务器端处理，体现了http协议的被动性。而且两种方式都非常消耗资源，ajax需要服务器有很快的处理速度和资源，long poll需要很高的并发。</p>
<h5 id="WebSocket的作用"><a href="#WebSocket的作用" class="headerlink" title="WebSocket的作用"></a>WebSocket的作用</h5><p>WebSocket解决了http协议的被动性，服务器可以主动推送消息给客服端，只需要经过一次请求，就可以源源不断的消息传送；另外http是无状态的，每次都要传输identity info（鉴别信息）来告诉服务器你是谁，而WebSocket只需要一次握手，整个通讯过程都是建立在一次连接/状态中，避免了http的非状态性，服务器端会一直知道你的信息知道关闭请求。</p>
<h4 id="如何在不支持WebSocket的客户端上使用"><a href="#如何在不支持WebSocket的客户端上使用" class="headerlink" title="如何在不支持WebSocket的客户端上使用"></a>如何在不支持WebSocket的客户端上使用</h4><p>实际上是不能，但是可以通过上面说的long poll和ajax轮询来实现类似的效果</p>
<h3 id="6、null和undefined的区别"><a href="#6、null和undefined的区别" class="headerlink" title="6、null和undefined的区别"></a>6、null和undefined的区别</h3><h4 id="null"><a href="#null" class="headerlink" title="null"></a>null</h4><p>null表示的是一个“无”的对象，转为数值时为0<br>典型用法：</p>
<ul>
<li>作为函数的参数，表示该函数的参数不是对象</li>
<li>作为原型链的终点<h4 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h4>undefined表示的是一个“无”的原始值，转为数值是NaN<br>典型用法：</li>
<li>变量被声明了，但是没有赋值时，就等于underfined</li>
<li>调用函数时，应该提供的参数没有提供，该参数等于undefined</li>
<li>对象没有赋值的属性，该属性的值为undefined</li>
<li>函数没有返回值时，默认返回undefined<h3 id="7、new操作符具体干了什么"><a href="#7、new操作符具体干了什么" class="headerlink" title="7、new操作符具体干了什么"></a>7、new操作符具体干了什么</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var Fun=function()&#123;</div><div class="line"> &#125;</div><div class="line">var func=new Func();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>new共经历了四个阶段：</p>
<ol>
<li>创建一个空对象<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var obj=new Object();</div></pre></td></tr></table></figure>
</li>
</ol>
<p>2、设置原型链<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">obj._proto_=Func.prototype;(继承构造函数的属性和方法)</div></pre></td></tr></table></figure></p>
<p>3、让Func中的this指向obj，并执行Func函数体<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var result=Func.call(obj);</div></pre></td></tr></table></figure></p>
<h3 id="8、跨域问题"><a href="#8、跨域问题" class="headerlink" title="8、跨域问题"></a>8、跨域问题</h3><h4 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h4><p>在讲跨域问题之前先说同源策略。一个url由协议、域名、端口和路径组成，如果两个url协议、域名、端口相同，则表示它们同源。浏览器的同源策略是指一个域上加载的脚本不允许访问另一个域的文档属性。</p>
<h4 id="跨域方法"><a href="#跨域方法" class="headerlink" title="跨域方法"></a>跨域方法</h4><h5 id="1、跨域资源共享（CORS"><a href="#1、跨域资源共享（CORS" class="headerlink" title="1、跨域资源共享（CORS)"></a>1、跨域资源共享（CORS)</h5><p>创建CORS请求对象<br>因为CORS是属于XMLHttpRequest2的一部分，所以主要要做的就是区分IE8/9和不支持XMLHttpRequest的浏览器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">function createCoresRequest(method,url)&#123;</div><div class="line">   var xhr=new XMLHttpRequest();</div><div class="line">   if(&apos;withCredentials&apos; in xhr)&#123;</div><div class="line">      //支持CORS</div><div class="line">      //检查XMLHttpRequest对象是否有&quot;withCredentials&quot;属性，withCredentials仅存在xmlHttpRequest对象里</div><div class="line">      xhr.open(method,url,true);</div><div class="line">    &#125;</div><div class="line">   else if(window.XDomainRequest)&#123;</div><div class="line">     //XDomainRequest仅存在IE中，是IE用于支持CORS请求的方式</div><div class="line">     xhr=new C=XDomainRequest();</div><div class="line">     xhr.open(method,true);</div><div class="line">   &#125;</div><div class="line">   else&#123;</div><div class="line">      //不支持CORS</div><div class="line">      xhr=null;</div><div class="line">   &#125;</div><div class="line">   return xhr;</div><div class="line">  &#125;</div><div class="line">  var xhr=createCORSRequest(&quot;GET&quot;,url);</div><div class="line">  if(!xhr)&#123;</div><div class="line">     throw new Error(&apos;CORS not supported&apos;);</div><div class="line">   &#125;</div><div class="line">  xhr.send();//发送请求</div></pre></td></tr></table></figure></p>
<p>CORS是W3C提出的跨域请求方案，需要服务器端的支持。服务器端对CORS的支持主要通过设置HTTP头Access-Control-Allow-Origin实现，如果浏览器检测到相应的设置，就能允许AJAX跨域请求。</p>
<h5 id="2、通过jsonp跨域"><a href="#2、通过jsonp跨域" class="headerlink" title="2、通过jsonp跨域"></a>2、通过jsonp跨域</h5><p>JSONP也叫填充式json，是应用json的新方法，只不过是包含在函数中调用json，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">callback(&#123;&quot;name&quot;,&quot;jack&quot;&#125;)</div></pre></td></tr></table></figure></p>
<p>JSONP由两部分组成：回调函数和数据。回调函数是当响应到来时在页面中调用的函数，数据是传入回调函数的json数据。<br>在js中直接通过xmlHttpRequest请求不同域上的数据时，是不行的，但是，在页面上引入不同域的js脚本文件却是可以的，jsonp正是利用这个特性来实现的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;test/javascript&quot;&gt;</div><div class="line">   function dosomething(jsondata)&#123;</div><div class="line">     //处理json数据</div><div class="line">  &#125;</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;script src=&quot;http://example.data/data.php?callback=dosomething&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p>js文件载入成功后会执行url中指定的函数，并把需要的json数据作为参数传入该函数。<br>如果页面使用的是jquery，那么通过它封装的方法就能很方便的来进行JSONP操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">   $.getJSON(&quot;http://example.data/data.php?callback=?,function(jsondata)&quot;)&#123;</div><div class="line">     //处理获得json数据</div><div class="line">  &#125;）</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p>jQuery会自动生成一个全局函数来替换callback=？中的？，之后获取的数据又会自动销毁，实际上就是起一个临时代理函数的作用。$.getJSON方法会自动判断是否跨域，如果不跨域，就用普通的ajax方法，跨域的话，就会异步加载js文件的形式来调用jsonp的回调函数。</p>
<h6 id="JSOPN的优缺点"><a href="#JSOPN的优缺点" class="headerlink" title="JSOPN的优缺点"></a>JSOPN的优缺点</h6><ul>
<li>优点：不像XMLHttpRequest对象实现得Ajax请求那样受到同源策略的限制，它的兼容性更好，不需要XMLHttpRequest或ActiveX的支持，并且在请求完毕后可以通过调用callback方式回传结果。</li>
<li>缺点：它支持GET请求而不支持POST等其他类型的HTTP请求，它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行javascript调用的问题。<h6 id="CORS和JSONP的对比"><a href="#CORS和JSONP的对比" class="headerlink" title="CORS和JSONP的对比"></a>CORS和JSONP的对比</h6></li>
</ul>
<ol>
<li>JSONP只支持GET类型的http请求，CORS支持所有类型的http请求</li>
<li>CORS，开发者可以使用普通的XMLHttpRequest发起请求和获取数据，有更好的错误处理</li>
<li>JSONP主要被老的浏览器支持，它们往往不支持CORS，对大多数现代浏览器都已经支持CORS了<h5 id="3、通过修改document-domain来跨域（iframe）"><a href="#3、通过修改document-domain来跨域（iframe）" class="headerlink" title="3、通过修改document.domain来跨域（iframe）"></a>3、通过修改document.domain来跨域（iframe）</h5>浏览器的同源策略的两个限制：一、不能通过ajax方法去请求不同源的文档；二、浏览器中不同框架是不能进行js交互操作的。<br>比如：有一个页面，它的地址是”<a href="http://www.example.com/a.html&quot;，这个页面里有个iframe，它的iframe的src是&quot;http://example.com/a.html&quot;，很显然这个页面与它的iframe框架是不同域的，所以无法通过js代码来获取iframe的东西。" target="_blank" rel="external">http://www.example.com/a.html&quot;，这个页面里有个iframe，它的iframe的src是&quot;http://example.com/a.html&quot;，很显然这个页面与它的iframe框架是不同域的，所以无法通过js代码来获取iframe的东西。</a><br>此时document.domain就排上用场了，但是document.domain的设置有限制，只能将其设置成自身或者父域，且主域必须相同。</li>
<li><p>“<a href="http://www.example.com/a.html&quot;页面设置document.domain" target="_blank" rel="external">http://www.example.com/a.html&quot;页面设置document.domain</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;iframe id=&quot;iframe&quot; src=&quot;http://example.com/a.html&quot; onload=&quot;test()&quot;&gt;&lt;/iframe&gt;</div><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">   document.domain=&quot;example.com&quot;;//设置成主域</div><div class="line">   funtion test()&#123;</div><div class="line">      alert(document.getElementById(&quot;#ifrme&quot;).contentWindow);//可取得子窗口的window对象</div><div class="line">   &#125;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>“<a href="http://example.com/a.html&quot;设置document.domain" target="_blank" rel="external">http://example.com/a.html&quot;设置document.domain</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">   document.domain=&quot;example.com&quot;;//设置成主域</div><div class="line"></div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>注：document.domain只适用于不同子域的框架中。</p>
<h5 id="4、window-name"><a href="#4、window-name" class="headerlink" title="4、window.name"></a>4、window.name</h5><p>在一个窗口的生命周期内，不同url共享同一个window.name，每个页面对window.name都有读写权限，且window.name持久存在一个窗口在载入过的所有页面中。</p>
<h5 id="5、HTML5的window-postMessage方法"><a href="#5、HTML5的window-postMessage方法" class="headerlink" title="5、HTML5的window.postMessage方法"></a>5、HTML5的window.postMessage方法</h5><p>HTML5的新特性，不能实现与服务器交换数据，只能在不同的iframe中使用。<br>window.postMessage(message,targetOrigin).</p>
<h3 id="9、document-write和innerHTML的区别"><a href="#9、document-write和innerHTML的区别" class="headerlink" title="9、document.write和innerHTML的区别"></a>9、document.write和innerHTML的区别</h3><p>document.write是直接写入页面的文档流，如果写之前没有调用document.open，浏览器会自动调用open，每次写完之后重新调用该函数，会导致整个页面的重绘。<br>innerHTML能精确到某个具体的元素来更改，只对页面的部分重绘。</p>
<h3 id="10、内存泄露"><a href="#10、内存泄露" class="headerlink" title="10、内存泄露"></a>10、内存泄露</h3><p>内存泄漏：是指任何对象不再拥有或需要它之后仍然存在。<br>javascript有自动垃圾回收机制，一旦数据不再使用，可以将其设为null来释放引用。<br>造成内存泄漏的集中操作：</p>
<ol>
<li>循环引用<br>一个DOM对象被一个javascript对象引用，与此同时又引用同一个或其他的javascript对象，这个DOM对象可能会引发内存泄露。这个DOM对象的引用将不会在脚本停止的时候被垃圾回收器回收。要想破坏引用，引用DOM元素的随想或DOM对象的引用需要被赋值为null。</li>
<li><p>闭包<br>在闭包中引入闭包外部的变量时，当闭包结束时此对象无法被垃圾回收。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var a=function()&#123;</div><div class="line">   var largeStr=new Array(1000000).join(&quot;x&quot;);</div><div class="line">    return function()&#123;</div><div class="line">      return largeStr;</div><div class="line">     &#125;</div><div class="line">&#125;();</div></pre></td></tr></table></figure>
</li>
<li><p>DOM泄露<br>父节点被删除时，子节点引用没有被移除则无法回收。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var select=document.querySelector;</div><div class="line">var treeRef=select(&quot;#tree&quot;);</div><div class="line"></div><div class="line">var leaf=select(&quot;#leaf&quot;);//#leaf是#tree的子节点</div><div class="line">var body=select(&quot;body&quot;);</div><div class="line"></div><div class="line">body.removeChild(treeleaf);</div><div class="line">//#tree不能被回收，因为treeLeaf还在</div><div class="line">//解决方案</div><div class="line">treeRef=null;</div><div class="line"></div><div class="line">//tree不能被回收，一位内叶子leaf还在</div><div class="line">leaf=null;</div><div class="line"></div><div class="line">//现在#tree被释放了</div></pre></td></tr></table></figure>
</li>
</ol>
<p>4、Timer定时器泄露<br>定时器也是常见的产生泄露的地方<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">for(var i=0;i&lt;90000;i++)&#123;</div><div class="line">   var b=&#123;</div><div class="line">      callAgain:function()&#123;</div><div class="line">        var ref=this;</div><div class="line">        var val=setTimeout(function()&#123;</div><div class="line">            ref.callAgain();</div><div class="line">         &#125;,90000);</div><div class="line">     &#125;</div><div class="line">    &#125;</div><div class="line">b.callAgain();</div><div class="line">//虽然很想收回但是timer还在</div><div class="line">b=null;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="11、作用域链"><a href="#11、作用域链" class="headerlink" title="11、作用域链"></a>11、作用域链</h3><p>作用域链、闭包、原型链是javascript中比较重要的知识点。</p>
<h4 id="javascript中的作用域"><a href="#javascript中的作用域" class="headerlink" title="javascript中的作用域"></a>javascript中的作用域</h4><p>每一种语言都有作用域的概念，所谓作用域就是变量和函数的可用范围，确定了变量和函数的可见性和生命周期。<br>javascript中有两种作用域，全局作用域和局部作用域。</p>
<h5 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h5><p>以下情况一般拥有全局作用域</p>
<ul>
<li>全局声明的函数和变量</li>
<li>没有定义直接赋值的变量</li>
<li>所以window属性<h5 id="局部作用域"><a href="#局部作用域" class="headerlink" title="局部作用域"></a>局部作用域</h5>在函数内部声明的函数和变量只能在函数内部访问到，即拥有局部作用域。<h4 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h4>javascript中，一切都是对象，包括函数。而函数有一个内部属性[[scope]]，里面包含了函数的可访问的作用域对象的集合，这个集合被称为作用域链。<h5 id="作用域链的创建"><a href="#作用域链的创建" class="headerlink" title="作用域链的创建"></a>作用域链的创建</h5>作用域链在函数执行时创建。<strong>作用域的前端，始终是当前环境的变量对象</strong>。如果这个环境是函数，则将其活动对象作为变量对象，里面包含了该函数的所有局部变量、参数及this。<br>把作用域链当成一个对象数组，先把该函数的变量对象push进数组，然后把函数的外部环境的作用域push进数组，下一个就是外部环境的外部环境的变量对象，一直往外直到全局环境，<strong>即作用域链的最后一个对象肯定是全局环境的作用域</strong>。<h5 id="作用域链的作用"><a href="#作用域链的作用" class="headerlink" title="作用域链的作用"></a>作用域链的作用</h5>作用域链的目的是<strong>保证当前环境对可访问的变量和函数的有序访问。</strong><br>具体实现是：函数内部标识符解析时会沿着作用域链一级一级地搜索。搜索的过程始终从作用域链前端开始，直到最后一个对象即全局变量对象为止，如果找不到的话，就是undefined。<br>这样可以保证内部变量的优先级始终大于外部变量。<h5 id="变量提升的问题"><a href="#变量提升的问题" class="headerlink" title="变量提升的问题"></a>变量提升的问题</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var name=&quot;123&quot;;</div><div class="line">function foo()&#123;</div><div class="line">   console.log(name); //undefined</div><div class="line">   var name=&quot;456&quot;;</div><div class="line">   console.log(name);  //456</div><div class="line">&#125;</div><div class="line">foo();</div></pre></td></tr></table></figure>
</li>
</ul>
<p>以上例子，按常规连接，应该先输出全局变量“123”，再输出局部变量“456”，然而第一个却输出了undefined，为什么呢？<br>因为函数在执行时首先胡创建作用域链，这是在整个函数执行之前就完成的，所以第一次输出时，该函数的变量对象已经包含了name这个变量，从而导致解析时在作用域链第一个对象就停止，，而不会访问到全局变量，同时那个时候局部变量没有赋值，所以会输出undefined。这种现象叫做变量提升。<br>注：ES6中通过let标识符可以防止这种现象的出现</p>
<h5 id="作用域链的延长"><a href="#作用域链的延长" class="headerlink" title="作用域链的延长"></a>作用域链的延长</h5><p>部分语句可以在作用域链的前端临时增加一个变量对象，该变量对象会在代码执行后移除。主要由两种情况</p>
<ol>
<li>with语句</li>
<li>try-catch语句<h6 id="with语句"><a href="#with语句" class="headerlink" title="with语句"></a>with语句</h6>平时优化需要可以把所需对象存储在局部变量中，不推荐使用with语句，可能造成bug和性能损失。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function foo()&#123;</div><div class="line">  var he=&quot;?name=1&quot;;</div><div class="line">  with(location)&#123;</div><div class="line">    var url=href+he;</div><div class="line">   &#125;</div><div class="line">  return url;</div><div class="line">&#125;</div><div class="line">foo();</div></pre></td></tr></table></figure>
</li>
</ol>
<p>这里with语句把location对象添加到作用域链前端，因此在访问href时，其实是访问了location.href。在with语句执行完毕后，作用域链就返回之前的状态。</p>
<h6 id="catch块"><a href="#catch块" class="headerlink" title="catch块"></a>catch块</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">try&#123;</div><div class="line">  something();</div><div class="line">&#125;catch(e)&#123;</div><div class="line">  console.log(e);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当try代码块中的语句发生错误时，执行块跳转到catch语句块，并且把一个异常对象添加到作用域的头部。在catch语句执行完毕后，作用域链就返回之前的状态。<br>注：可以把错误处理委托给一个函数。这样的话就只执行一条语句，并且没有访问局部变量，对性能影响就比较小。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">try&#123;</div><div class="line">  something();</div><div class="line">&#125;catch(e)&#123;</div><div class="line">  handleError(e);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="12、闭包"><a href="#12、闭包" class="headerlink" title="12、闭包"></a>12、闭包</h3><h4 id="闭包的特性"><a href="#闭包的特性" class="headerlink" title="闭包的特性"></a>闭包的特性</h4><ol>
<li>函数嵌套函数</li>
<li>内部的函数可以引用函数外部的参数和变量</li>
<li>参数和变量不能被垃圾回收机制回收<h4 id="闭包的定义及其优缺点"><a href="#闭包的定义及其优缺点" class="headerlink" title="闭包的定义及其优缺点"></a>闭包的定义及其优缺点</h4>闭包：是指有权访问另一个函数作用域中的变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量。<br>闭包的缺点：常驻内存，会增加大量的内存使用，使用不当会造成内存泄漏。<br>闭包的应用：一是前面提到的读取函数内部的变量，二是让这些变量的值始终保持在内存中。<br>看个例子：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function f1()&#123;</div><div class="line">   var n=999;</div><div class="line">   add=function()&#123;</div><div class="line">      n+=1;</div><div class="line">   &#125;</div><div class="line">   function f2()&#123;</div><div class="line">      alert(n);</div><div class="line">   &#125;</div><div class="line">   return f2;</div><div class="line">&#125;</div><div class="line">var result=f1();</div><div class="line">result();//999</div><div class="line">add();</div><div class="line">result();</div></pre></td></tr></table></figure>
</li>
</ol>
<p>result实际上就是闭包f2函数，它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。<br>为什么会这样呢？因为f1是f2的复函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制回收。<br>另外要注意add，首先add前面没有使用var关键字，因此add是一个全局变量，而不是局部变量。其次add的值是一个匿名函数，而这个匿名函数本身也是一个闭包，所以add相当于一个setter，可以在函数外部对函数内部的局部变量进行操作。</p>
<h4 id="闭包使用注意点"><a href="#闭包使用注意点" class="headerlink" title="闭包使用注意点"></a>闭包使用注意点</h4><ol>
<li>由于闭包会使得函数中的变量都保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页性能问题，IE中可能导致内存泄漏。解决办法是，在退出函数之前，将不适用的局部变量全部删除。</li>
<li>闭包会在父函数外部，改变父函数内部变量的值。如果把父函数当作对象使用，把闭包当作它的公用方法，把内部变量当作它的私有属性，这是一定要小心，不要随便改变父函数内部变量的值。<h3 id="13、javascript中的this"><a href="#13、javascript中的this" class="headerlink" title="13、javascript中的this"></a>13、javascript中的this</h3>一般而言，javascript中<strong>this指向函数执行时的当前对象</strong>。换句话说，这个关键字<strong>与函数的执行环境有关，与声明环境无关</strong>。所以this的指向要看如何去调用这个函数而不是声明。<h4 id="不同的调用方式"><a href="#不同的调用方式" class="headerlink" title="不同的调用方式"></a>不同的调用方式</h4><h5 id="1、作为对象的方法调用"><a href="#1、作为对象的方法调用" class="headerlink" title="1、作为对象的方法调用"></a>1、作为对象的方法调用</h5>把函数赋值给对象的一个属性，然后通过该对象调用该方法，此时函数的执行环境就是这个对象，所以this指向该对象。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var name=&quot;haha&quot;;</div><div class="line">var obj=&#123;</div><div class="line">  name:&quot;hehe&quot;,</div><div class="line">  show:function()&#123;</div><div class="line">     console.log(this.name);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">obj.show(); //hehe</div></pre></td></tr></table></figure>
</li>
</ol>
<p>换种更清晰的方式，我们把声明和调用放在两个对象里面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var obj=&#123;</div><div class="line">   name:&quot;hehe&quot;,</div><div class="line">   show:function()&#123;</div><div class="line">      console.log(this.name)</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line">var t_obj=&#123;</div><div class="line">   name:&quot;lala&quot;,</div><div class="line">   show:obj_show</div><div class="line">&#125;</div><div class="line">t_obj.show();  //lala</div></pre></td></tr></table></figure></p>
<p>可以看到show虽然在obj中声明过，但是通过t_obj调用了这个方法，所以此时this指向t_obj。</p>
<h5 id="2、作为函数调用"><a href="#2、作为函数调用" class="headerlink" title="2、作为函数调用"></a>2、作为函数调用</h5><p>我们将上面的代码改一下，将obj.show赋值给全局变量show再调用，此时this绑定到全局对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var name=&quot;lala&quot;;</div><div class="line">var obj=&#123;</div><div class="line">   name:&quot;hehe&quot;,</div><div class="line">   show:function()&#123;</div><div class="line">      console.log(this.name);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line">var show=obj.show;</div><div class="line">show(); //lala</div></pre></td></tr></table></figure></p>
<h5 id="3、独立函数调用"><a href="#3、独立函数调用" class="headerlink" title="3、独立函数调用"></a>3、独立函数调用</h5><p>在函数内部调用一个函数，比如在一个对象的方法里面调用一个函数时，this会指向全局对象(讲道理的话应该指向对象），实际上是不带任何修饰的函数引用进行调用时，默认this指向全局变量。这是javascript设计比较坑的地方，平时经常使用命名一个新变量ctx(context，即上下文环境)替代this。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var name=&quot;lala&quot;;</div><div class="line">var obj=&#123;</div><div class="line">   name:&quot;hehe&quot;,</div><div class="line">   show:function()&#123;</div><div class="line">      var test=function()&#123;</div><div class="line">          console.log(this.name);</div><div class="line">       &#125;</div><div class="line">      test();</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line">obj.show();  //lala</div></pre></td></tr></table></figure></p>
<p>修正版<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var name=&quot;lala&quot;;</div><div class="line">var obj=&#123;</div><div class="line">   name:&quot;hehe&quot;,</div><div class="line">   show:function()&#123;</div><div class="line">      var txt=this;</div><div class="line">      console.log(this);//obj</div><div class="line">      var test=function()&#123;</div><div class="line">          console.log(this.name);</div><div class="line">       &#125;</div><div class="line">      test();</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line">obj.show();  // hehe</div></pre></td></tr></table></figure></p>
<p>再看一个例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var name=&quot;lala&quot;;</div><div class="line">function b()&#123;</div><div class="line">  var name=&quot;hehe&quot;</div><div class="line">  function a()&#123;</div><div class="line">     console.log(this.name);</div><div class="line">   &#125;</div><div class="line">  a();</div><div class="line">&#125;</div><div class="line">b(); //lala</div></pre></td></tr></table></figure></p>
<p>修改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var name=&quot;lala&quot;;</div><div class="line">function b()&#123;</div><div class="line">  var cxt=this;</div><div class="line">  console.log(this);//window</div><div class="line">  var name=&quot;hehe&quot;</div><div class="line">  function a()&#123;</div><div class="line">     console.log(ctx.name);</div><div class="line">   &#125;</div><div class="line">  a();</div><div class="line">&#125;</div><div class="line">b(); //lala</div></pre></td></tr></table></figure></p>
<p>可以看到对比上一个例子，obj.show中的this指向obj，而第二个例子由于b是独立函数，b中的this指向全局对象，有一个误区认为this指向执行的函数，实际上不是的。</p>
<h5 id="4、作为构造函数使用"><a href="#4、作为构造函数使用" class="headerlink" title="4、作为构造函数使用"></a>4、作为构造函数使用</h5><p>我们常使用new构造函数名()来创建一个对象，此时函数中的this指向新创建的对象。如果不使用new，则和普通函数一样绑定到全局对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function Foo()&#123;</div><div class="line">   console.log(this);</div><div class="line">&#125;</div><div class="line">var test=new Foo(); //test</div><div class="line">Foo(); //window</div></pre></td></tr></table></figure></p>
<h5 id="5、在setTimeout、setInterval和匿名函数中"><a href="#5、在setTimeout、setInterval和匿名函数中" class="headerlink" title="5、在setTimeout、setInterval和匿名函数中"></a>5、在setTimeout、setInterval和匿名函数中</h5><p>在setTimeout,setInterval和匿名执行时的对象为全局对象，所以this也指向全局对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var name=&quot;lala&quot;;</div><div class="line">var obj=&#123;</div><div class="line">  name:&quot;hehe&quot;,</div><div class="line">  show:function()&#123;</div><div class="line">     setTimeout(function()&#123;</div><div class="line">        console.log(this.name);</div><div class="line">      &#125;,500);</div><div class="line">   &#125;</div><div class="line"> &#125;</div><div class="line">obj.show();</div></pre></td></tr></table></figure></p>
<h5 id="6、函数调用call和apply方法时"><a href="#6、函数调用call和apply方法时" class="headerlink" title="6、函数调用call和apply方法时"></a>6、函数调用call和apply方法时</h5><p>两者的本质就是改变函数当前的上下文环境即this，两者的区别是call接收一个个参数，而apply接受一个参数数组。<br>注：使用call和apply函数的时候要主要，如果传递的this值不是一个对象，javascript将会尝试使用内部ToObject操作将其转换为对象。因此，如果传递的值，如果传递的值是一个原始值比如7或者”foo”，那么就会使用相关构造函数将它转换为对象，所以原始值7通过new Number(7)被转换为对象，而字符串”foo”使用new String(“foo”)转化为对象。</p>
<h5 id="7、函数调用bind方法时"><a href="#7、函数调用bind方法时" class="headerlink" title="7、函数调用bind方法时"></a>7、函数调用bind方法时</h5><p>函数调用bind方法时会创建一个有相同函数体和作用域的函数，新函数的this指向bind的第一个参数。该方法不会调用函数，而是返回新函数。</p>
<h3 id="14、prototype和原型链"><a href="#14、prototype和原型链" class="headerlink" title="14、prototype和原型链"></a>14、prototype和原型链</h3><p>每个函数都有一个prototype属性，这个属性是指向一个对象的引用，这个对象称为原型对象，原型对象包含函数实例共享的方法和属性，也就是说将函数用作构造函数调用的时候，新创建的对象会从原型对象上继承属性和方法。不像传统的面向对象语言，<strong>javascript的继承机制基于原型</strong>，而不是class类。</p>
<h4 id="1、javascript的设计意图"><a href="#1、javascript的设计意图" class="headerlink" title="1、javascript的设计意图"></a>1、javascript的设计意图</h4><ol>
<li><p>私有变量、函数<br>javascript的作用域链，在函数内定义的变量和函数如果不对外提供接口，外部将无法访问到，也就是变为私有变量和私有函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function Obj()&#123; </div><div class="line">   var a=0;  //私有变量</div><div class="line">   var fn=function()&#123;  //私有函数</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">var o=new Obj();</div><div class="line">console.log(o.a)  //undefined</div><div class="line">console.log(o.fn) //undefined</div></pre></td></tr></table></figure>
</li>
<li><p>静态变量、函数<br>当定义一个函数后，通过“.”为其添加属性和函数，通过对象本身仍然可以访问得到，但是其实例访问不到，这样的变量和函数分别被称为静态变量和静态函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function Obj()&#123;&#125;</div><div class="line">   Obj.a=0;  //静态变量</div><div class="line">   Obj.fn=function()&#123;  //静态函数</div><div class="line">    &#125;</div><div class="line"></div><div class="line">console.log(Obj.a) //0</div><div class="line">console.log(Obj.fn) //function()&#123;  //静态函数 &#125;</div><div class="line">var o=new Obj();</div><div class="line">console.log(o.a)  //undefined</div><div class="line">console.log(o.fn) //undefined</div></pre></td></tr></table></figure>
</li>
<li><p>实例变量、函数<br>在面向对象编程中除了一些库函数我们还希望在对象定义的时候同时定义一些属性和方法，实例化后可以访问，javascript也可以做到这样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function Obj()&#123;</div><div class="line">   this.a=[];  //实例变量</div><div class="line">   this.fn=function()&#123;  //实例函数</div><div class="line">   &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">console.log(typeof Obj.a)  //undefined</div><div class="line">console.log(typeof Obj.fn)  //undefined</div><div class="line">var o=new Obj();</div><div class="line">console.log(typeof o.a)  //object</div><div class="line">console.log(typeof o.fn)  //function</div></pre></td></tr></table></figure>
</li>
</ol>
<p>这样可以达到目的，然而<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function Obj()&#123;</div><div class="line">   this.a=[];//实例变量</div><div class="line">   this.fn=function()&#123; //实例方法</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">var o1=new Obj();</div><div class="line">o1.a.push(1);</div><div class="line">o1.fn=&#123;&#125;; </div><div class="line">console.log(o1.a);  //[1]</div><div class="line">console.log(typeof o1.fn); //object</div><div class="line">var o2=new Obj();</div><div class="line">console.log(o2.a);  //[]</div><div class="line">console.log(typeof o2.fn) //function</div></pre></td></tr></table></figure></p>
<p>虽然可以实例访问了，但是在o1中修改了a和fn，在o2中没有改变，由于数组和函数都是对象，是引用类型，这说明o1和o2中的属性和方法虽然同名但不是一个引用，而是对Obj对象定义的属性和方法的一个复制。<br>这对属性来说没什么问题，但是对方法来说，因为方法都是在做完全一样的功能，但是却有两份复制，如果一个函数对象有上千个实例方法，每个实例都要保持一份上千个方法的复制，这显然不科学，因此prototype应运而生。<br><strong>原型对象的主要目的是让所有对象实例共享它所包含的属性和方法。</strong></p>
<h4 id="2、prototype原型"><a href="#2、prototype原型" class="headerlink" title="2、prototype原型"></a>2、prototype原型</h4><p>在javascript中，所有都是对象。但对象是有区别的，分为普通对象和函数对象。<strong>凡是通过new Funtion()的方式创建的对象都是函数对象，其他都是普通对象</strong>。<br>每个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。<strong>prototype就是调用构造函数而创建的那个对象实例的原型对象。</strong>普通对象没有prototype，但是有<em>proto</em>属性。<br>原型对象其实就是普通对象（Funtion.prototype除外，它是函数对象，但它很特殊，它没有prototype属性（前面说函数对象都有prototype属性））。举个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function f1()&#123;&#125;;</div><div class="line">console.log(f1.prototype) //f1&#123;&#125;</div><div class="line">console.log(typeof f1.prototype) //object</div><div class="line">console.log(typeof Function.prototype) // function，这个特殊</div><div class="line">console.log(typeof Object.prototype) // object</div><div class="line">console.log(typeof Function.prototype.prototype) //undefined</div></pre></td></tr></table></figure></p>
<p>从console.log(f1.prototype)//f1{}看出，f1.prototype就是f1的实例对象。就是f1创建的时候，创建了一个实例对象并赋值给它的prototype，过程如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var temp=new f1();</div><div class="line">f1.prototype=temp;</div></pre></td></tr></table></figure></p>
<p>所以Function.prototype为什么时函数对象就迎刃而解，上文提到凡是new Function产生的对象都是函数对象，所以temp1是函数对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var temp1=new Function();</div><div class="line">Function.prototype=temp1;</div></pre></td></tr></table></figure></p>
<p>那原型对象是用来做什么呢？主要是用来继承，举个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var person=function(name)&#123;</div><div class="line">  this.name=name;</div><div class="line">&#125;</div><div class="line">person.prototype.getName=function()&#123;</div><div class="line">  return this.name;//this指向源性对象</div><div class="line">&#125;</div><div class="line">var xpg=new Person(&quot;alice&quot;)</div><div class="line">xpg.getName() //alice</div></pre></td></tr></table></figure></p>
<p>从这里看出，person.prototype设置了一个函数对象的属性，那由person实例出来的对象就继承了这个属性。具体继承机制看原型链。<br>无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性（同时它也是一个对象），默认情况下prototype属性会默认获得一个constructor（构造函数）属性，这个属性是一个指向prototype属性所在函数的指针。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">function Person()&#123;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://i.imgur.com/V16NjcO.png" alt=""><br>可以看到Person对象会自动获得prototype属性，而prototype也是一个对象，会自动获得constructor属性，该属性正是指向Person对象。<br>当调用构造函数创建一个实例的时候，实例内部将包含一个内部指针<strong>（<em>proto</em>）指向构造函数的prototype，这个连接存在于实例和构造函数的prototype之间，而不是实例与构造函数之间。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function Person(name)&#123;</div><div class="line">   this.name=name;</div><div class="line">&#125;</div><div class="line">Person.prototype.printName=function()&#123;</div><div class="line">  alert(this.name)</div><div class="line">&#125;</div><div class="line">var person1=new Person(&quot;Byron&quot;)</div><div class="line">var person2=new Person(&quot;Frank&quot;)</div></pre></td></tr></table></figure></p>
<p><img src="http://i.imgur.com/Ilyjg8u.png" alt=""></p>
<p>Person的实例person1中包含了name属性，同时自动生成一个<strong>proto</strong>属性，该属性指向Person的prototype，可以访问到prototype内定义的printName方法：<br><img src="http://i.imgur.com/XuwCD60.png" alt=""></p>
<h4 id="3、原型链"><a href="#3、原型链" class="headerlink" title="3、原型链"></a>3、原型链</h4><p>由于<strong>proto</strong>是任何对象都有的属性，而js里万物皆对象，所以会形成一条<strong>proto</strong>连起来的链。<br>代码读取某个对象的属性的时候，都会执行一遍搜索，目标是具有给定名字的属性，搜索首先从对象实例开始，如果实例中找到该属性则返回，如果没有则查找prototype，如果还没有找到则继续递归prototype的prototype对象，直到找到为止，如果递归到object仍然没有怎返回错误。同理如果在实例中定义prototype同名的属性或函数，则会覆盖prototype的属性或函数。这就是javascript的原型链。<br><img src="http://i.imgur.com/UwVMlkn.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var A = function()&#123;&#125;;</div><div class="line">var a = new A();</div><div class="line">console.log(a.__proto__); //A &#123;&#125;（即构造器function A 的原型对象）</div><div class="line">console.log(a.__proto__.__proto__); //Object &#123;&#125;（即构造器function Object 的原型对象）</div><div class="line">console.log(a.__proto__.__proto__.__proto__); //null</div></pre></td></tr></table></figure></p>
<h4 id="4、hasOwnProperty与in操作符"><a href="#4、hasOwnProperty与in操作符" class="headerlink" title="4、hasOwnProperty与in操作符"></a>4、hasOwnProperty与in操作符</h4><p>in操作符是只要能访问到该属性就返回true，hasOwnProperty只有属性存在于实例中时才返回true。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Object.prototype.bar=1</div><div class="line">var foo=&#123;moo:2&#125;</div><div class="line">for(var i in foo)&#123;</div><div class="line">if(foo.hasOwnProperty(i))</div><div class="line">  console.log(i) //输出两个属性： moo和bar</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们没有办法改变for in语句的行为，所以想过滤结果就只能使用hasOwnProperty方法，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for(var i in foo)&#123;</div><div class="line">  if(foo.hasOwnProperty(i))</div><div class="line">    console.log(i) // moo</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>prototype指向该方法的原型对象，只有函数对象有prototype<br><strong>proto</strong>是指向该对象的构造函数的原型对象，所有对象都有<strong>proto</strong>，<strong>proto</strong>是普通对象的隐式属性，在new的时候会指向该对象的构造函数的原型对象</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function F()&#123;</div><div class="line">&#125;</div><div class="line">var f=new F();</div><div class="line">f.__proto__==F.prototype //true</div></pre></td></tr></table></figure></p>
<p>构造函数.prototype=原型对象<br>原型对象.constructor=构造函数<br>实例.<strong>proto</strong>=构造函数.prototype<br>isPrototypeof(实例对象)判断实例对象的原型是不是当前对象。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/06/25/原生JavaScript实现Ajax/" title="原生JavaScript实现Ajax" itemprop="url">原生JavaScript实现Ajax</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Alice" target="_blank" itemprop="author">Alice</a>
		
  <p class="article-time">
    <time datetime="2017-06-25T12:21:18.000Z" itemprop="datePublished"> Published 2017-06-25</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>Ajax实现步骤：</p>
<h3 id="创建XMLHttpRequest对象"><a href="#创建XMLHttpRequest对象" class="headerlink" title="创建XMLHttpRequest对象"></a>创建XMLHttpRequest对象</h3><p>XMLHttpRequest用于在后台与服务器交换数据，可以在不重新加载整个网页的情况下，对网页的部分进行更新。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var XHR=if(window.XMLHttpRequest)&#123;</div><div class="line">   XHR=new XMLHttpRequest();</div><div class="line">&#125;else if(window.ActiveXObject)&#123;//IE6</div><div class="line">   XHR=new ActiveXobject(&apos;Microsoft.XMLHTTP&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注：ActiveXObject对象在IE11中已移除。</p>
<h3 id="想服务器发送请求"><a href="#想服务器发送请求" class="headerlink" title="想服务器发送请求"></a>想服务器发送请求</h3><p>首先调用open方法，有五个参数（常用的前三个）：</p>
<ol>
<li>method:必须提供，用来指定发送请求的HTTP方法（GET, POST等）</li>
<li>uri：请求的url，会被自动解析成绝对地址</li>
<li>async:请求是否是异步的，默认是true</li>
<li>username, password:如果需要服务器验证用户，则设置username和password这两个参数。<br>然后调用send方法，按照open方法设定的参数将请求进去发送<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">if(type==&apos;GET&apos;)&#123;</div><div class="line">   //拼接GET方法的URL</div><div class="line">   if(typeof(data)!=&apos;undefined&apos;)&#123;</div><div class="line">      url+=&apos;?&apos;;</div><div class="line">      for(i in data)&#123;</div><div class="line">          url+=i+&apos;=&apos;+data[i]+&apos;&amp;&apos;;</div><div class="line">       &#125;</div><div class="line">      url=url.substring(0,url.length-1); //去掉最后一个&apos;&amp;&apos;</div><div class="line">    &#125;</div><div class="line">    XHR.open(type,url,true);</div><div class="line">    XHR.send(null);</div><div class="line">&#125;else if(type==&apos;POST&apos;)&#123;</div><div class="line">    XHR.open(type,url,true);</div><div class="line">    XHR.send(data);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>注：理论上GET方法也有body，但一般约定GET的参数都放在URL上，所以type为GET时，send的参数一般是null.</p>
<h4 id="get和post的区别"><a href="#get和post的区别" class="headerlink" title="get和post的区别"></a>get和post的区别</h4><p>它们的结构和使用方式相同，区别：</p>
<ol>
<li>get请求会将参数跟在url后进行传递，而post则是将参数作为http消息的实体内容发给web服务器 （对用户是不可见的）</li>
<li>get对传输数据有大小限制（通常不能大于2kb），而post传递的数据量要比get大得多（理论上没有限制。但get效率更高，一般用来查询</li>
<li>get方式请求的数据会被浏览缓存，post则不会，get具有安全问题、</li>
<li>get方式和post方式传递的数据在服务器端的获取也不相同<h3 id="服务器响应"><a href="#服务器响应" class="headerlink" title="服务器响应"></a>服务器响应</h3>在讲响应之前，先介绍一下readyState属性，readyState标识了当前对象正处于什么状态。<br><img src="http://i.imgur.com/k4q4mxH.png" alt=""><br>另外介绍一下status属性，status属性描述了HTTP状态代码，一下常用的状态码：<br><img src="http://i.imgur.com/uOPv6zj.png" alt=""><br><img src="http://i.imgur.com/L8Znsb2.png" alt=""><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">XHR.onreadystatechange=function()&#123;//readyState的值发生改变时就会触发onreadystatechange</div><div class="line">   if(readystate==4)&#123;</div><div class="line">      if(XHR.status&gt;=200&amp;&amp;XHR.status&lt;300||XHR.status==304)&#123;</div><div class="line">         //请求成功</div><div class="line">      &#125;else&#123;</div><div class="line">         //请求失败</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>注：</p>
<ol>
<li>status仅当readyState的状态是3或者4的时候才可用</li>
<li>send()方法必须在readyState的属性值是1，即调用open()方法以后才能调用</li>
</ol>
<h4 id="http-302-303-307"><a href="#http-302-303-307" class="headerlink" title="http 302 303 307"></a>http 302 303 307</h4><p>302作为HTTP 1.0的标准，现在使用只是为了兼容性的处理。<br>HTTP 1.1有303 307作为详细的补充，其实是对302的细化<br>302：指示资源在另一个位置，该位置通过;Location指定<br>303：请求的资源可以在另一个URI处找到，客户端必须使用GET方法来获取新位置的资源<br>307：后续请求资源的方法是使用与当前交互相同的方法而不是全部使用GET</p>
<h4 id="Ajax的交互模型"><a href="#Ajax的交互模型" class="headerlink" title="Ajax的交互模型"></a>Ajax的交互模型</h4><ul>
<li>用户发出请求</li>
<li>创建XMLHttpRequest对象</li>
<li>告诉XMLHttpRequest对象哪个函数会处理XMLHttpRequest对象状态的改变，为此要把对象的onReadyStateChange属性设置为响应该事件的JavaScript函数的引用</li>
<li>创建请求，用open方法指定get还是post，是否同步，url地址</li>
<li>发送请求，send方法</li>
<li>接收结果并分析</li>
<li>实现刷新</li>
</ul>
<h4 id="同步与异步的区别"><a href="#同步与异步的区别" class="headerlink" title="同步与异步的区别"></a>同步与异步的区别</h4><p>同步：脚本会停留等待服务器发送回复然后再继续<br>异步：脚本允许页面继续其进程并处理可能的回复</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <a class="extend prev" rel="prev" href="/page/2/"><span></span>Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/4/">Next<span></span></a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  


  

  

  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
        
          <li>
            
            	<a href="https://github.com/jsfront/" target="_blank" title="JS高级前端开发">JS高级前端开发</a>
            
          </li>
        
          <li>
            
            	<a href="https://segmentfault.com/" target="_blank" title="segmentfault">segmentfault</a>
            
          </li>
        
          <li>
            
            	<a href="https://stackoverflow.com/" target="_blank" title="stackoverflow">stackoverflow</a>
            
          </li>
        
          <li>
            
            	<a href="https://github.com/jikeytang/front-end-collect" target="_blank" title="前端收集">前端收集</a>
            
          </li>
        
    </ul>
</div>

  


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m Alice Page in Google. <br/>
			This is my blog,believe it or not.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/2176287895" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>
<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>










<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->









<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
