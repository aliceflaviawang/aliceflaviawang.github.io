
 <!DOCTYPE HTML>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
  
    <title>前端面试准备 | 笑呵呵</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Alice">
    
    
    
    <meta name="description" content="1、cookie的优点及弊端如果步骤5携带的是过期或者错误的cookie，那么将认证失败，返回至要求身份认证页面。 优点：极高的扩展性和可用性1、通过良好的编程，控制保存在cookie中的session对象的大小2、通过加密和安全传输技术（SSL），减少cookie被破解的可能性3、只在cookie中存放不敏感数据，即使被盗也不会有重大损失4、控制cookie的生命期，使之不会永远有效。 缺点：1">
<meta name="keywords">
<meta property="og:type" content="article">
<meta property="og:title" content="前端面试准备">
<meta property="og:url" content="https://aliceflaviawang.github.io/2017/07/03/前端面试准备/index.html">
<meta property="og:site_name" content="笑呵呵">
<meta property="og:description" content="1、cookie的优点及弊端如果步骤5携带的是过期或者错误的cookie，那么将认证失败，返回至要求身份认证页面。 优点：极高的扩展性和可用性1、通过良好的编程，控制保存在cookie中的session对象的大小2、通过加密和安全传输技术（SSL），减少cookie被破解的可能性3、只在cookie中存放不敏感数据，即使被盗也不会有重大损失4、控制cookie的生命期，使之不会永远有效。 缺点：1">
<meta property="og:image" content="http://i.imgur.com/NU4tepj.png">
<meta property="og:image" content="http://i.imgur.com/gjAQ4Pu.png">
<meta property="og:image" content="http://i.imgur.com/qTCFLjP.png">
<meta property="og:image" content="http://i.imgur.com/iE6kNtk.png">
<meta property="og:image" content="http://i.imgur.com/tE6VGpj.png">
<meta property="og:image" content="http://i.imgur.com/V16NjcO.png">
<meta property="og:image" content="http://i.imgur.com/Ilyjg8u.png">
<meta property="og:image" content="http://i.imgur.com/XuwCD60.png">
<meta property="og:image" content="http://i.imgur.com/UwVMlkn.png">
<meta property="og:updated_time" content="2017-08-18T03:02:33.407Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="前端面试准备">
<meta name="twitter:description" content="1、cookie的优点及弊端如果步骤5携带的是过期或者错误的cookie，那么将认证失败，返回至要求身份认证页面。 优点：极高的扩展性和可用性1、通过良好的编程，控制保存在cookie中的session对象的大小2、通过加密和安全传输技术（SSL），减少cookie被破解的可能性3、只在cookie中存放不敏感数据，即使被盗也不会有重大损失4、控制cookie的生命期，使之不会永远有效。 缺点：1">
<meta name="twitter:image" content="http://i.imgur.com/NU4tepj.png">

    
    <link rel="alternative" href="/atom.xml" title="笑呵呵" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.png">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/favicon.png" alt="笑呵呵" title="笑呵呵"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="笑呵呵">笑呵呵</a></h1>
				<h2 class="blog-motto">We were moving mountains long before we knew we could</h2>
			</div>
			
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">首页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/about">关于</a></li>
					
					<li>
 					
						<form class="search" action="http://zhannei.baidu.com/cse/search" target="_blank">
							<label>Search</label>
						<input name="s" type="hidden" value= null ><input type="text" name="q" size="30" placeholder="搜索"><br>
						</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/07/03/前端面试准备/" title="前端面试准备" itemprop="url">前端面试准备</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Alice" target="_blank" itemprop="author">Alice</a>
		
  <p class="article-time">
    <time datetime="2017-07-03T09:03:08.000Z" itemprop="datePublished"> 发表于 2017-07-03</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		
			<ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、cookie的优点及弊端"><span class="toc-number">1.</span> <span class="toc-text">1、cookie的优点及弊端</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#优点：极高的扩展性和可用性"><span class="toc-number">1.1.</span> <span class="toc-text">优点：极高的扩展性和可用性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#缺点："><span class="toc-number">1.2.</span> <span class="toc-text">缺点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#session"><span class="toc-number">1.3.</span> <span class="toc-text">session</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cookie与session的区别"><span class="toc-number">1.4.</span> <span class="toc-text">cookie与session的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、浏览器的本地存储（web-storage）"><span class="toc-number">2.</span> <span class="toc-text">2、浏览器的本地存储（web storage）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3、web-storage和cookie的区别"><span class="toc-number">3.</span> <span class="toc-text">3、web storage和cookie的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSS相关问题"><span class="toc-number"></span> <span class="toc-text">CSS相关问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、display-none和visibility：hidden的区别"><span class="toc-number">1.</span> <span class="toc-text">1、display:none和visibility：hidden的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、css中link和-import的区别"><span class="toc-number">2.</span> <span class="toc-text">2、css中link和@import的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3、position的absolute和fixed"><span class="toc-number">3.</span> <span class="toc-text">3、position的absolute和fixed</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4、清除浮动的三种方式"><span class="toc-number">4.</span> <span class="toc-text">4、清除浮动的三种方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#方法一：增加新元素，应用clear：both"><span class="toc-number">4.1.</span> <span class="toc-text">方法一：增加新元素，应用clear：both</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#方法二：overflow"><span class="toc-number">4.2.</span> <span class="toc-text">方法二：overflow</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#方法三：伪元素：after"><span class="toc-number">4.3.</span> <span class="toc-text">方法三：伪元素：after</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5、CSS的盒子模型：W3C盒子模型和IE盒子模型"><span class="toc-number">5.</span> <span class="toc-text">5、CSS的盒子模型：W3C盒子模型和IE盒子模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6、CSS选择符有哪些？哪些属性可以继承？优先级算法如何计算？CSS3新增的伪类？"><span class="toc-number">6.</span> <span class="toc-text">6、CSS选择符有哪些？哪些属性可以继承？优先级算法如何计算？CSS3新增的伪类？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#一"><span class="toc-number">6.1.</span> <span class="toc-text">一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#二"><span class="toc-number">6.2.</span> <span class="toc-text">二</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#三"><span class="toc-number">6.3.</span> <span class="toc-text">三</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#四"><span class="toc-number">6.4.</span> <span class="toc-text">四</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7、列出display的值，说明他们的作用。position的值，relative和absolute分别是对于谁进行定位。"><span class="toc-number">7.</span> <span class="toc-text">7、列出display的值，说明他们的作用。position的值，relative和absolute分别是对于谁进行定位。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8、对BFC规范的理解"><span class="toc-number">8.</span> <span class="toc-text">8、对BFC规范的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9、CSS-spirite"><span class="toc-number">9.</span> <span class="toc-text">9、CSS spirite</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10、text-overflow-这个属性貌似问的比较多"><span class="toc-number">10.</span> <span class="toc-text">10、text-overflow(这个属性貌似问的比较多)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTML"><span class="toc-number"></span> <span class="toc-text">HTML</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、DOCTYPE"><span class="toc-number">1.</span> <span class="toc-text">1、DOCTYPE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、HTML5新特性"><span class="toc-number">2.</span> <span class="toc-text">2、HTML5新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HTML5离线存储技术"><span class="toc-number">2.1.</span> <span class="toc-text">HTML5离线存储技术</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3、iframe的优缺点"><span class="toc-number">3.</span> <span class="toc-text">3、iframe的优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#优点："><span class="toc-number">3.1.</span> <span class="toc-text">优点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#缺点"><span class="toc-number">3.2.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4、如何实现浏览器多个标签页之间的通信"><span class="toc-number">4.</span> <span class="toc-text">4、如何实现浏览器多个标签页之间的通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5、WebSocket如何兼容低浏览器"><span class="toc-number">5.</span> <span class="toc-text">5、WebSocket如何兼容低浏览器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#WebSocket"><span class="toc-number">5.1.</span> <span class="toc-text">WebSocket</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#WebSocket的作用"><span class="toc-number">5.1.1.</span> <span class="toc-text">WebSocket的作用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如何在不支持WebSocket的客户端上使用"><span class="toc-number">5.2.</span> <span class="toc-text">如何在不支持WebSocket的客户端上使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6、null和undefined的区别"><span class="toc-number">6.</span> <span class="toc-text">6、null和undefined的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#null"><span class="toc-number">6.1.</span> <span class="toc-text">null</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-number">6.2.</span> <span class="toc-text">undefined</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7、new操作符具体干了什么"><span class="toc-number">7.</span> <span class="toc-text">7、new操作符具体干了什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8、跨域问题"><span class="toc-number">8.</span> <span class="toc-text">8、跨域问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#同源策略"><span class="toc-number">8.1.</span> <span class="toc-text">同源策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#跨域方法"><span class="toc-number">8.2.</span> <span class="toc-text">跨域方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1、跨域资源共享（CORS"><span class="toc-number">8.2.1.</span> <span class="toc-text">1、跨域资源共享（CORS)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2、通过jsonp跨域"><span class="toc-number">8.2.2.</span> <span class="toc-text">2、通过jsonp跨域</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#JSOPN的优缺点"><span class="toc-number">8.2.2.1.</span> <span class="toc-text">JSOPN的优缺点</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#CORS和JSONP的对比"><span class="toc-number">8.2.2.2.</span> <span class="toc-text">CORS和JSONP的对比</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3、通过修改document-domain来跨域（iframe）"><span class="toc-number">8.2.3.</span> <span class="toc-text">3、通过修改document.domain来跨域（iframe）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4、window-name"><span class="toc-number">8.2.4.</span> <span class="toc-text">4、window.name</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5、HTML5的window-postMessage方法"><span class="toc-number">8.2.5.</span> <span class="toc-text">5、HTML5的window.postMessage方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9、document-write和innerHTML的区别"><span class="toc-number">9.</span> <span class="toc-text">9、document.write和innerHTML的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10、内存泄露"><span class="toc-number">10.</span> <span class="toc-text">10、内存泄露</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11、作用域链"><span class="toc-number">11.</span> <span class="toc-text">11、作用域链</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#javascript中的作用域"><span class="toc-number">11.1.</span> <span class="toc-text">javascript中的作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#全局作用域"><span class="toc-number">11.1.1.</span> <span class="toc-text">全局作用域</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#局部作用域"><span class="toc-number">11.1.2.</span> <span class="toc-text">局部作用域</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#作用域链"><span class="toc-number">11.2.</span> <span class="toc-text">作用域链</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#作用域链的创建"><span class="toc-number">11.2.1.</span> <span class="toc-text">作用域链的创建</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#作用域链的作用"><span class="toc-number">11.2.2.</span> <span class="toc-text">作用域链的作用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#变量提升的问题"><span class="toc-number">11.2.3.</span> <span class="toc-text">变量提升的问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#作用域链的延长"><span class="toc-number">11.2.4.</span> <span class="toc-text">作用域链的延长</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#with语句"><span class="toc-number">11.2.4.1.</span> <span class="toc-text">with语句</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#catch块"><span class="toc-number">11.2.4.2.</span> <span class="toc-text">catch块</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12、闭包"><span class="toc-number">12.</span> <span class="toc-text">12、闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#闭包的特性"><span class="toc-number">12.1.</span> <span class="toc-text">闭包的特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#闭包的定义及其优缺点"><span class="toc-number">12.2.</span> <span class="toc-text">闭包的定义及其优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#闭包使用注意点"><span class="toc-number">12.3.</span> <span class="toc-text">闭包使用注意点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13、javascript中的this"><span class="toc-number">13.</span> <span class="toc-text">13、javascript中的this</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#不同的调用方式"><span class="toc-number">13.1.</span> <span class="toc-text">不同的调用方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1、作为对象的方法调用"><span class="toc-number">13.1.1.</span> <span class="toc-text">1、作为对象的方法调用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2、作为函数调用"><span class="toc-number">13.1.2.</span> <span class="toc-text">2、作为函数调用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3、独立函数调用"><span class="toc-number">13.1.3.</span> <span class="toc-text">3、独立函数调用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4、作为构造函数使用"><span class="toc-number">13.1.4.</span> <span class="toc-text">4、作为构造函数使用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5、在setTimeout、setInterval和匿名函数中"><span class="toc-number">13.1.5.</span> <span class="toc-text">5、在setTimeout、setInterval和匿名函数中</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6、函数调用call和apply方法时"><span class="toc-number">13.1.6.</span> <span class="toc-text">6、函数调用call和apply方法时</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7、函数调用bind方法时"><span class="toc-number">13.1.7.</span> <span class="toc-text">7、函数调用bind方法时</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14、prototype和原型链"><span class="toc-number">14.</span> <span class="toc-text">14、prototype和原型链</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1、javascript的设计意图"><span class="toc-number">14.1.</span> <span class="toc-text">1、javascript的设计意图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2、prototype原型"><span class="toc-number">14.2.</span> <span class="toc-text">2、prototype原型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3、原型链"><span class="toc-number">14.3.</span> <span class="toc-text">3、原型链</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4、hasOwnProperty与in操作符"><span class="toc-number">14.4.</span> <span class="toc-text">4、hasOwnProperty与in操作符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#总结"><span class="toc-number">14.5.</span> <span class="toc-text">总结</span></a></li></ol></li></ol>
		
		</div>
		
		<h3 id="1、cookie的优点及弊端"><a href="#1、cookie的优点及弊端" class="headerlink" title="1、cookie的优点及弊端"></a>1、cookie的优点及弊端</h3><p><img src="http://i.imgur.com/NU4tepj.png" alt=""><br>如果步骤5携带的是过期或者错误的cookie，那么将认证失败，返回至要求身份认证页面。</p>
<h4 id="优点：极高的扩展性和可用性"><a href="#优点：极高的扩展性和可用性" class="headerlink" title="优点：极高的扩展性和可用性"></a>优点：极高的扩展性和可用性</h4><p>1、通过良好的编程，控制保存在cookie中的session对象的大小<br>2、通过加密和安全传输技术（SSL），减少cookie被破解的可能性<br>3、只在cookie中存放不敏感数据，即使被盗也不会有重大损失<br>4、控制cookie的生命期，使之不会永远有效。</p>
<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><p>1、cookie数量和长度的限制。每个domain最多只能有20条cookie，每个cookie长度不能超过4KB，否则会被截掉。<br>2、安全性问题。如果cookie被拦截了，就可以获取所以的session信息。即使加密也于事无补，因为拦截者不需要知道cookie的意义，只需要原样转发cookie就行了。<br>3、有些状态不可能保存在客户端。如：为了防止重复提交表单，在服务器端保存计数器，如果计数器放在客户端就起不了任何作用。</p>
<h4 id="session"><a href="#session" class="headerlink" title="session"></a>session</h4><p>session是一种服务器端机制，服务器类似于散列表的结构来保存信息。当程序需要为客户端请求创建一个session时，服务器首先检查这个客户端的请求是否包含了session标志（session id），如果已包含则说明服务端曾经为用户创建过session，服务器就按照session id将session检索处理（检索不到会新建），如果不包含则会新建session并生产与之关联的session id（既不重复也不容易被找到规律仿造），找个session id将在本次响应中返回给客户端保存（保存这个session id的方式可以用cookie，另外还有两种方式：基于url path parameter默认支持的，基于SSL，默认不支持）。</p>
<p>补充session<br>sessionid是一个会话的key，浏览器第一次访问服务器会在服务端生成一个sessionid和它对应。<br>以tomcat为例，session在访问tomcat服务器HttpServerRequest的getSession(true)的时候创建，tomcat的ManagerBase类提供创建sessionid的方法：随机数+时间+jvmid;<br>存储：存储在服务器的内存中，客户端只保存sessionid到cookie中。<br>创建：sessionid第一次产生是在直到某server端程序调用HttpServletRequest.getSession(true)这样的语句时才被创建<br>删除：超时；程序调用HttpSession.invalidate();程序关闭</p>
<h4 id="cookie与session的区别"><a href="#cookie与session的区别" class="headerlink" title="cookie与session的区别"></a>cookie与session的区别</h4><ol>
<li>cookie有大小和个数的限制，单个cookie大小不超过4kb，很多浏览器限制一个站点最多保存20个cookie</li>
<li>cookie保存在客户端，session保存在服务器端</li>
<li>cookie不是很安全，别人可以分析存放在本地的cookie并进行欺骗；因此建议将登陆等重要信息保存在服务器端，其他信息放在cookie中</li>
<li>session会在一定时间内保存在服务器上，当访问增多，会比较占用服务器的性能，考虑到减轻服务器的负担应当使用cookie<h3 id="2、浏览器的本地存储（web-storage）"><a href="#2、浏览器的本地存储（web-storage）" class="headerlink" title="2、浏览器的本地存储（web storage）"></a>2、浏览器的本地存储（web storage）</h3>js提供了sessionStorage和globalStorage。在HTML5中提供了localStorage取代了globalStorage。<br>sessionStorage用于本地存储一个会话（session）中的数据，这些数据只在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁，sessionStorage不是一种持久化的本地存储。<br>而localStorage用于持久化的本地存储，除非主动删除数据，否则数据永远不会过期。<h3 id="3、web-storage和cookie的区别"><a href="#3、web-storage和cookie的区别" class="headerlink" title="3、web storage和cookie的区别"></a>3、web storage和cookie的区别</h3>web storage与cookie类似，但是它是为更大容量存储设计的。cookie的大小受限，并且每次请求一个新的页面的时候cookie都会被发送过去，这样无形浪费了带宽，另外cookie还指定了作用域，不可以跨域调用。<br>除此之外，web storage拥有setItem, getItem, removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie,getCookie。<br>但是cookie也是不可或缺的：cookie的作用是与服务器交互，作为HTTP规范的一部分而存在，而web storage仅仅作为本地存储数据而生。</li>
</ol>
<h2 id="CSS相关问题"><a href="#CSS相关问题" class="headerlink" title="CSS相关问题"></a>CSS相关问题</h2><h3 id="1、display-none和visibility：hidden的区别"><a href="#1、display-none和visibility：hidden的区别" class="headerlink" title="1、display:none和visibility：hidden的区别"></a>1、display:none和visibility：hidden的区别</h3><p>display:none  隐藏对应的元素，不给它分配空间，周围元素会合拢<br>visibility:hidden  隐藏对应的元素，但是在文档布局空间仍保留原来的空间</p>
<h3 id="2、css中link和-import的区别"><a href="#2、css中link和-import的区别" class="headerlink" title="2、css中link和@import的区别"></a>2、css中link和@import的区别</h3><p>1）link属于HTML标签，@import是css提供的<br>2）页面加载时，link同时被加载，而@import页面加载完后被加载的<br>3）link无兼容问题<br>4）link的样式权重高于@import</p>
<h3 id="3、position的absolute和fixed"><a href="#3、position的absolute和fixed" class="headerlink" title="3、position的absolute和fixed"></a>3、position的absolute和fixed</h3><p>共同点：<br>1、改变行内元素的呈现方式，display被设置为block<br>2、让元素脱离普通流，不占空间<br>3、默认会覆盖到非定位元素上<br>不同点：<br>absolute是相对于它最近的非static定位的祖先元素来定位的<br>fixed是根据屏幕视窗来定位的，屏幕滚动时位置不变</p>
<h3 id="4、清除浮动的三种方式"><a href="#4、清除浮动的三种方式" class="headerlink" title="4、清除浮动的三种方式"></a>4、清除浮动的三种方式</h3><p>首先说下浮动与绝对定位的区别。float是一种不彻底的脱离文档流的方式，绝对定位是彻底的。float脱离文档流的时候，其他盒子会无视这个元素，但其他盒子内的文本依然会为这个元素让出位置，环绕在周围；而绝对定位，其他盒子内的文本都会无视它（不会让出位置）。<br>比如：A为绝对定位，如果A使用的绝对定位，元素B会占据B之前的位置，与元素A重合在一起，并被元素A覆盖。<br>若A为float：left，B内的文本跑到了A的右边，即实现了文字环绕浮动元素的功，元素B的背景和元素A的背景重合了一部分，这就是浮动元素脱离了正常的文档流但还是会影响布局。<br>清楚浮动的三种方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;outer&quot;&gt;</div><div class="line">   &lt;div class=&quot;div1&quot;&gt;1&lt;/div&gt;</div><div class="line">   &lt;div class=&quot;div2&quot;&gt;2&lt;/div&gt;</div><div class="line">   &lt;div class=&quot;div3&quot;&gt;3&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>css样式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">.outer&#123;</div><div class="line">border:1 px solid #ccc;</div><div class="line">background:#fc9;</div><div class="line">color:#fff;</div><div class="line">margin:50px auto;</div><div class="line">padding:50px;&#125;</div><div class="line">.div1&#123;</div><div class="line">width:80px;height:80px;background:red;float:left;</div><div class="line">&#125;</div><div class="line">.div2&#123;</div><div class="line">width:80px;height:80px;background:blue;float:left;</div><div class="line">&#125;</div><div class="line">.div3&#123;</div><div class="line">width:80px;height:80px;background:green;float:left;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://i.imgur.com/gjAQ4Pu.png" alt=""></p>
<h4 id="方法一：增加新元素，应用clear：both"><a href="#方法一：增加新元素，应用clear：both" class="headerlink" title="方法一：增加新元素，应用clear：both"></a>方法一：增加新元素，应用clear：both</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;outer&quot;&gt;</div><div class="line">   &lt;div class=&quot;div1&quot;&gt;1&lt;/div&gt;</div><div class="line">   &lt;div class=&quot;div2&quot;&gt;2&lt;/div&gt;</div><div class="line">   &lt;div class=&quot;div3&quot;&gt;3&lt;/div&gt;</div><div class="line">   &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<p>CSS:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">.clear&#123;clear:both;&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://i.imgur.com/qTCFLjP.png" alt=""><br>在.outer的最后加入一个空的<div>（只要是块就行，因为只有块才可以撑满），因为它在.outer的最下面，并且不是float的，它的存在定义了.outer的高度。必须有clear：both，不然只是标准流，会紧贴在第一行的底部，不能涵盖其他div。<br>注：<br>clear的取值如下：<br>none：默认值，允许两边都可以浮动<br>left：不允许左边浮动对象<br>right：不允许右边有浮动对象<br>both：不允许有浮动对象<br>清除浮动只能影响清除的元素本身，不能影响其他元素，比如，div1的右边有浮动元素div2,在div1的css样式中加入clear：right不起任何作用，只能在div2的css样式中加clear：left。要想让上述三个div垂直排列，可以增加css样式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">.div2&#123;</div><div class="line">clear:left;</div><div class="line">&#125;</div><div class="line">.div3&#123;</div><div class="line">clear:left;</div><div class="line">&#125;</div></pre></td></tr></table></figure></div></p>
<p><img src="http://i.imgur.com/iE6kNtk.png" alt=""></p>
<h4 id="方法二：overflow"><a href="#方法二：overflow" class="headerlink" title="方法二：overflow"></a>方法二：overflow</h4><p>float元素的父元素设置overflow:hidden|auto|scroll(不能使用visible)，overflow不是清除float而是新建BFC，BFC类似于编程语言里的作用域，作用域变了，float就影响不到了，只有clear可以取消float的影响。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.outer&#123;</div><div class="line">overflow:auto;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="方法三：伪元素：after"><a href="#方法三：伪元素：after" class="headerlink" title="方法三：伪元素：after"></a>方法三：伪元素：after</h4><p>利用:after在元素内部插入一个元素块，从而达到清除浮动的效果，其实现原理类似于clear：both。区别在于：clear是在html插入一个div.clear标签，而outer利用其伪类:after在元素内部增加了一个类似于div.clear的效果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">.outer:after&#123;</div><div class="line">  content:&quot;.&quot;;</div><div class="line">  display:block;</div><div class="line">  clear:both;</div><div class="line">  visibility:hidden;</div><div class="line">  height:0;</div><div class="line">  width:0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="5、CSS的盒子模型：W3C盒子模型和IE盒子模型"><a href="#5、CSS的盒子模型：W3C盒子模型和IE盒子模型" class="headerlink" title="5、CSS的盒子模型：W3C盒子模型和IE盒子模型"></a>5、CSS的盒子模型：W3C盒子模型和IE盒子模型</h3><p>盒模型：content（内容）、padding（填充）、border（边框）、margin（边界）<br>IE的width包含padding和border，而W3C仅包含content。<br><img src="http://i.imgur.com/tE6VGpj.png" alt=""></p>
<p>在这个地方顺便提下css的box-sizing属性，box-sizing主要是允许以特定的方式定义匹配某个区域的特定元素。有三种取值：1.content-box：规定宽度高度，不包括padding、border、margin 2. border-box:规定宽度高度，包括padding和boder 3. inherit：规定从父元素继承box-sizing属性的值。</p>
<h3 id="6、CSS选择符有哪些？哪些属性可以继承？优先级算法如何计算？CSS3新增的伪类？"><a href="#6、CSS选择符有哪些？哪些属性可以继承？优先级算法如何计算？CSS3新增的伪类？" class="headerlink" title="6、CSS选择符有哪些？哪些属性可以继承？优先级算法如何计算？CSS3新增的伪类？"></a>6、CSS选择符有哪些？哪些属性可以继承？优先级算法如何计算？CSS3新增的伪类？</h3><h4 id="一"><a href="#一" class="headerlink" title="一"></a>一</h4><p>1、id选择器 #id<br>2、类选择器 .classname<br>3、标签选择器 p，span<br>4、相邻选择器 div+p<br>5、子选择器 ul&gt;li<br>6、后代选择器 li a<br>7、通配符选择器 *<br>8、属性选择器 a[rel=”external”]<br>9、伪类选择器 a:hover, li:nth-child</p>
<h4 id="二"><a href="#二" class="headerlink" title="二"></a>二</h4><p>可继承的样式（大部分针对字体）：font-size,font-family,color,text-indent<br>不可继承的样式：border，padding，margin，width，height</p>
<h4 id="三"><a href="#三" class="headerlink" title="三"></a>三</h4><p>CSS优先级由四个级别和四个级别出现的次数决定，四个级别分别为：行内选择符、ID选择符、类选择符、元素选择符。CSS specificity是一个四位数用来衡量优先级。<br>如：div #id {font-size:12px;}<br>1个div元素，specificity为0,0,0,1<br>一个id选择符，specificity为0,1,0,0<br>最终：specificity为0,1,0,1<br>注意：</p>
<ol>
<li>！important的优先级是最高的，但出现冲突时则需比较四位数</li>
<li>优先级相同时采取就近原则</li>
<li>继承得来的属性，优先级最低</li>
<li>specificity从左到右比较，大的优先级越高<h4 id="四"><a href="#四" class="headerlink" title="四"></a>四</h4>CSS伪元素：</li>
</ol>
<ul>
<li>:after匹配该元素的一个虚拟的最后子元素，配合content使用，默认为行内元素</li>
<li>:before匹配该元素的一个虚拟的最先子元素，与:after类似</li>
<li>:first-line匹配元素的第一行</li>
<li>:first-letter匹配元素的第一个字符</li>
<li>:selection匹配用户鼠标选中的部分（只应用background、color、cursor、outline属性）<br>CSS伪类：</li>
<li>:link未被访问的链接</li>
<li>:visited被访问过的链接</li>
<li>:hover用户鼠标移至其上方</li>
<li>:active被激活的元素，通常指鼠标按下到松开的那段时间</li>
<li>:focus元素成为焦点</li>
<li>:first-child元素为其父元素的第一个子元素</li>
<li>:last-child元素为其父元素的最后一个子元素</li>
<li>:nth-child(an+b)匹配为其父元素的第an+b个子元素的元素</li>
<li>:nth-last-child(an+b)同上但是顺序相反</li>
<li>:first-of-type匹配所有子元素类型第一个出现的元素</li>
<li>:last-of-type匹配元素中所有子元素类型最后一个出线的元素</li>
<li>:enabled :disabled 控制表单控件的禁用状态</li>
<li>：checked 单选框或是复选框被选中<br>注意：first-child和first-of-type的区别，first-child匹配的是其父元素的第一个子元素，而first-of-type匹配到的是该类型的第一个。举个例子：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt;</div><div class="line">   &lt;p&gt;第一个子元素&lt;/p&gt;</div><div class="line">   &lt;h1&gt;第二个子元素&lt;/h1&gt;</div><div class="line">   &lt;span&gt;第三个子元素&lt;/span&gt;</div><div class="line">   &lt;span&gt;第四个子元素&lt;/span&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>p:first-child 匹配到p元素，因为p是div的第一个子元素<br>h1:first-child 匹配不到任何元素，因为h1不是第一个子元素<br>同理span:first-child也匹配不到<br>p:first-of-type 匹配到p元素，因为p元素是div所有为p的子元素的第一个<br>h1:first-of-type 匹配到h1元素，因为h1元素是div所有为h1的子元素的第一个<br>span:first-of-type 匹配到第三个子元素span，这里div有两个为span的元素，匹配到的是第一个</p>
<h3 id="7、列出display的值，说明他们的作用。position的值，relative和absolute分别是对于谁进行定位。"><a href="#7、列出display的值，说明他们的作用。position的值，relative和absolute分别是对于谁进行定位。" class="headerlink" title="7、列出display的值，说明他们的作用。position的值，relative和absolute分别是对于谁进行定位。"></a>7、列出display的值，说明他们的作用。position的值，relative和absolute分别是对于谁进行定位。</h3><ol>
<li></li>
</ol>
<ul>
<li>none 此元素不会被显示</li>
<li>block 此元素会显示为块级元素，前后会带有换行符</li>
<li>inline 此元素会被现实为内联元素，前后没有换行符</li>
<li>inline-block 行内块元素</li>
<li>list-item 此元素作为列表显示</li>
</ul>
<p>问的比较多的就是inline,block,inline-block，详细比较一下它们：<br> <strong>display：block</strong></p>
<ul>
<li>block元素会独占一行，多个block元素会各自新起一行。默认情况下，block元素宽度自动填满其父元素宽度</li>
<li>block元素可以设置width、height属性。块级元素即使设置了宽度，仍然独占一行</li>
<li>block元素可以设置margin和padding属性<br><strong>display:inline</strong></li>
<li>inline元素不会独占一行，多个相邻的行内元素会排列在同一行里，直到一行排列不下，才会新换一行，其宽度随元素的内容而变化</li>
<li>inline元素设置width、height无效</li>
<li>inline元素的margin和padding属性，水平方向的padding-left,padding-right,margin-left,margin-right都产生边距效果，但竖直方向的padding-top,padding-bottom,margin-top,margin-bottom都不起作用。<br><strong>display：inline-block</strong><br>简单来说，就是将对象呈现为inline对象，但对象的内容作为block对象呈现。之后的内联对象会被排列在同一行内。比如给一个link（a元素）inline-block属性值，使其既具有block高度宽度特性又具有inline同行特性。</li>
</ul>
<p>2.</p>
<ul>
<li>static 默认值，元素处于正常的文档流之中，top,right,bottom,left,z-index（设置元素的堆叠顺序）属性无效</li>
<li>relative 元素相对原本正常位置的定位，不改变布局，这样会在此元素原本所在的位置留下空白，对display为表格型的元素无效</li>
<li>absolute 不为元素预留空间，元素相对于与它最近的非static定位的祖先元素来定位。元素可以设置外边距（margin），并且不会与其他边距合并（即形成一个BFC）</li>
<li>fixed 不为元素预留空间，相对屏幕视窗定位，屏幕滚动时位置不变</li>
<li>sticky （新属性，目前仅firefox实现）平时为relative，在特定条件下变为fixed，类似于实现浮动条<br>-inherit 从父元素继承position属性的值<h3 id="8、对BFC规范的理解"><a href="#8、对BFC规范的理解" class="headerlink" title="8、对BFC规范的理解"></a>8、对BFC规范的理解</h3>BFC，块级格式上下文，一个创建了新的BFC的盒子是独立布局的，盒子里面的子元素的样式不会影响到外面的元素。在同一个BFC中的两个毗邻的块级盒在垂直方向的margin会发生折叠。<h3 id="9、CSS-spirite"><a href="#9、CSS-spirite" class="headerlink" title="9、CSS spirite"></a>9、CSS spirite</h3>CSS spirite把网页中的背景图片整合到一张图片文件中，再利用CSS的background-image, background-rep<h3 id="10、text-overflow-这个属性貌似问的比较多"><a href="#10、text-overflow-这个属性貌似问的比较多" class="headerlink" title="10、text-overflow(这个属性貌似问的比较多)"></a>10、text-overflow(这个属性貌似问的比较多)</h3>text-overflow规定文本溢出包含元素时发生的事情。<br>包含以下属性：</li>
</ul>
<ol>
<li>clip:修剪文本</li>
<li>ellipsis：显示省略号来代表被修剪的文本</li>
<li>string：使用给定的字符串来代表被修剪的文本<br>注意ellipsis要与overflow：hidden，white-space:nowrap一起使用(white-space规定了文本不换行)</li>
</ol>
<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><h3 id="1、DOCTYPE"><a href="#1、DOCTYPE" class="headerlink" title="1、DOCTYPE"></a>1、DOCTYPE</h3><p>&lt;!DOCTYPE&gt;位于html文档的第一行，它并不是一个html标签。它的作用是告诉浏览器以哪种模式来解析文档。<br>HTML 5只有一种DOCTYPE声明，&lt;!DOCTYPE html&gt;<br>HTML 4.01有三种：strict、transitional、frameset。</p>
<h3 id="2、HTML5新特性"><a href="#2、HTML5新特性" class="headerlink" title="2、HTML5新特性"></a>2、HTML5新特性</h3><ul>
<li>语义化标签（header、nav、footer、aside、article、section）</li>
<li>拖放事件（drag类事件）</li>
<li>跨文档消息传递（postMessage）</li>
<li>媒体元素（audio、video标签）</li>
<li>地理位置定位（navigator、geolocation）API</li>
<li>历史状态管理（更新history对象，pushstate等）<h4 id="HTML5离线存储技术"><a href="#HTML5离线存储技术" class="headerlink" title="HTML5离线存储技术"></a>HTML5离线存储技术</h4>用户离线时，可以正常访问站点时，联网可以更新缓存，使用方法就是在html标签中加入manifest属性，如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html manifest=&quot;cache.manifest&quot;&gt;</div><div class="line">...</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>cache.manifest文件格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">CACHE MANIFEST</div><div class="line"></div><div class="line">CACHE:</div><div class="line"></div><div class="line">js/app.js</div><div class="line">css/style.css</div><div class="line"></div><div class="line">NETWORK:</div><div class="line"></div><div class="line">resource/logo.png</div><div class="line"></div><div class="line">FALLBACK:</div><div class="line">/ /offline.html</div></pre></td></tr></table></figure></p>
<p>离线缓存的manifest一般由三个部分组成：</p>
<ol>
<li>CACHE:表示需要离线存储的资源列表</li>
<li>NETWORK:表示在它下面列出来的资源只有在有线的情况下才能访问，他们不会被离线存储</li>
<li>FALLBACK:(实例里’/ /‘不是注释）表示如果访问第一个资源失败，那么就使用第二个资源来替换它，比如上面这个文件表示的就是如果访问根目录下任何一个资源失败了，那么就去访问offline.html。<h3 id="3、iframe的优缺点"><a href="#3、iframe的优缺点" class="headerlink" title="3、iframe的优缺点"></a>3、iframe的优缺点</h3><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4></li>
</ol>
<ul>
<li>重载页面时不需要重载整个页面，只需要重载页面中的一个框架页（减少了数据的传输，加快了网页下载速度</li>
<li>技术容易掌握，使用方便，可主要应用于不需搜索引擎来搜索的页面</li>
<li>方便制作导航栏<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4></li>
<li>最大的缺点四搜索引擎无法解读这种页面</li>
<li>框架结构让人迷惑</li>
<li>浏览器后退按钮失效（之呢个针对当前光标所在页面的前进和后退）<h3 id="4、如何实现浏览器多个标签页之间的通信"><a href="#4、如何实现浏览器多个标签页之间的通信" class="headerlink" title="4、如何实现浏览器多个标签页之间的通信"></a>4、如何实现浏览器多个标签页之间的通信</h3>调用localStorage、cookie等本地存储方式<h3 id="5、WebSocket如何兼容低浏览器"><a href="#5、WebSocket如何兼容低浏览器" class="headerlink" title="5、WebSocket如何兼容低浏览器"></a>5、WebSocket如何兼容低浏览器</h3><h4 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">//创建WebSocket实例</div><div class="line">var socket=new WebSocket(&quot;ws://licalhost:8080&quot;);</div><div class="line"></div><div class="line">//打开WebSocket</div><div class="line">socket.onopen=function(event)&#123;</div><div class="line">  //发送一个初始化消息</div><div class="line">  socket.send(&apos;I am a client and i am listening&apos;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//监听消息</div><div class="line">socket.onmessage=function(event)&#123;</div><div class="line">  console.log(&apos;Client received a message&apos;);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">//监听关闭</div><div class="line">socket.onclose=function(event)&#123;</div><div class="line">  console.log(&apos;WebSocket closed&apos;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//关闭socket</div><div class="line">//socket.close();</div></pre></td></tr></table></figure>
</li>
</ul>
<p>WebSocket是HTML5出的协议，是一个持久化的协议，相对于http这种非持久化的协议来说。WebSocket是基于http协议的，在握手阶段是一样的，不同的是http每个request接收一个response，这个response是被动的，不能主动发起。<br>在讲WebSocket之前，先说long poll和ajax轮询。<br>ajax轮询：让浏览器每隔几秒就发送一次请求，询问服务器是否有新消息。<br>long pull:跟ajax轮询差不多，不过采取的是阻塞模型（不收到消息就不发response给客户端，知道有消息才返回，返回完后再次建立连接，周而复始）。<br>这两种方式都是不断建立http连接，然后等待服务器端处理，体现了http协议的被动性。而且两种方式都非常消耗资源，ajax需要服务器有很快的处理速度和资源，long poll需要很高的并发。</p>
<h5 id="WebSocket的作用"><a href="#WebSocket的作用" class="headerlink" title="WebSocket的作用"></a>WebSocket的作用</h5><p>WebSocket解决了http协议的被动性，服务器可以主动推送消息给客服端，只需要经过一次请求，就可以源源不断的消息传送；另外http是无状态的，每次都要传输identity info（鉴别信息）来告诉服务器你是谁，而WebSocket只需要一次握手，整个通讯过程都是建立在一次连接/状态中，避免了http的非状态性，服务器端会一直知道你的信息知道关闭请求。</p>
<h4 id="如何在不支持WebSocket的客户端上使用"><a href="#如何在不支持WebSocket的客户端上使用" class="headerlink" title="如何在不支持WebSocket的客户端上使用"></a>如何在不支持WebSocket的客户端上使用</h4><p>实际上是不能，但是可以通过上面说的long poll和ajax轮询来实现类似的效果</p>
<h3 id="6、null和undefined的区别"><a href="#6、null和undefined的区别" class="headerlink" title="6、null和undefined的区别"></a>6、null和undefined的区别</h3><h4 id="null"><a href="#null" class="headerlink" title="null"></a>null</h4><p>null表示的是一个“无”的对象，转为数值时为0<br>典型用法：</p>
<ul>
<li>作为函数的参数，表示该函数的参数不是对象</li>
<li>作为原型链的终点<h4 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h4>undefined表示的是一个“无”的原始值，转为数值是NaN<br>典型用法：</li>
<li>变量被声明了，但是没有赋值时，就等于underfined</li>
<li>调用函数时，应该提供的参数没有提供，该参数等于undefined</li>
<li>对象没有赋值的属性，该属性的值为undefined</li>
<li>函数没有返回值时，默认返回undefined<h3 id="7、new操作符具体干了什么"><a href="#7、new操作符具体干了什么" class="headerlink" title="7、new操作符具体干了什么"></a>7、new操作符具体干了什么</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var Fun=function()&#123;</div><div class="line"> &#125;</div><div class="line">var func=new Func();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>new共经历了四个阶段：</p>
<ol>
<li>创建一个空对象<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var obj=new Object();</div></pre></td></tr></table></figure>
</li>
</ol>
<p>2、设置原型链<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">obj._proto_=Func.prototype;(继承构造函数的属性和方法)</div></pre></td></tr></table></figure></p>
<p>3、让Func中的this指向obj，并执行Func函数体<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var result=Func.call(obj);</div></pre></td></tr></table></figure></p>
<h3 id="8、跨域问题"><a href="#8、跨域问题" class="headerlink" title="8、跨域问题"></a>8、跨域问题</h3><h4 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h4><p>在讲跨域问题之前先说同源策略。一个url由协议、域名、端口和路径组成，如果两个url协议、域名、端口相同，则表示它们同源。浏览器的同源策略是指一个域上加载的脚本不允许访问另一个域的文档属性。</p>
<h4 id="跨域方法"><a href="#跨域方法" class="headerlink" title="跨域方法"></a>跨域方法</h4><h5 id="1、跨域资源共享（CORS"><a href="#1、跨域资源共享（CORS" class="headerlink" title="1、跨域资源共享（CORS)"></a>1、跨域资源共享（CORS)</h5><p>创建CORS请求对象<br>因为CORS是属于XMLHttpRequest2的一部分，所以主要要做的就是区分IE8/9和不支持XMLHttpRequest的浏览器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">function createCoresRequest(method,url)&#123;</div><div class="line">   var xhr=new XMLHttpRequest();</div><div class="line">   if(&apos;withCredentials&apos; in xhr)&#123;</div><div class="line">      //支持CORS</div><div class="line">      //检查XMLHttpRequest对象是否有&quot;withCredentials&quot;属性，withCredentials仅存在xmlHttpRequest对象里</div><div class="line">      xhr.open(method,url,true);</div><div class="line">    &#125;</div><div class="line">   else if(window.XDomainRequest)&#123;</div><div class="line">     //XDomainRequest仅存在IE中，是IE用于支持CORS请求的方式</div><div class="line">     xhr=new C=XDomainRequest();</div><div class="line">     xhr.open(method,true);</div><div class="line">   &#125;</div><div class="line">   else&#123;</div><div class="line">      //不支持CORS</div><div class="line">      xhr=null;</div><div class="line">   &#125;</div><div class="line">   return xhr;</div><div class="line">  &#125;</div><div class="line">  var xhr=createCORSRequest(&quot;GET&quot;,url);</div><div class="line">  if(!xhr)&#123;</div><div class="line">     throw new Error(&apos;CORS not supported&apos;);</div><div class="line">   &#125;</div><div class="line">  xhr.send();//发送请求</div></pre></td></tr></table></figure></p>
<p>CORS是W3C提出的跨域请求方案，需要服务器端的支持。服务器端对CORS的支持主要通过设置HTTP头Access-Control-Allow-Origin实现，如果浏览器检测到相应的设置，就能允许AJAX跨域请求。</p>
<h5 id="2、通过jsonp跨域"><a href="#2、通过jsonp跨域" class="headerlink" title="2、通过jsonp跨域"></a>2、通过jsonp跨域</h5><p>JSONP也叫填充式json，是应用json的新方法，只不过是包含在函数中调用json，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">callback(&#123;&quot;name&quot;,&quot;jack&quot;&#125;)</div></pre></td></tr></table></figure></p>
<p>JSONP由两部分组成：回调函数和数据。回调函数是当响应到来时在页面中调用的函数，数据是传入回调函数的json数据。<br>在js中直接通过xmlHttpRequest请求不同域上的数据时，是不行的，但是，在页面上引入不同域的js脚本文件却是可以的，jsonp正是利用这个特性来实现的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;test/javascript&quot;&gt;</div><div class="line">   function dosomething(jsondata)&#123;</div><div class="line">     //处理json数据</div><div class="line">  &#125;</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;script src=&quot;http://example.data/data.php?callback=dosomething&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p>js文件载入成功后会执行url中指定的函数，并把需要的json数据作为参数传入该函数。<br>如果页面使用的是jquery，那么通过它封装的方法就能很方便的来进行JSONP操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">   $.getJSON(&quot;http://example.data/data.php?callback=?,function(jsondata)&quot;)&#123;</div><div class="line">     //处理获得json数据</div><div class="line">  &#125;）</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p>jQuery会自动生成一个全局函数来替换callback=？中的？，之后获取的数据又会自动销毁，实际上就是起一个临时代理函数的作用。$.getJSON方法会自动判断是否跨域，如果不跨域，就用普通的ajax方法，跨域的话，就会异步加载js文件的形式来调用jsonp的回调函数。</p>
<h6 id="JSOPN的优缺点"><a href="#JSOPN的优缺点" class="headerlink" title="JSOPN的优缺点"></a>JSOPN的优缺点</h6><ul>
<li>优点：不像XMLHttpRequest对象实现得Ajax请求那样受到同源策略的限制，它的兼容性更好，不需要XMLHttpRequest或ActiveX的支持，并且在请求完毕后可以通过调用callback方式回传结果。</li>
<li>缺点：它支持GET请求而不支持POST等其他类型的HTTP请求，它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行javascript调用的问题。<h6 id="CORS和JSONP的对比"><a href="#CORS和JSONP的对比" class="headerlink" title="CORS和JSONP的对比"></a>CORS和JSONP的对比</h6></li>
</ul>
<ol>
<li>JSONP只支持GET类型的http请求，CORS支持所有类型的http请求</li>
<li>CORS，开发者可以使用普通的XMLHttpRequest发起请求和获取数据，有更好的错误处理</li>
<li>JSONP主要被老的浏览器支持，它们往往不支持CORS，对大多数现代浏览器都已经支持CORS了<h5 id="3、通过修改document-domain来跨域（iframe）"><a href="#3、通过修改document-domain来跨域（iframe）" class="headerlink" title="3、通过修改document.domain来跨域（iframe）"></a>3、通过修改document.domain来跨域（iframe）</h5>浏览器的同源策略的两个限制：一、不能通过ajax方法去请求不同源的文档；二、浏览器中不同框架是不能进行js交互操作的。<br>比如：有一个页面，它的地址是”<a href="http://www.example.com/a.html&quot;，这个页面里有个iframe，它的iframe的src是&quot;http://example.com/a.html&quot;，很显然这个页面与它的iframe框架是不同域的，所以无法通过js代码来获取iframe的东西。" target="_blank" rel="external">http://www.example.com/a.html&quot;，这个页面里有个iframe，它的iframe的src是&quot;http://example.com/a.html&quot;，很显然这个页面与它的iframe框架是不同域的，所以无法通过js代码来获取iframe的东西。</a><br>此时document.domain就排上用场了，但是document.domain的设置有限制，只能将其设置成自身或者父域，且主域必须相同。</li>
<li><p>“<a href="http://www.example.com/a.html&quot;页面设置document.domain" target="_blank" rel="external">http://www.example.com/a.html&quot;页面设置document.domain</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;iframe id=&quot;iframe&quot; src=&quot;http://example.com/a.html&quot; onload=&quot;test()&quot;&gt;&lt;/iframe&gt;</div><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">   document.domain=&quot;example.com&quot;;//设置成主域</div><div class="line">   funtion test()&#123;</div><div class="line">      alert(document.getElementById(&quot;#ifrme&quot;).contentWindow);//可取得子窗口的window对象</div><div class="line">   &#125;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>“<a href="http://example.com/a.html&quot;设置document.domain" target="_blank" rel="external">http://example.com/a.html&quot;设置document.domain</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">   document.domain=&quot;example.com&quot;;//设置成主域</div><div class="line"></div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>注：document.domain只适用于不同子域的框架中。</p>
<h5 id="4、window-name"><a href="#4、window-name" class="headerlink" title="4、window.name"></a>4、window.name</h5><p>在一个窗口的生命周期内，不同url共享同一个window.name，每个页面对window.name都有读写权限，且window.name持久存在一个窗口在载入过的所有页面中。</p>
<h5 id="5、HTML5的window-postMessage方法"><a href="#5、HTML5的window-postMessage方法" class="headerlink" title="5、HTML5的window.postMessage方法"></a>5、HTML5的window.postMessage方法</h5><p>HTML5的新特性，不能实现与服务器交换数据，只能在不同的iframe中使用。html5提供了两个重要的接口：postMessage(send)和onmessage。一个页面通过postMessage发送消息，另一个页面监听消息。<br>例如：父页面向子页面发送消息，父页面代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;</div><div class="line">    &lt;title&gt;崔涣 iframe postmessage 父页面&lt;/title&gt;</div><div class="line">    &lt;script type=&quot;text/JavaScript&quot;&gt;</div><div class="line">        function sendIt() &#123;</div><div class="line">            // 通过 postMessage 向子窗口发送数据</div><div class="line">            document.getElementById(&quot;otherPage&quot;).contentWindow</div><div class="line">                    .postMessage(</div><div class="line">                    document.getElementById(&quot;message&quot;).value,</div><div class="line">                    &quot;http://cuihuan.net:8003&quot;</div><div class="line">            );</div><div class="line">        &#125;</div><div class="line">    &lt;/script&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;!-- 通过 iframe 嵌入子页面 --&gt;</div><div class="line">&lt;iframe src=&quot;http://cuihuan.net:8003/test.html&quot; id=&quot;otherPage&quot;&gt;&lt;/iframe&gt;</div><div class="line">&lt;br/&gt;</div><div class="line">&lt;br/&gt;</div><div class="line">&lt;input type=&quot;text&quot; id=&quot;message&quot;/&gt;</div><div class="line">&lt;input type=&quot;button&quot; value=&quot;Send to child.com&quot; onclick=&quot;sendIt()&quot;/&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<p>window.postMessage(message,targetOrigin).postMessage必须包含两个参数，第一个参数是发送的信息，第二个参数是目标域名。<br>子页面代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;html&gt; </div><div class="line"> &lt;head&gt; </div><div class="line"> &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; </div><div class="line"> &lt;title&gt;崔涣测试子页面信息&lt;/title&gt; </div><div class="line"> &lt;script type=&quot;text/JavaScript&quot;&gt; </div><div class="line">     //event 参数中有 data 属性，就是父窗口发送过来的数据</div><div class="line">     window.addEventListener(&quot;message&quot;, function( event ) &#123; </div><div class="line">         // 把父窗口发送过来的数据显示在子窗口中</div><div class="line">       document.getElementById(&quot;content&quot;).innerHTML+=event.data+&quot;&lt;br/&gt;&quot;; </div><div class="line">     &#125;, false ); </div><div class="line"></div><div class="line"> &lt;/script&gt; </div><div class="line"> &lt;/head&gt; </div><div class="line"> &lt;body&gt; </div><div class="line">     this is the 8003 port for cuixiaozhuai </div><div class="line">     &lt;div id=&quot;content&quot;&gt;&lt;/div&gt; </div><div class="line"> &lt;/body&gt; </div><div class="line"> &lt;/html&gt;</div></pre></td></tr></table></figure></p>
<p>处于安全方面的考虑，可以对域或数据规则进行安全校验：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">window.addEventListener(&apos;message&apos;, function (event) &#123;</div><div class="line">        </div><div class="line">        //校验函数是否合法</div><div class="line">        var checkMessage = function () &#123;</div><div class="line">            // 只获取需要的域，并非所有都可以跨域</div><div class="line">            if (event.origin != &quot;need domain&quot;) &#123;</div><div class="line">                return false;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            </div><div class="line">            var message = event.data;</div><div class="line">            // 传输数据类型校验</div><div class="line">            if (typeof(message) !== &apos;object&apos;) &#123;</div><div class="line">                return false;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // message 的rule中包含xxx则为xxx需要字段。</div><div class="line">            return message.rule === &quot;xxx&quot;;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        if (checkMessage()) &#123;</div><div class="line">            // 通过校验进行相关操作</div><div class="line">            addDetailFunc(event);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div></pre></td></tr></table></figure></p>
<h3 id="9、document-write和innerHTML的区别"><a href="#9、document-write和innerHTML的区别" class="headerlink" title="9、document.write和innerHTML的区别"></a>9、document.write和innerHTML的区别</h3><p>document.write是直接写入页面的文档流，如果写之前没有调用document.open，浏览器会自动调用open，每次写完之后重新调用该函数，会导致整个页面的重绘。<br>innerHTML能精确到某个具体的元素来更改，只对页面的部分重绘。</p>
<h3 id="10、内存泄露"><a href="#10、内存泄露" class="headerlink" title="10、内存泄露"></a>10、内存泄露</h3><p>内存泄漏：是指任何对象不再拥有或需要它之后仍然存在。<br>javascript有自动垃圾回收机制，一旦数据不再使用，可以将其设为null来释放引用。<br>造成内存泄漏的集中操作：</p>
<ol>
<li>循环引用<br>一个DOM对象被一个javascript对象引用，与此同时又引用同一个或其他的javascript对象，这个DOM对象可能会引发内存泄露。这个DOM对象的引用将不会在脚本停止的时候被垃圾回收器回收。要想破坏引用，引用DOM元素的随想或DOM对象的引用需要被赋值为null。</li>
<li><p>闭包<br>在闭包中引入闭包外部的变量时，当闭包结束时此对象无法被垃圾回收。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var a=function()&#123;</div><div class="line">   var largeStr=new Array(1000000).join(&quot;x&quot;);</div><div class="line">    return function()&#123;</div><div class="line">      return largeStr;</div><div class="line">     &#125;</div><div class="line">&#125;();</div></pre></td></tr></table></figure>
</li>
<li><p>DOM泄露<br>父节点被删除时，子节点引用没有被移除则无法回收。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var select=document.querySelector;</div><div class="line">var treeRef=select(&quot;#tree&quot;);</div><div class="line"></div><div class="line">var leaf=select(&quot;#leaf&quot;);//#leaf是#tree的子节点</div><div class="line">var body=select(&quot;body&quot;);</div><div class="line"></div><div class="line">body.removeChild(treeleaf);</div><div class="line">//#tree不能被回收，因为treeLeaf还在</div><div class="line">//解决方案</div><div class="line">treeRef=null;</div><div class="line"></div><div class="line">//tree不能被回收，一位内叶子leaf还在</div><div class="line">leaf=null;</div><div class="line"></div><div class="line">//现在#tree被释放了</div></pre></td></tr></table></figure>
</li>
</ol>
<p>4、Timer定时器泄露<br>定时器也是常见的产生泄露的地方<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">for(var i=0;i&lt;90000;i++)&#123;</div><div class="line">   var b=&#123;</div><div class="line">      callAgain:function()&#123;</div><div class="line">        var ref=this;</div><div class="line">        var val=setTimeout(function()&#123;</div><div class="line">            ref.callAgain();</div><div class="line">         &#125;,90000);</div><div class="line">     &#125;</div><div class="line">    &#125;</div><div class="line">b.callAgain();</div><div class="line">//虽然很想收回但是timer还在</div><div class="line">b=null;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="11、作用域链"><a href="#11、作用域链" class="headerlink" title="11、作用域链"></a>11、作用域链</h3><p>作用域链、闭包、原型链是javascript中比较重要的知识点。</p>
<h4 id="javascript中的作用域"><a href="#javascript中的作用域" class="headerlink" title="javascript中的作用域"></a>javascript中的作用域</h4><p>每一种语言都有作用域的概念，所谓作用域就是变量和函数的可用范围，确定了变量和函数的可见性和生命周期。<br>javascript中有两种作用域，全局作用域和局部作用域。</p>
<h5 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h5><p>以下情况一般拥有全局作用域</p>
<ul>
<li>全局声明的函数和变量</li>
<li>没有定义直接赋值的变量</li>
<li>所以window属性<h5 id="局部作用域"><a href="#局部作用域" class="headerlink" title="局部作用域"></a>局部作用域</h5>在函数内部声明的函数和变量只能在函数内部访问到，即拥有局部作用域。<h4 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h4>javascript中，一切都是对象，包括函数。而函数有一个内部属性[[scope]]，里面包含了函数的可访问的作用域对象的集合，这个集合被称为作用域链。<h5 id="作用域链的创建"><a href="#作用域链的创建" class="headerlink" title="作用域链的创建"></a>作用域链的创建</h5>作用域链在函数执行时创建。<strong>作用域的前端，始终是当前环境的变量对象</strong>。如果这个环境是函数，则将其活动对象作为变量对象，里面包含了该函数的所有局部变量、参数及this。<br>把作用域链当成一个对象数组，先把该函数的变量对象push进数组，然后把函数的外部环境的作用域push进数组，下一个就是外部环境的外部环境的变量对象，一直往外直到全局环境，<strong>即作用域链的最后一个对象肯定是全局环境的作用域</strong>。<h5 id="作用域链的作用"><a href="#作用域链的作用" class="headerlink" title="作用域链的作用"></a>作用域链的作用</h5>作用域链的目的是<strong>保证当前环境对可访问的变量和函数的有序访问。</strong><br>具体实现是：函数内部标识符解析时会沿着作用域链一级一级地搜索。搜索的过程始终从作用域链前端开始，直到最后一个对象即全局变量对象为止，如果找不到的话，就是undefined。<br>这样可以保证内部变量的优先级始终大于外部变量。<h5 id="变量提升的问题"><a href="#变量提升的问题" class="headerlink" title="变量提升的问题"></a>变量提升的问题</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var name=&quot;123&quot;;</div><div class="line">function foo()&#123;</div><div class="line">   console.log(name); //undefined</div><div class="line">   var name=&quot;456&quot;;</div><div class="line">   console.log(name);  //456</div><div class="line">&#125;</div><div class="line">foo();</div></pre></td></tr></table></figure>
</li>
</ul>
<p>以上例子，按常规连接，应该先输出全局变量“123”，再输出局部变量“456”，然而第一个却输出了undefined，为什么呢？<br>因为函数在执行时首先胡创建作用域链，这是在整个函数执行之前就完成的，所以第一次输出时，该函数的变量对象已经包含了name这个变量，从而导致解析时在作用域链第一个对象就停止，，而不会访问到全局变量，同时那个时候局部变量没有赋值，所以会输出undefined。这种现象叫做变量提升。<br>注：ES6中通过let标识符可以防止这种现象的出现</p>
<h5 id="作用域链的延长"><a href="#作用域链的延长" class="headerlink" title="作用域链的延长"></a>作用域链的延长</h5><p>部分语句可以在作用域链的前端临时增加一个变量对象，该变量对象会在代码执行后移除。主要由两种情况</p>
<ol>
<li>with语句</li>
<li>try-catch语句<h6 id="with语句"><a href="#with语句" class="headerlink" title="with语句"></a>with语句</h6>平时优化需要可以把所需对象存储在局部变量中，不推荐使用with语句，可能造成bug和性能损失。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function foo()&#123;</div><div class="line">  var he=&quot;?name=1&quot;;</div><div class="line">  with(location)&#123;</div><div class="line">    var url=href+he;</div><div class="line">   &#125;</div><div class="line">  return url;</div><div class="line">&#125;</div><div class="line">foo();</div></pre></td></tr></table></figure>
</li>
</ol>
<p>这里with语句把location对象添加到作用域链前端，因此在访问href时，其实是访问了location.href。在with语句执行完毕后，作用域链就返回之前的状态。</p>
<h6 id="catch块"><a href="#catch块" class="headerlink" title="catch块"></a>catch块</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">try&#123;</div><div class="line">  something();</div><div class="line">&#125;catch(e)&#123;</div><div class="line">  console.log(e);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当try代码块中的语句发生错误时，执行块跳转到catch语句块，并且把一个异常对象添加到作用域的头部。在catch语句执行完毕后，作用域链就返回之前的状态。<br>注：可以把错误处理委托给一个函数。这样的话就只执行一条语句，并且没有访问局部变量，对性能影响就比较小。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">try&#123;</div><div class="line">  something();</div><div class="line">&#125;catch(e)&#123;</div><div class="line">  handleError(e);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="12、闭包"><a href="#12、闭包" class="headerlink" title="12、闭包"></a>12、闭包</h3><h4 id="闭包的特性"><a href="#闭包的特性" class="headerlink" title="闭包的特性"></a>闭包的特性</h4><ol>
<li>函数嵌套函数</li>
<li>内部的函数可以引用函数外部的参数和变量</li>
<li>参数和变量不能被垃圾回收机制回收<h4 id="闭包的定义及其优缺点"><a href="#闭包的定义及其优缺点" class="headerlink" title="闭包的定义及其优缺点"></a>闭包的定义及其优缺点</h4>闭包：是指有权访问另一个函数作用域中的变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量。<br>闭包的缺点：常驻内存，会增加大量的内存使用，使用不当会造成内存泄漏。<br>闭包的应用：一是前面提到的读取函数内部的变量，二是让这些变量的值始终保持在内存中。<br>看个例子：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function f1()&#123;</div><div class="line">   var n=999;</div><div class="line">   add=function()&#123;</div><div class="line">      n+=1;</div><div class="line">   &#125;</div><div class="line">   function f2()&#123;</div><div class="line">      alert(n);</div><div class="line">   &#125;</div><div class="line">   return f2;</div><div class="line">&#125;</div><div class="line">var result=f1();</div><div class="line">result();//999</div><div class="line">add();</div><div class="line">result();</div></pre></td></tr></table></figure>
</li>
</ol>
<p>result实际上就是闭包f2函数，它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。<br>为什么会这样呢？因为f1是f2的复函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制回收。<br>另外要注意add，首先add前面没有使用var关键字，因此add是一个全局变量，而不是局部变量。其次add的值是一个匿名函数，而这个匿名函数本身也是一个闭包，所以add相当于一个setter，可以在函数外部对函数内部的局部变量进行操作。</p>
<h4 id="闭包使用注意点"><a href="#闭包使用注意点" class="headerlink" title="闭包使用注意点"></a>闭包使用注意点</h4><ol>
<li>由于闭包会使得函数中的变量都保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页性能问题，IE中可能导致内存泄漏。解决办法是，在退出函数之前，将不适用的局部变量全部删除。</li>
<li>闭包会在父函数外部，改变父函数内部变量的值。如果把父函数当作对象使用，把闭包当作它的公用方法，把内部变量当作它的私有属性，这是一定要小心，不要随便改变父函数内部变量的值。<h3 id="13、javascript中的this"><a href="#13、javascript中的this" class="headerlink" title="13、javascript中的this"></a>13、javascript中的this</h3>一般而言，javascript中<strong>this指向函数执行时的当前对象</strong>。换句话说，这个关键字<strong>与函数的执行环境有关，与声明环境无关</strong>。所以this的指向要看如何去调用这个函数而不是声明。<h4 id="不同的调用方式"><a href="#不同的调用方式" class="headerlink" title="不同的调用方式"></a>不同的调用方式</h4><h5 id="1、作为对象的方法调用"><a href="#1、作为对象的方法调用" class="headerlink" title="1、作为对象的方法调用"></a>1、作为对象的方法调用</h5>把函数赋值给对象的一个属性，然后通过该对象调用该方法，此时函数的执行环境就是这个对象，所以this指向该对象。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var name=&quot;haha&quot;;</div><div class="line">var obj=&#123;</div><div class="line">  name:&quot;hehe&quot;,</div><div class="line">  show:function()&#123;</div><div class="line">     console.log(this.name);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">obj.show(); //hehe</div></pre></td></tr></table></figure>
</li>
</ol>
<p>换种更清晰的方式，我们把声明和调用放在两个对象里面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var obj=&#123;</div><div class="line">   name:&quot;hehe&quot;,</div><div class="line">   show:function()&#123;</div><div class="line">      console.log(this.name)</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line">var t_obj=&#123;</div><div class="line">   name:&quot;lala&quot;,</div><div class="line">   show:obj_show</div><div class="line">&#125;</div><div class="line">t_obj.show();  //lala</div></pre></td></tr></table></figure></p>
<p>可以看到show虽然在obj中声明过，但是通过t_obj调用了这个方法，所以此时this指向t_obj。</p>
<h5 id="2、作为函数调用"><a href="#2、作为函数调用" class="headerlink" title="2、作为函数调用"></a>2、作为函数调用</h5><p>我们将上面的代码改一下，将obj.show赋值给全局变量show再调用，此时this绑定到全局对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var name=&quot;lala&quot;;</div><div class="line">var obj=&#123;</div><div class="line">   name:&quot;hehe&quot;,</div><div class="line">   show:function()&#123;</div><div class="line">      console.log(this.name);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line">var show=obj.show;</div><div class="line">show(); //lala</div></pre></td></tr></table></figure></p>
<h5 id="3、独立函数调用"><a href="#3、独立函数调用" class="headerlink" title="3、独立函数调用"></a>3、独立函数调用</h5><p>在函数内部调用一个函数，比如在一个对象的方法里面调用一个函数时，this会指向全局对象(讲道理的话应该指向对象），实际上是不带任何修饰的函数引用进行调用时，默认this指向全局变量。这是javascript设计比较坑的地方，平时经常使用命名一个新变量ctx(context，即上下文环境)替代this。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var name=&quot;lala&quot;;</div><div class="line">var obj=&#123;</div><div class="line">   name:&quot;hehe&quot;,</div><div class="line">   show:function()&#123;</div><div class="line">      var test=function()&#123;</div><div class="line">          console.log(this.name);</div><div class="line">       &#125;</div><div class="line">      test();</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line">obj.show();  //lala</div></pre></td></tr></table></figure></p>
<p>修正版<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var name=&quot;lala&quot;;</div><div class="line">var obj=&#123;</div><div class="line">   name:&quot;hehe&quot;,</div><div class="line">   show:function()&#123;</div><div class="line">      var txt=this;</div><div class="line">      console.log(this);//obj</div><div class="line">      var test=function()&#123;</div><div class="line">          console.log(this.name);</div><div class="line">       &#125;</div><div class="line">      test();</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line">obj.show();  // hehe</div></pre></td></tr></table></figure></p>
<p>再看一个例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var name=&quot;lala&quot;;</div><div class="line">function b()&#123;</div><div class="line">  var name=&quot;hehe&quot;</div><div class="line">  function a()&#123;</div><div class="line">     console.log(this.name);</div><div class="line">   &#125;</div><div class="line">  a();</div><div class="line">&#125;</div><div class="line">b(); //lala</div></pre></td></tr></table></figure></p>
<p>修改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var name=&quot;lala&quot;;</div><div class="line">function b()&#123;</div><div class="line">  var cxt=this;</div><div class="line">  console.log(this);//window</div><div class="line">  var name=&quot;hehe&quot;</div><div class="line">  function a()&#123;</div><div class="line">     console.log(ctx.name);</div><div class="line">   &#125;</div><div class="line">  a();</div><div class="line">&#125;</div><div class="line">b(); //lala</div></pre></td></tr></table></figure></p>
<p>可以看到对比上一个例子，obj.show中的this指向obj，而第二个例子由于b是独立函数，b中的this指向全局对象，有一个误区认为this指向执行的函数，实际上不是的。</p>
<h5 id="4、作为构造函数使用"><a href="#4、作为构造函数使用" class="headerlink" title="4、作为构造函数使用"></a>4、作为构造函数使用</h5><p>我们常使用new构造函数名()来创建一个对象，此时函数中的this指向新创建的对象。如果不使用new，则和普通函数一样绑定到全局对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function Foo()&#123;</div><div class="line">   console.log(this);</div><div class="line">&#125;</div><div class="line">var test=new Foo(); //test</div><div class="line">Foo(); //window</div></pre></td></tr></table></figure></p>
<h5 id="5、在setTimeout、setInterval和匿名函数中"><a href="#5、在setTimeout、setInterval和匿名函数中" class="headerlink" title="5、在setTimeout、setInterval和匿名函数中"></a>5、在setTimeout、setInterval和匿名函数中</h5><p>在setTimeout,setInterval和匿名执行时的对象为全局对象，所以this也指向全局对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var name=&quot;lala&quot;;</div><div class="line">var obj=&#123;</div><div class="line">  name:&quot;hehe&quot;,</div><div class="line">  show:function()&#123;</div><div class="line">     setTimeout(function()&#123;</div><div class="line">        console.log(this.name);</div><div class="line">      &#125;,500);</div><div class="line">   &#125;</div><div class="line"> &#125;</div><div class="line">obj.show();</div></pre></td></tr></table></figure></p>
<h5 id="6、函数调用call和apply方法时"><a href="#6、函数调用call和apply方法时" class="headerlink" title="6、函数调用call和apply方法时"></a>6、函数调用call和apply方法时</h5><p>两者的本质就是改变函数当前的上下文环境即this，两者的区别是call接收一个个参数，而apply接受一个参数数组。<br>注：使用call和apply函数的时候要主要，如果传递的this值不是一个对象，javascript将会尝试使用内部ToObject操作将其转换为对象。因此，如果传递的值，如果传递的值是一个原始值比如7或者”foo”，那么就会使用相关构造函数将它转换为对象，所以原始值7通过new Number(7)被转换为对象，而字符串”foo”使用new String(“foo”)转化为对象。</p>
<h5 id="7、函数调用bind方法时"><a href="#7、函数调用bind方法时" class="headerlink" title="7、函数调用bind方法时"></a>7、函数调用bind方法时</h5><p>函数调用bind方法时会创建一个有相同函数体和作用域的函数，新函数的this指向bind的第一个参数。该方法不会调用函数，而是返回新函数。</p>
<h3 id="14、prototype和原型链"><a href="#14、prototype和原型链" class="headerlink" title="14、prototype和原型链"></a>14、prototype和原型链</h3><p>每个函数都有一个prototype属性，这个属性是指向一个对象的引用，这个对象称为原型对象，原型对象包含函数实例共享的方法和属性，也就是说将函数用作构造函数调用的时候，新创建的对象会从原型对象上继承属性和方法。不像传统的面向对象语言，<strong>javascript的继承机制基于原型</strong>，而不是class类。</p>
<h4 id="1、javascript的设计意图"><a href="#1、javascript的设计意图" class="headerlink" title="1、javascript的设计意图"></a>1、javascript的设计意图</h4><ol>
<li><p>私有变量、函数<br>javascript的作用域链，在函数内定义的变量和函数如果不对外提供接口，外部将无法访问到，也就是变为私有变量和私有函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function Obj()&#123; </div><div class="line">   var a=0;  //私有变量</div><div class="line">   var fn=function()&#123;  //私有函数</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">var o=new Obj();</div><div class="line">console.log(o.a)  //undefined</div><div class="line">console.log(o.fn) //undefined</div></pre></td></tr></table></figure>
</li>
<li><p>静态变量、函数<br>当定义一个函数后，通过“.”为其添加属性和函数，通过对象本身仍然可以访问得到，但是其实例访问不到，这样的变量和函数分别被称为静态变量和静态函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function Obj()&#123;&#125;</div><div class="line">   Obj.a=0;  //静态变量</div><div class="line">   Obj.fn=function()&#123;  //静态函数</div><div class="line">    &#125;</div><div class="line"></div><div class="line">console.log(Obj.a) //0</div><div class="line">console.log(Obj.fn) //function()&#123;  //静态函数 &#125;</div><div class="line">var o=new Obj();</div><div class="line">console.log(o.a)  //undefined</div><div class="line">console.log(o.fn) //undefined</div></pre></td></tr></table></figure>
</li>
<li><p>实例变量、函数<br>在面向对象编程中除了一些库函数我们还希望在对象定义的时候同时定义一些属性和方法，实例化后可以访问，javascript也可以做到这样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function Obj()&#123;</div><div class="line">   this.a=[];  //实例变量</div><div class="line">   this.fn=function()&#123;  //实例函数</div><div class="line">   &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">console.log(typeof Obj.a)  //undefined</div><div class="line">console.log(typeof Obj.fn)  //undefined</div><div class="line">var o=new Obj();</div><div class="line">console.log(typeof o.a)  //object</div><div class="line">console.log(typeof o.fn)  //function</div></pre></td></tr></table></figure>
</li>
</ol>
<p>这样可以达到目的，然而<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function Obj()&#123;</div><div class="line">   this.a=[];//实例变量</div><div class="line">   this.fn=function()&#123; //实例方法</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">var o1=new Obj();</div><div class="line">o1.a.push(1);</div><div class="line">o1.fn=&#123;&#125;; </div><div class="line">console.log(o1.a);  //[1]</div><div class="line">console.log(typeof o1.fn); //object</div><div class="line">var o2=new Obj();</div><div class="line">console.log(o2.a);  //[]</div><div class="line">console.log(typeof o2.fn) //function</div></pre></td></tr></table></figure></p>
<p>虽然可以实例访问了，但是在o1中修改了a和fn，在o2中没有改变，由于数组和函数都是对象，是引用类型，这说明o1和o2中的属性和方法虽然同名但不是一个引用，而是对Obj对象定义的属性和方法的一个复制。<br>这对属性来说没什么问题，但是对方法来说，因为方法都是在做完全一样的功能，但是却有两份复制，如果一个函数对象有上千个实例方法，每个实例都要保持一份上千个方法的复制，这显然不科学，因此prototype应运而生。<br><strong>原型对象的主要目的是让所有对象实例共享它所包含的属性和方法。</strong></p>
<h4 id="2、prototype原型"><a href="#2、prototype原型" class="headerlink" title="2、prototype原型"></a>2、prototype原型</h4><p>在javascript中，所有都是对象。但对象是有区别的，分为普通对象和函数对象。<strong>凡是通过new Funtion()的方式创建的对象都是函数对象，其他都是普通对象</strong>。<br>每个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。<strong>prototype就是调用构造函数而创建的那个对象实例的原型对象。</strong>普通对象没有prototype，但是有<em>proto</em>属性。<br>原型对象其实就是普通对象（Funtion.prototype除外，它是函数对象，但它很特殊，它没有prototype属性（前面说函数对象都有prototype属性））。举个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function f1()&#123;&#125;;</div><div class="line">console.log(f1.prototype) //f1&#123;&#125;</div><div class="line">console.log(typeof f1.prototype) //object</div><div class="line">console.log(typeof Function.prototype) // function，这个特殊</div><div class="line">console.log(typeof Object.prototype) // object</div><div class="line">console.log(typeof Function.prototype.prototype) //undefined</div></pre></td></tr></table></figure></p>
<p>从console.log(f1.prototype)//f1{}看出，f1.prototype就是f1的实例对象。就是f1创建的时候，创建了一个实例对象并赋值给它的prototype，过程如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var temp=new f1();</div><div class="line">f1.prototype=temp;</div></pre></td></tr></table></figure></p>
<p>所以Function.prototype为什么时函数对象就迎刃而解，上文提到凡是new Function产生的对象都是函数对象，所以temp1是函数对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var temp1=new Function();</div><div class="line">Function.prototype=temp1;</div></pre></td></tr></table></figure></p>
<p>那原型对象是用来做什么呢？主要是用来继承，举个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var person=function(name)&#123;</div><div class="line">  this.name=name;</div><div class="line">&#125;</div><div class="line">person.prototype.getName=function()&#123;</div><div class="line">  return this.name;//this指向源性对象</div><div class="line">&#125;</div><div class="line">var xpg=new Person(&quot;alice&quot;)</div><div class="line">xpg.getName() //alice</div></pre></td></tr></table></figure></p>
<p>从这里看出，person.prototype设置了一个函数对象的属性，那由person实例出来的对象就继承了这个属性。具体继承机制看原型链。<br>无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性（同时它也是一个对象），默认情况下prototype属性会默认获得一个constructor（构造函数）属性，这个属性是一个指向prototype属性所在函数的指针。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">function Person()&#123;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://i.imgur.com/V16NjcO.png" alt=""><br>可以看到Person对象会自动获得prototype属性，而prototype也是一个对象，会自动获得constructor属性，该属性正是指向Person对象。<br>当调用构造函数创建一个实例的时候，实例内部将包含一个内部指针<strong>（<em>proto</em>）指向构造函数的prototype，这个连接存在于实例和构造函数的prototype之间，而不是实例与构造函数之间。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function Person(name)&#123;</div><div class="line">   this.name=name;</div><div class="line">&#125;</div><div class="line">Person.prototype.printName=function()&#123;</div><div class="line">  alert(this.name)</div><div class="line">&#125;</div><div class="line">var person1=new Person(&quot;Byron&quot;)</div><div class="line">var person2=new Person(&quot;Frank&quot;)</div></pre></td></tr></table></figure></p>
<p><img src="http://i.imgur.com/Ilyjg8u.png" alt=""></p>
<p>Person的实例person1中包含了name属性，同时自动生成一个<strong>proto</strong>属性，该属性指向Person的prototype，可以访问到prototype内定义的printName方法：<br><img src="http://i.imgur.com/XuwCD60.png" alt=""></p>
<h4 id="3、原型链"><a href="#3、原型链" class="headerlink" title="3、原型链"></a>3、原型链</h4><p>由于<strong>proto</strong>是任何对象都有的属性，而js里万物皆对象，所以会形成一条<strong>proto</strong>连起来的链。<br>代码读取某个对象的属性的时候，都会执行一遍搜索，目标是具有给定名字的属性，搜索首先从对象实例开始，如果实例中找到该属性则返回，如果没有则查找prototype，如果还没有找到则继续递归prototype的prototype对象，直到找到为止，如果递归到object仍然没有怎返回错误。同理如果在实例中定义prototype同名的属性或函数，则会覆盖prototype的属性或函数。这就是javascript的原型链。<br><img src="http://i.imgur.com/UwVMlkn.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var A = function()&#123;&#125;;</div><div class="line">var a = new A();</div><div class="line">console.log(a.__proto__); //A &#123;&#125;（即构造器function A 的原型对象）</div><div class="line">console.log(a.__proto__.__proto__); //Object &#123;&#125;（即构造器function Object 的原型对象）</div><div class="line">console.log(a.__proto__.__proto__.__proto__); //null</div></pre></td></tr></table></figure></p>
<h4 id="4、hasOwnProperty与in操作符"><a href="#4、hasOwnProperty与in操作符" class="headerlink" title="4、hasOwnProperty与in操作符"></a>4、hasOwnProperty与in操作符</h4><p>in操作符是只要能访问到该属性就返回true，hasOwnProperty只有属性存在于实例中时才返回true。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Object.prototype.bar=1</div><div class="line">var foo=&#123;moo:2&#125;</div><div class="line">for(var i in foo)&#123;</div><div class="line">if(foo.hasOwnProperty(i))</div><div class="line">  console.log(i) //输出两个属性： moo和bar</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们没有办法改变for in语句的行为，所以想过滤结果就只能使用hasOwnProperty方法，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for(var i in foo)&#123;</div><div class="line">  if(foo.hasOwnProperty(i))</div><div class="line">    console.log(i) // moo</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>prototype指向该方法的原型对象，只有函数对象有prototype<br><strong>proto</strong>是指向该对象的构造函数的原型对象，所有对象都有<strong>proto</strong>，<strong>proto</strong>是普通对象的隐式属性，在new的时候会指向该对象的构造函数的原型对象</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function F()&#123;</div><div class="line">&#125;</div><div class="line">var f=new F();</div><div class="line">f.__proto__==F.prototype //true</div></pre></td></tr></table></figure></p>
<p>构造函数.prototype=原型对象<br>原型对象.constructor=构造函数<br>实例.<strong>proto</strong>=构造函数.prototype<br>isPrototypeof(实例对象)判断实例对象的原型是不是当前对象。</p>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">


</div>



	<div class="article-share" id="share">
	
	  <div data-url="https://aliceflaviawang.github.io/2017/07/03/前端面试准备/" data-title="前端面试准备 | 笑呵呵" data-tsina="null" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2017/06/25/原生JavaScript实现Ajax/" title="原生JavaScript实现Ajax">
  <strong>上一篇：</strong><br/>
  <span>
  原生JavaScript实现Ajax</span>
</a>
</div>


<div class="next">
<a href="/2017/07/10/Bootsstrap实现原理/"  title="Bootsstrap实现原理">
 <strong>下一篇：</strong><br/> 
 <span>Bootsstrap实现原理
</span>
</a>
</div>

</nav>

	

</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
 
 <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、cookie的优点及弊端"><span class="toc-number">1.</span> <span class="toc-text">1、cookie的优点及弊端</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#优点：极高的扩展性和可用性"><span class="toc-number">1.1.</span> <span class="toc-text">优点：极高的扩展性和可用性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#缺点："><span class="toc-number">1.2.</span> <span class="toc-text">缺点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#session"><span class="toc-number">1.3.</span> <span class="toc-text">session</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cookie与session的区别"><span class="toc-number">1.4.</span> <span class="toc-text">cookie与session的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、浏览器的本地存储（web-storage）"><span class="toc-number">2.</span> <span class="toc-text">2、浏览器的本地存储（web storage）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3、web-storage和cookie的区别"><span class="toc-number">3.</span> <span class="toc-text">3、web storage和cookie的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSS相关问题"><span class="toc-number"></span> <span class="toc-text">CSS相关问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、display-none和visibility：hidden的区别"><span class="toc-number">1.</span> <span class="toc-text">1、display:none和visibility：hidden的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、css中link和-import的区别"><span class="toc-number">2.</span> <span class="toc-text">2、css中link和@import的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3、position的absolute和fixed"><span class="toc-number">3.</span> <span class="toc-text">3、position的absolute和fixed</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4、清除浮动的三种方式"><span class="toc-number">4.</span> <span class="toc-text">4、清除浮动的三种方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#方法一：增加新元素，应用clear：both"><span class="toc-number">4.1.</span> <span class="toc-text">方法一：增加新元素，应用clear：both</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#方法二：overflow"><span class="toc-number">4.2.</span> <span class="toc-text">方法二：overflow</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#方法三：伪元素：after"><span class="toc-number">4.3.</span> <span class="toc-text">方法三：伪元素：after</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5、CSS的盒子模型：W3C盒子模型和IE盒子模型"><span class="toc-number">5.</span> <span class="toc-text">5、CSS的盒子模型：W3C盒子模型和IE盒子模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6、CSS选择符有哪些？哪些属性可以继承？优先级算法如何计算？CSS3新增的伪类？"><span class="toc-number">6.</span> <span class="toc-text">6、CSS选择符有哪些？哪些属性可以继承？优先级算法如何计算？CSS3新增的伪类？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#一"><span class="toc-number">6.1.</span> <span class="toc-text">一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#二"><span class="toc-number">6.2.</span> <span class="toc-text">二</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#三"><span class="toc-number">6.3.</span> <span class="toc-text">三</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#四"><span class="toc-number">6.4.</span> <span class="toc-text">四</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7、列出display的值，说明他们的作用。position的值，relative和absolute分别是对于谁进行定位。"><span class="toc-number">7.</span> <span class="toc-text">7、列出display的值，说明他们的作用。position的值，relative和absolute分别是对于谁进行定位。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8、对BFC规范的理解"><span class="toc-number">8.</span> <span class="toc-text">8、对BFC规范的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9、CSS-spirite"><span class="toc-number">9.</span> <span class="toc-text">9、CSS spirite</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10、text-overflow-这个属性貌似问的比较多"><span class="toc-number">10.</span> <span class="toc-text">10、text-overflow(这个属性貌似问的比较多)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTML"><span class="toc-number"></span> <span class="toc-text">HTML</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、DOCTYPE"><span class="toc-number">1.</span> <span class="toc-text">1、DOCTYPE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、HTML5新特性"><span class="toc-number">2.</span> <span class="toc-text">2、HTML5新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HTML5离线存储技术"><span class="toc-number">2.1.</span> <span class="toc-text">HTML5离线存储技术</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3、iframe的优缺点"><span class="toc-number">3.</span> <span class="toc-text">3、iframe的优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#优点："><span class="toc-number">3.1.</span> <span class="toc-text">优点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#缺点"><span class="toc-number">3.2.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4、如何实现浏览器多个标签页之间的通信"><span class="toc-number">4.</span> <span class="toc-text">4、如何实现浏览器多个标签页之间的通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5、WebSocket如何兼容低浏览器"><span class="toc-number">5.</span> <span class="toc-text">5、WebSocket如何兼容低浏览器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#WebSocket"><span class="toc-number">5.1.</span> <span class="toc-text">WebSocket</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#WebSocket的作用"><span class="toc-number">5.1.1.</span> <span class="toc-text">WebSocket的作用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如何在不支持WebSocket的客户端上使用"><span class="toc-number">5.2.</span> <span class="toc-text">如何在不支持WebSocket的客户端上使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6、null和undefined的区别"><span class="toc-number">6.</span> <span class="toc-text">6、null和undefined的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#null"><span class="toc-number">6.1.</span> <span class="toc-text">null</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-number">6.2.</span> <span class="toc-text">undefined</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7、new操作符具体干了什么"><span class="toc-number">7.</span> <span class="toc-text">7、new操作符具体干了什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8、跨域问题"><span class="toc-number">8.</span> <span class="toc-text">8、跨域问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#同源策略"><span class="toc-number">8.1.</span> <span class="toc-text">同源策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#跨域方法"><span class="toc-number">8.2.</span> <span class="toc-text">跨域方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1、跨域资源共享（CORS"><span class="toc-number">8.2.1.</span> <span class="toc-text">1、跨域资源共享（CORS)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2、通过jsonp跨域"><span class="toc-number">8.2.2.</span> <span class="toc-text">2、通过jsonp跨域</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#JSOPN的优缺点"><span class="toc-number">8.2.2.1.</span> <span class="toc-text">JSOPN的优缺点</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#CORS和JSONP的对比"><span class="toc-number">8.2.2.2.</span> <span class="toc-text">CORS和JSONP的对比</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3、通过修改document-domain来跨域（iframe）"><span class="toc-number">8.2.3.</span> <span class="toc-text">3、通过修改document.domain来跨域（iframe）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4、window-name"><span class="toc-number">8.2.4.</span> <span class="toc-text">4、window.name</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5、HTML5的window-postMessage方法"><span class="toc-number">8.2.5.</span> <span class="toc-text">5、HTML5的window.postMessage方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9、document-write和innerHTML的区别"><span class="toc-number">9.</span> <span class="toc-text">9、document.write和innerHTML的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10、内存泄露"><span class="toc-number">10.</span> <span class="toc-text">10、内存泄露</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11、作用域链"><span class="toc-number">11.</span> <span class="toc-text">11、作用域链</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#javascript中的作用域"><span class="toc-number">11.1.</span> <span class="toc-text">javascript中的作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#全局作用域"><span class="toc-number">11.1.1.</span> <span class="toc-text">全局作用域</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#局部作用域"><span class="toc-number">11.1.2.</span> <span class="toc-text">局部作用域</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#作用域链"><span class="toc-number">11.2.</span> <span class="toc-text">作用域链</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#作用域链的创建"><span class="toc-number">11.2.1.</span> <span class="toc-text">作用域链的创建</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#作用域链的作用"><span class="toc-number">11.2.2.</span> <span class="toc-text">作用域链的作用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#变量提升的问题"><span class="toc-number">11.2.3.</span> <span class="toc-text">变量提升的问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#作用域链的延长"><span class="toc-number">11.2.4.</span> <span class="toc-text">作用域链的延长</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#with语句"><span class="toc-number">11.2.4.1.</span> <span class="toc-text">with语句</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#catch块"><span class="toc-number">11.2.4.2.</span> <span class="toc-text">catch块</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12、闭包"><span class="toc-number">12.</span> <span class="toc-text">12、闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#闭包的特性"><span class="toc-number">12.1.</span> <span class="toc-text">闭包的特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#闭包的定义及其优缺点"><span class="toc-number">12.2.</span> <span class="toc-text">闭包的定义及其优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#闭包使用注意点"><span class="toc-number">12.3.</span> <span class="toc-text">闭包使用注意点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13、javascript中的this"><span class="toc-number">13.</span> <span class="toc-text">13、javascript中的this</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#不同的调用方式"><span class="toc-number">13.1.</span> <span class="toc-text">不同的调用方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1、作为对象的方法调用"><span class="toc-number">13.1.1.</span> <span class="toc-text">1、作为对象的方法调用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2、作为函数调用"><span class="toc-number">13.1.2.</span> <span class="toc-text">2、作为函数调用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3、独立函数调用"><span class="toc-number">13.1.3.</span> <span class="toc-text">3、独立函数调用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4、作为构造函数使用"><span class="toc-number">13.1.4.</span> <span class="toc-text">4、作为构造函数使用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5、在setTimeout、setInterval和匿名函数中"><span class="toc-number">13.1.5.</span> <span class="toc-text">5、在setTimeout、setInterval和匿名函数中</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6、函数调用call和apply方法时"><span class="toc-number">13.1.6.</span> <span class="toc-text">6、函数调用call和apply方法时</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7、函数调用bind方法时"><span class="toc-number">13.1.7.</span> <span class="toc-text">7、函数调用bind方法时</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14、prototype和原型链"><span class="toc-number">14.</span> <span class="toc-text">14、prototype和原型链</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1、javascript的设计意图"><span class="toc-number">14.1.</span> <span class="toc-text">1、javascript的设计意图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2、prototype原型"><span class="toc-number">14.2.</span> <span class="toc-text">2、prototype原型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3、原型链"><span class="toc-number">14.3.</span> <span class="toc-text">3、原型链</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4、hasOwnProperty与in操作符"><span class="toc-number">14.4.</span> <span class="toc-text">4、hasOwnProperty与in操作符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#总结"><span class="toc-number">14.5.</span> <span class="toc-text">总结</span></a></li></ol></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  


  

  

  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="https://github.com/jsfront/" target="_blank" title="JS高级前端开发">JS高级前端开发</a>
            
          </li>
        
          <li>
            
            	<a href="https://segmentfault.com/" target="_blank" title="segmentfault">segmentfault</a>
            
          </li>
        
          <li>
            
            	<a href="https://stackoverflow.com/" target="_blank" title="stackoverflow">stackoverflow</a>
            
          </li>
        
          <li>
            
            	<a href="https://github.com/jikeytang/front-end-collect" target="_blank" title="前端收集">前端收集</a>
            
          </li>
        
    </ul>
</div>

  


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m Alice Page in Google. <br/>
			This is my blog,believe it or not.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/2176287895" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>
<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>









<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->









<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
