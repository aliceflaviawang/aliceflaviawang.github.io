{"meta":{"title":"笑呵呵","subtitle":"Live beautifully, dream passionately, love completely","description":"You Never Know Who You Can Be","author":"Alice","url":"https://aliceflaviawang.github.io"},"pages":[{"title":"about","date":"2017-04-17T13:23:23.000Z","updated":"2017-04-17T13:23:23.051Z","comments":true,"path":"about/index.html","permalink":"https://aliceflaviawang.github.io/about/index.html","excerpt":"","text":""}],"posts":[{"title":"bind(), delegate(), on()方法区别","slug":"bind-delegate-on-方法区别","date":"2017-06-23T08:51:44.000Z","updated":"2017-06-23T09:12:23.824Z","comments":true,"path":"2017/06/23/bind-delegate-on-方法区别/","link":"","permalink":"https://aliceflaviawang.github.io/2017/06/23/bind-delegate-on-方法区别/","excerpt":"","text":"bind()：$(selector).bind(event,data,function)123$(&quot;div p&quot;).bind(&quot;click&quot;,function()&#123; &#125;) 使用bind()方法为所有div里的p元素都绑定了click事件，存在的问题：1）这里使用了隐式迭代，如果匹配到的元素特别多，影响了性能；2）对于尚未存在的元素，无法绑定。动态添加的p元素，点击会没有响应。顺便提一下，bind()的简写方式：123$(&quot;div p&quot;).click(function()&#123;&#125;) delegate():$(selector).delegate(childSelector,event,data,function)123$(&quot;div&quot;）.delegate(&quot;p&quot;,&quot;click&quot;,function()&#123; &#125;) 事件委托方式，不直接为p元素绑定事件，而是为其父元素（或祖先元素）绑定事件，当在div内任意元素点击时，事件会一层层从event.target向上冒泡，直到达到为其绑定事件的元素，如此例中的div元素。冒泡的过程中，如果事件的currentTarget与选择器匹配时就会执行代码。delegate()方法解决了bind具有的两个问题，但是如果事件目标在DOM树很深的位置，这样一层层来查找与选择器匹配的元素，又影响了性能。 on():$(selector).on(event,childselector,data,function)12$(&quot;div&quot;).on(&quot;click&quot;,&quot;p&quot;,function()&#123;&#125;) 看jQuery源代码发现，无论是bind()还是delegate()，都是通过on()方法实现的，只是参数不同。12345678910111213bind: function( types, data, fn ) &#123; return this.on( types, null, data, fn ); &#125;, unbind: function( types, fn ) &#123; return this.off( types, null, fn ); &#125;, delegate: function( selector, types, data, fn ) &#123; return this.on( types, selector, data, fn ); &#125; undelegate: function( selector, types, fn ) &#123; // ( namespace ) or ( selector, types [, fn] ) return arguments.length === 1 ? this.off( selector, &quot;**&quot; ) : this.off( types, selector || &quot;**&quot;, fn ); &#125; 总结1、选择器匹配元素较多时，不要使用bind()迭代绑定2、id选择器时，可以用bind()3、需要动态绑定时，用delegate()或on()4、用delegate()或on()，DOM树不要太深5、尽量使用on()","categories":[],"tags":[],"keywords":[]},{"title":"jQuery性能优化","slug":"jQuery性能优化","date":"2017-06-23T02:14:53.000Z","updated":"2017-06-23T08:48:32.480Z","comments":true,"path":"2017/06/23/jQuery性能优化/","link":"","permalink":"https://aliceflaviawang.github.io/2017/06/23/jQuery性能优化/","excerpt":"","text":"1、使用最新版本的jQuery类库jQuery每个新版本都会较上个版本进行bug修复和优化，同时进行一些创新。 2、使用合适的选择器jQuery提供了丰富的选择器来定位DOM元素，下面介绍几种常用的选择器及它们之间的性能差异： $(“#id”)使用id来定位DOM元素是最佳提高性能的方式，因为jQuery底层将直接调用本地方法document.getElementById()。如果不能直接找到，还可以考虑调用find()方法：1$(&quot;#content&quot;).find(&quot;div&quot;); 使用以上方法可以有效缩小定位DOM元素的范围，为了提高性能，可以从最近的ID元素开始往下搜索。 $(“p”),$(“div”),$(“input”)标签选择器是性能优化的第二选择，因为jQuery将直接调用本地方法document.getElementByTagName()来定位DOM元素。 $(“.class”)对于较新的浏览器，支持本地方法document.getElementByClassName(),老的浏览器如IE8及更早版本只能靠使用DOM搜索方式来实现，这无疑对性能产生较大的影响。所以有选择性的使用它。 $(“[attribute=value]”)利用属性定位DOM元素，本地JavaScript方法并没有直接实现，大多是使用DOM搜索方式来达到效果，很多现代浏览器支持querySelectAll()方法，但是浏览器之间还是有区别。 $(“:hidden”)和上面利用属性定位DOM方式类似，这种伪选择器也没有直接在本地JavaScript实现，并且jQuery需要搜索每一个元素来定位这个选择器，这对性能影响较大。如果一定要用这种方式，建议先用id定位父元素再使用该选择器，这样有助于优化性能。1$(&quot;#content&quot;).find(&quot;:hidden&quot;); 以上是使用选择器的基本规则，性能自上而下依次下降。 3、缓存对象开发人员经常喜欢这样写：12$(&quot;#traffic input.on&quot;).bind(&quot;click&quot;,function&#123;&#125;);$(&quot;#traffic&quot;).css(&quot;border&quot;,&quot;1px solid red&quot;)) 这样写导致的结果是jQuery会在每个选择器创建的过程中，查找DOM，创建多个jQuery对象。比较好的方式：123var $traffic=$(&quot;#traffic&quot;);$traffic.bind(&quot;click&quot;,function()&#123;&#125;).css(&quot;border&quot;,&quot;1px solid red&quot;) //使用链式结构让代码更简洁 如果希望在其他函数中使用jQuery对象，可以把它缓存放全局环境中。1234567891011//在全局范围内定义一个对象（例如window对象）window.$my=&#123; head:$(&quot;head&quot;), traffic:$(&quot;#traffic&quot;), &#125;function do()&#123; var script=document.createElement(&quot;script&quot;); $my.head.append(script); //现在可以引用存储的结果并操作它们 $my.coll=$(&quot;#ul li&quot;);//在函数内部操作时，可以继续将查询存入全局对象中 $my.coll.css(&quot;border-color&quot;,&quot;red&quot;); //将全局函数作为一个普通的jquery对象使用 &#125; 4、循环时的DOM操作使用for,while,$.each处理节点时，要注意：12345var top=[];//假设是100个字符串var list=$(&quot;#list&quot;);for(var i=0;i&lt;top.length;i++)&#123; list.append(&quot;&lt;li&gt;&quot;+top[i]+&quot;&lt;/li&gt;&quot;); &#125; 以上每添加一个新的标签元素都作为一个节点添加容器ID中，循环了100次，消耗较大。应该将整个元素字符串在插入DOM中全部创建好：1234567var top=[];//假设是100个字符串var list=$(&quot;#list&quot;);var mylist=&quot;&quot;;//暂存列表元素for(var i=0;i&lt;top.length;i++)&#123; mylist+=&quot;&lt;li&gt;&quot;+top[i]+&quot;&lt;/li&gt;&quot;; &#125;list.append(mylist); 非常类似与DOM操作中用createElementFragment一次性添加全部DOM节点，再一次性更新DOM：1234567var fragment=document.createElementFragment();for(var i=0;i&lt;items.length;i++)&#123; var item=document.createElement(&quot;li&quot;); item.append(document.createTextNode(&quot;option&quot;+i); fragment.appendChild(item); &#125;list.appendChild(fragment); 5、数组方式使用jQuery对象使用for或者while循环而不是$.each()能使代码更快。 6、事件代理每个javascript事件都会冒泡到父级节点。当需要给多个元素同个函数时，事件代理会很有用。123$(&quot;#table td&quot;).click(function()&#123; $(this).css(&apos;background&apos;,&apos;red&apos;) &#125;) 假设有100个td元素，使用上述方法，将会绑定100个事件，对性能影响很大。代替这种多元素事件监听的方法是，只需要向他们的父节点绑定一次事件，然后通过event.target获取到点击的当前元素：123$(&quot;#table&quot;).click(function(event)&#123; $(event.target).css(&apos;background&apos;,&apos;red&apos;); //event.target捕捉触发的目标元素 &#125;) 改进的方式中，只为一个元素绑定了1个事件。jQuery 1.7中提供了on方式，on(type,[selector],[data],fn)中增加了selector，如果能够匹配到该selector则执行此方法：123$(&quot;#table&quot;).on(&quot;click&quot;,&quot;td&quot;,function()&#123; $(this).css(&apos;background&apos;,&apos;red&apos;);&#125;) 7、将代码转化成jQuery插件将代码转化成插件能让代码具有更好的重用性。 8、使用join()来拼接字符串使用join来拼接字符串比使用”+“来拼接长字符串性能更优。首先创建一个数组，然后循环，最后通过join()将数组转化成字符串：12345var array=[];for(int i=0;i&lt;100;i++)&#123; array[i]=&apos;&lt;li&gt;&apos;+i+&apos;&lt;/li&gt;&apos;; &#125;$(&apos;#list&apos;).html(array.join(&apos;&apos;)); 9、合理利用HTML5的Data属性HTML5的data属性可以帮助我们插入数据，特别是前后端的数据交换。jQuery的data（）方法，有效的利用HTML5的属性，来自动得到数据。12345&lt;div id=&quot;dl&quot; data-role=&quot;page&quot; data-last=&quot;43&quot; data-options=&apos;&#123;&quot;name&quot;:&quot;John&quot;&#125;&apos;&gt;&lt;/div&gt;//读取数据$(&quot;#dl&quot;).data(&quot;role&quot;); //&quot;page&quot;$(&quot;#dl&quot;).data(&quot;last&quot;); //43$(&quot;#dl&quot;).data(&quot;options&quot;).name; //&quot;John&apos; 10、尽量使用原生的JavaScript方法123456var $cr=$(&quot;#cr&quot;);$cr.click(function()&#123; if($cr.is(&quot;:checked&quot;))&#123; //jQuery方式判断 &#125;&#125;) 它使用了jQuery提供的is方法来判断多选框是否被选中，但是这里可以直接使用原生的JavaScript方法：123456var $cr=$(&quot;#cr&quot;); //jQuery对象var cr=$cr.get(0); //DOM对象$cr.click(function()&#123; if(cr.checked)&#123; //原生的js方式判断 &#125;&#125;) 第二种方式比第一种方式效率高，因为它不需要拐弯抹角去调用许多函数。 11、压缩JavaScript一方面使用Gzip，另一方面去除JS文件里的注释、空白。","categories":[],"tags":[],"keywords":[]},{"title":"页面内跳转方法总结","slug":"页面内跳转方法总结","date":"2017-06-22T08:31:43.000Z","updated":"2017-06-22T09:04:27.613Z","comments":true,"path":"2017/06/22/页面内跳转方法总结/","link":"","permalink":"https://aliceflaviawang.github.io/2017/06/22/页面内跳转方法总结/","excerpt":"","text":"方法一：用标签，在href里写入定位的DIV的id.如：1234&lt;a href=&quot;#div1&quot;&gt;scroll to div1&gt;&lt;/a&gt; //定位到div1&lt;div id=&quot;div1&quot;&gt;div1&lt;/div&gt;&lt;div id=&quot;div2&quot;&gt;div2&lt;/div&gt;&lt;div id=&quot;div3&quot;&gt;div3&lt;/div&gt; 缺点：点击锚点后，浏览器的URL会发生变化，刷新会出现问题。 方法二：使用js中的window.location.hash=”divId”跳转，但地址也会发生变化，跟第一种方法差不多。123456&lt;a href=&quot;javascript:void(0)&quot; onclick=&quot;locate()&quot;&gt;&lt;/a&gt;&lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; funtion locate()&#123; window.location.hash=&quot;#div1&quot;;&#125; 方法三：用animate属性，当点击锚点后，页面滚动到相应的div。12345678&lt;a href=&quot;javascript:void(0)&quot; onclick=&quot;locate()&quot;&gt;&lt;/a&gt;&lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function lacate()&#123; $(&quot;html&quot;,&quot;body&quot;).animate(&#123; scrollTop:$(&quot;#div1&quot;).offset().top &#125;,&#123;duration:500,easing:&quot;swing&quot;&#125;) &#125; 优点：url地址不会改变，同时点击锚点会自动响应scroll事件，不需要重新绑定。缺点：如果页面复杂的话，偏移值可能会发生变化需要算法辅助。 方法四：用js的scrollIntoView方法，直接用：123456&lt;a href=&quot;javascript:void(0)&quot; onclick=&quot;locate()&quot;&gt;&lt;/a&gt;&lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;function lacate()&#123; docuemnt.getElementById(&quot;div1&quot;).scrollIntoView();&#125; 优点：url不会变，同时能够响应scroll事件，不需要算法什么的。注意：scrollIntoView是js方法，不能使用$(“#div1”).scrollIntoView().","categories":[],"tags":[],"keywords":[]},{"title":"JSON.parse()和Json.stringify()","slug":"JSON-parse-和Json-stringify","date":"2017-06-22T02:01:30.000Z","updated":"2017-06-22T02:14:29.284Z","comments":true,"path":"2017/06/22/JSON-parse-和Json-stringify/","link":"","permalink":"https://aliceflaviawang.github.io/2017/06/22/JSON-parse-和Json-stringify/","excerpt":"","text":"JSON.parse()parse是用一个字符串中解析出json对象，如：var str=’{“name”:”alice”,”age”:”23”}’结果：JSON.parse(str)Objectage:”23”name:”alice”proto:Object 注意：单引号写在{}外面，每个属性名必须用双引号，否则会报错 JSON.stringify()stringify是从对象解析出字符串，如：var a={a:1,b:2}JSON.stringify(a)‘{“a”:1,”b”:2}’","categories":[],"tags":[],"keywords":[]},{"title":"serialize()系列方法","slug":"serialize-系列方法","date":"2017-06-17T11:22:16.000Z","updated":"2017-06-17T13:25:38.569Z","comments":true,"path":"2017/06/17/serialize-系列方法/","link":"","permalink":"https://aliceflaviawang.github.io/2017/06/17/serialize-系列方法/","excerpt":"","text":"serialize()jQuery有方法$.fn.serialize()，可以将表单序列化成字符串。提交表单的时候，将表单的每个元素表达成如：username:$(“#username”).val(),content:$(“#content”).val()…无疑随着表单元素越来越复杂，这种方式在增大工作量的同时也使表单元素缺乏弹性。采用serialize（）方法可以将需要提交的字段内容序列化为字符串，username:$(“#username”).val(),content:$(“#content”).val()…可以用一个语句代替:$(“#form”).serialize(),其中#form是表单的id。 serialize()的其他两种方法–serializeArray()和serializeObject()serializeArray()是将表单序列化为JSON格式的数据，输出的是对象数组。而serializeObject()是基于serializeArray（）编写的。下面例子能非常清晰的看出其中的区别：123$(&quot;#form&quot;).serialize(); //username=&amp;content=$(&quot;#form&quot;).serializeArray(); //[&#123;name:&quot;username&quot;,value:&quot;&quot;&#125;,&#123;name:&quot;content&quot;,value:&quot;&quot;&#125;]$(&quot;#form&quot;).serializeObject(); //&#123;username:&quot;&quot;,content:&quot;&quot;&#125; 注意1、serializeObject()直接使用的话，会提示serializeObject()is not a funtion.因为serializeObject()本身并不是一个jQuery自带的功能，而是基于serializeArray（）的添加功能，需要对其进行定义如下：12345678910111213141516$.fn.serializeObject()&#123; var o=&#123;&#125;; //保存对象 var a=this.serializeArray(); //先将元素序列化为对象数组 $.each(a,function()&#123; if(o[this.name])&#123;//表单中可能有多个相同的label，在插入第一个label后，还有继续插入，这个时候o[label]已经存在了，所以要把o[label]做嵌套处理 if（！o[this.name].push)&#123; //如果o[label]不是嵌套在数组里面，实际上就是看o[this.name]是不是一个数组，数组有push方法，对象没有 o[thos.name]=[o[this.name]];将o[label]初始为嵌套数组 &#125; o[this.name].push(this.value||&apos;&apos;); //将值插入o[label]数组里 &#125; else&#123; o[this.name]=this.value||&apos;&apos;;//第一次在o中插入o[label] &#125; &#125;) return o;&#125; 举个例子,对于下面的表单：123456&lt;form id=&quot;form&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt; &lt;input type=&quot;text&quot; name=&quot;content&quot; /&gt; &lt;input type=&quot;button&quot; id=&quot;send&quot; onclick=&quot;sen();&quot;&gt;&lt;/form&gt; 执行三个函数，分别结果为：12345var a=$(&quot;#form&quot;).serialize(); //username=alice&amp;username=bob&amp;content=123 var b=$(&quot;#form&quot;).serializeArray(); //[&#123;name:&quot;username&quot;,value=&quot;alice&quot;&#125;,&#123;name:&quot;username&quot;,value=&quot;bob&quot;&#125;,&#123;name:&quot;content&quot;,value=&quot;123&quot;&#125;]var c=$(&quot;#form&quot;).serializeObject(); //&#123;username:[&quot;alice&quot;,&quot;bob&quot;],content:&quot;123&quot;&#125; 2、表单元素要序列化必须要使用name属性，form里的name不能用js、jquery的关键字，否则获取不到值。3、不光表单能用到serialize()方法，其他选择器元素也可以。比如：1$(&quot;:checkbox,:radio&quot;).serialize()","categories":[],"tags":[],"keywords":[]},{"title":"EasyUI更改弹出框位置","slug":"EasyUI更改弹出框位置","date":"2017-06-15T02:15:18.000Z","updated":"2017-06-15T02:21:15.667Z","comments":true,"path":"2017/06/15/EasyUI更改弹出框位置/","link":"","permalink":"https://aliceflaviawang.github.io/2017/06/15/EasyUI更改弹出框位置/","excerpt":"","text":"EasyUI的dialog弹出一般用的是$(‘#dlg’).dialog(‘open’)，要想调整其位置，可以采用$(‘#dlg’).window(‘open’)，再用window的resize方法重新布局就可以了。如：1$(&apos;#dlg&apos;).dialog(&apos;open&apos;).dialog(&apos;center&apos;).dialog(&apos;setTitle&apos;, &apos;添加题目&apos;); 可以改成：1$(&apos;#dlg&apos;).window(&apos;open&apos;).window(&apos;setTitle&apos;,&apos;添加题目&apos;).window(&apos;resize&apos;,&#123;width:&apos;500px&apos;,height:&apos;800px&apos;,top:&apos;30px&apos;&#125;","categories":[],"tags":[],"keywords":[]},{"title":"a标签中href=''的几种用法","slug":"a标签中href-的几种用法","date":"2017-06-13T06:54:22.000Z","updated":"2017-06-13T12:29:08.779Z","comments":true,"path":"2017/06/13/a标签中href-的几种用法/","link":"","permalink":"https://aliceflaviawang.github.io/2017/06/13/a标签中href-的几种用法/","excerpt":"","text":"a标签的主要作用是实现超链接和锚点，下面总结下a标签href的几种用法。 一、href的几种调用方法1、a href=”javascript:js_method();”这是常用的方法，但是这种方法在传递this等参数的时候很容易出问题，而且javascript：协议作为a的href属性的时候不仅会导致不必要的触发window.onbeforeunload事件，在IE里面更会使gif动画图片停止播放。W3C标准不推荐在href里面执行javascript语句。 2、a href=”javascript:void(0);” onclick=”js_method()”这种方法是很多网站最常用的方法，也是最周全的方法，onclick方法负责执行js函数，而void是一个操作符，void(0)返回undefined，地址不发生跳转。而且这种方法不会像第一种方法一样直接js方法暴露在浏览器的状态栏。 3、a href=”javascript:;” onclick=”js_method()”这种方法跟2类似，区别只是执行了一条空的js代码 4、a href=”#” onclick=”js_method()”这种方法也是网上很常见的代码，#是标签内置的一个方法，”#”包含了一个位置信息，默认的锚点是#top,就是点击后返回页面的顶端。（如果希望不返回页面顶端，可以在#后面加任意无效的位置信息，如###） 5、a href=”#” onclick=”js_method();return false;”这种方法点击执行了js函数后return false,页面不发生跳转，执行后还是在页面的当前位置。","categories":[],"tags":[],"keywords":[]},{"title":"return false实现同时对事件对象停止冒泡和默认行为","slug":"return-false实现同时对事件对象停止冒泡和默认行为","date":"2017-06-12T08:06:54.000Z","updated":"2017-06-12T09:17:10.934Z","comments":true,"path":"2017/06/12/return-false实现同时对事件对象停止冒泡和默认行为/","link":"","permalink":"https://aliceflaviawang.github.io/2017/06/12/return-false实现同时对事件对象停止冒泡和默认行为/","excerpt":"","text":"冒泡网页上有两个元素，其中一个元素嵌套在另一个元素里面，并且都被绑定了click事件，那么点击内层元素，会冒泡到外层元素上。1234567891011121314151617181920212223242526&lt;body&gt;&lt;div id=&quot;content&quot;&gt; 外层div元素 &lt;span&gt;内层div元素&lt;/span&gt; 外层div元素&lt;/div&gt;&lt;div id=&apos;msg&apos;&gt;&lt;/div&gt;&lt;script&gt;$(function()&#123; $(&apos;span&apos;).bind(&apos;click&apos;,function()&#123; var txt=$(&apos;#msg&apos;).html()+&apos;&lt;p&gt;内层div元素被单击。&lt;/p&gt;&apos;; $(&apos;#msg&apos;).html(txt); &#125;) $(&apos;#content&apos;).bind(&apos;click&apos;,function()&#123; var txt=$(&apos;#msg&apos;).html()+&apos;&lt;p&gt;外层div元素被单击。&lt;/p&gt;&apos;; $(&apos;#msg&apos;).html(txt) &#125;) $(&apos;body&apos;).bind(&apos;click&apos;,function()&#123; var txt=$(&apos;#msg&apos;).html()+&apos;&lt;p&gt;body元素被单击。&lt;/p&gt;&apos;; $(&apos;#msg&apos;).html(txt) &#125;)&#125;)&lt;/script&gt;&lt;/body&gt; 效果如图：点击span元素点击外层div元素点击内层元素，会冒泡到外层的点击事件。 阻止冒泡stopPropagation()方法可以停止事件冒泡。12345$(&apos;span&apos;).bind(&apos;click&apos;,function(event)&#123; var txt=$(&apos;#msg&apos;).html()+&apos;&lt;p&gt;内层div元素被单击。&lt;/p&gt;&apos;; $(&apos;#msg&apos;).html(txt); event.stopPropagation(); &#125;) 点击span元素 阻止默认行为网页中的元素有自己的默认行为，例如，单击“提交”按钮后表单会提交，有时需要阻止元素的默认行为。1234567891011121314151617&lt;form action=&quot;test.html&quot;&gt;用户名：&lt;input type=&quot;text&quot; id=&quot;username&quot;&gt;&lt;br/&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot; id=&quot;sub&quot;&gt;&lt;/form&gt;&lt;div id=&quot;msg&quot;&gt;&lt;/div&gt;&lt;script&gt;$(function()&#123; $(&apos;#sub&apos;).bind(&apos;click&apos;,function()&#123; var username=$(&apos;#username&apos;).val(); if(username==&apos;&apos;)&#123; $(&apos;#msg&apos;).html(&apos;&lt;p&gt;文本框的值不能为空。&lt;/p&gt;&apos;); &#125; &#125;)&#125;)&lt;/script&gt; 如果不阻止默认行为，用户名为空的时候，也能提交表单。阻止默认行为使用preventDefault()方法。1234567$(&apos;#sub&apos;).bind(&apos;click&apos;,function(event)&#123; var username=$(&apos;#username&apos;).val(); if(username==&apos;&apos;)&#123; $(&apos;#msg&apos;).html(&apos;&lt;p&gt;文本框的值不能为空。&lt;/p&gt;&apos;); event.preventDefault(); &#125; &#125;) 同时对事件对象停止冒泡和默认行为——return false将event.stopPropagation()和event.preventDefault()替换为return false就可以实现同样的效果。 return false到底做了什么1、event.preventDefault()2、event.stopPropagation()3、停止回调函数执行并立即返回return false看似实现了阻止冒泡或者阻止默认事件，实际上还做了另外的操作，阻止浏览器默认行为的只有preventDefault()，除非你想停止事件冒泡，否则使用return false会为你的代码埋下很大的隐患。 ###扩展-stopImmediatePropagation()stopImmediatePropagagtion()函数用于阻止剩余的事件处理函数的执行(为同一对象绑定了多个事件处理函数)，并防止当前事件在DOM树上冒泡。12345678910111213141516171819202122232425&lt;p&gt;段落文本内容 &lt;input type=&quot;button&quot; value=&quot;点击&quot; /&gt;&lt;/p&gt;&lt;script&gt;// 为所有p元素绑定click事件$(&quot;p&quot;).click( function(event)&#123; alert(&quot;p-click&quot;);&#125; );// 为所有button元素的click事件绑定第一个事件处理函数$(&quot;:button&quot;).click( function(event)&#123; alert(&quot;button-click-1&quot;); // 阻止事件冒泡到DOM树上，并阻止剩余的事件处理函数的执行 // 只执行button-click-1，如果注释掉该行，将执行button-click-1、button-click-2和p-click // 如果换成event.stopPropagation() 将执行button-click-1和button-click-2 event.stopImmediatePropagation();&#125; );// 为所有button元素的click事件绑定第二个事件处理函数$(&quot;:button&quot;).click( function(event)&#123; alert(&quot;button-click-2&quot;);&#125; );&lt;/script&gt; 与stopPropagation()相比，stopImmediatePropagation()还能阻止剩余事件处理函数的执行。","categories":[],"tags":[],"keywords":[]},{"title":"ajax dataType","slug":"ajax-dataType","date":"2017-06-08T02:42:09.000Z","updated":"2017-06-09T06:30:48.124Z","comments":true,"path":"2017/06/08/ajax-dataType/","link":"","permalink":"https://aliceflaviawang.github.io/2017/06/08/ajax-dataType/","excerpt":"","text":"遇到一个很奇怪的问题12345678910$.ajax(&#123; type:&quot;POST&quot;, async:false, contentType: &quot;application/json; charset=utf-8&quot;, // dataType: &apos;json&apos;, url:baseUrl+&quot;/office/getEmploymentPeriod.do&quot;, success:function(data)&#123; console.log(data) //&#123;&quot;body&quot;:&quot;2017年3月-2017年7月&quot;,&quot;message&quot;:&quot;成功&quot;,&quot;status&quot;:0&#125; console.log(data.body) // undefined &#125; 如果没有dataType:’json’,返回的data是json对象，访问data.body是undefined。加上dataType:’json’，返回的是普通对象，访问data.body可以获取到。疑问是，dataType:’json’是指定返回数据的格式是’json’，为什么会返回数据的格式是普通对象，不指定反而返回的是’json’对象，另外返回数据无论是普通对象还是json对象，按理都应该能通过对象.属性访问到。12345678910$.ajax(&#123; type:&quot;POST&quot;, async:false, contentType: &quot;application/json; charset=utf-8&quot;, dataType: &apos;json&apos;, url:baseUrl+&quot;/office/getEmploymentPeriod.do&quot;, success:function(data)&#123; console.log(data) //&#123;body: &quot;2017年3月-2017年7月&quot;, message: &quot;成功&quot;, status: 0&#125; console.log(data.body) // 2017年3月-2017年7月 &#125;","categories":[],"tags":[],"keywords":[]},{"title":"apply,call,bind用法","slug":"apply-call-bind用法","date":"2017-06-06T03:10:43.000Z","updated":"2017-06-06T06:45:04.789Z","comments":true,"path":"2017/06/06/apply-call-bind用法/","link":"","permalink":"https://aliceflaviawang.github.io/2017/06/06/apply-call-bind用法/","excerpt":"","text":"1、apply()方法——apply([thisObj[,argArray]])apply()接收两个参数：一个是运行函数的作用域，另一个是参数数组。其中第二个参数可以是Array的实例，也可以是arguments对象。 2、call()方法——call([thisObj[,arg1[, arg2[, [,.argN]]]]])与apply作用相同，区别在于接收参数方式不同。第一个参数this的值没有变化，其余参数是以列举的方式直接传递给函数。 apply, call共同之处都可以用来代替另一个对象调用一个方法，将一个函数的对象上下文从初始上下文改变为由thisObj指定的新对象。 不同之处apply最多只能有两个参数——新this对象和一个数组argArray，如果argArray不是一个有效的数组或者不是arguments对象，那么将导致一个TypeError，如果没有提供argArray和thisObj任何一个参数，那么Global对象将被用作thisObj，并且无法被传递任何参数call传递的是参数列表，。如果没有提供thisObj参数，那么Global对象被用作thisObj。apply和call功能一样，只是传入参数列表形式不同，如果某个参数数量是不固定的，当参数明确时用call，不明确时用apply，然后把参数push进数组传递，函数内部也可以通过arguments数组来遍历所有参数。 3、bind()方法——fun.bind(thisObj[,arg1[, arg2[, [,.argN]]]]])与apply和call不同的是，bind会返回一个改变this指向的新函数，新函数与之前的使用的不是同一块内存地址，所以需要重复使用这个函数的时候，必须将其保存到一个变量，方便下次调用。而apply和call都是调用即执行。另外，bind函数中的首个参数，会自动成为返回新函数中参数的默认值，那么正式调用的时候，只需给出除首个参数外，剩余参数即可。 123456function f(x,y)&#123; console.log(x+y);&#125;f.call(null,1,1) //return 2var new_f=f.bind(null,1,1);new_f(2); //return 2 上面实例中thisArg参数均用null代替了，在未给出指定thisArg对象情况下，null与undefined下this指向的是全局对象，即js代码执行环境。 apply, call, bind比较123456789101112var obj=&#123;bar:&apos;hello&apos;&#125;var foo=&#123; get:function()&#123; return this.bar; &#125;&#125;var bind=foo.get.bind(obj), call=foo.get.call(obj), apply=foo.get.apply(obj);console.log(bind(),call,apply); //hello hello helloconsole.log(bind,call,apply); //function()&#123;return this.bar;&#125; &quot;hello&quot; &quot;hello&quot;console.log(typeof bind,typeof call,typeof apply); function string stringconsole.log(typeof bind(),typeof call,typeof apply); //string string string 三者的区别是：当你希望改变上下文环境之后并非立即执行，而是回调执行的时候，使用bind()方法，而apply/call则会立即执行函数。1234apply, call, bind三者都是用来改变函数的this对象的指向apply, call, bind三者第一个参数都是this要指向的对象，也就是想指定的上下文apply, call, bind三者都可以利用后续参数传参bind是返回对应的函数，便于稍后调用；apply, call则立即调用","categories":[],"tags":[],"keywords":[]},{"title":"JS定义变量的三种方式","slug":"JS定义变量的三种方式","date":"2017-06-05T03:05:49.000Z","updated":"2017-06-05T03:18:28.496Z","comments":true,"path":"2017/06/05/JS定义变量的三种方式/","link":"","permalink":"https://aliceflaviawang.github.io/2017/06/05/JS定义变量的三种方式/","excerpt":"","text":"1、最常见的var定义变量，可以修改，如果不初始化会输出undefined,但不会报错。12345678var a=1;console.log(&apos;函数外定义a:&apos;+a); //输出a=1function change()&#123; a=4; console.log(&apos;函数内定义a:&apos;+a); //可以输出a=4;&#125;change();console.log(&apos;函数调用后var定义a为函数内部修改值:&apos;+a); //输出a=4 2、const定义的变量不可以修改，而且必须初始化。12345const b=2;// const b; //错误，必须初始化console.log(b); //有输出值// b=5;console.log(b); //报错，不能给常量赋值 3、let是块级作用域，函数内部使用let定义后，对函数外部无影响。12345678let c=3;console.log(&apos;函数外定义c:&apos;+c); //输出c=3;function change()&#123; let c=6; console.log(&apos;函数内定义c:&apos;+c); //输出c=6;&#125;change();console.log(&apos;函数调用后let定义c不受函数内部定义的影响：&apos;+c); //输出c=3;","categories":[],"tags":[],"keywords":[]},{"title":"从输入URL到浏览器显示页面发生了什么","slug":"从输入URL到浏览器显示页面发生了什么","date":"2017-05-27T02:06:07.000Z","updated":"2017-05-27T07:15:26.824Z","comments":true,"path":"2017/05/27/从输入URL到浏览器显示页面发生了什么/","link":"","permalink":"https://aliceflaviawang.github.io/2017/05/27/从输入URL到浏览器显示页面发生了什么/","excerpt":"","text":"从输入URL到浏览器显示页面，这个过程分为两个部分：网络通信和页面渲染。 一、网络通信互联网内各网络设备间的通信都遵循TCP/IP协议，利用TCP/IP协议族进行网络通信时，会通过分层顺序与对方进行通信。分层由高到低分别为：应用层、传输层、网络层、数据链路层。发送端从应用层往下走，接收端从数据链路层往上走。如下图所示： 1.在浏览器中输入URL用户输入URL，例如http://www.baidu.com。其中http为协议，www.baidu.com为网络地址，及指出需要的资源在那台计算机上。一般网络地址可以为域名或IP地址，此处为域名。使用域名是为了方便记忆，但是为了让计算机理解这个地址还需要把它解析为IP地址。 2.应用层DNS解析域名客户端先检查本地是否有对应的IP地址，若找到则返回响应的IP地址。若没找到则请求上级DNS服务器，直至找到根节点。 3.应用层客户端发送HTTP请求HTTP请求包括请求报头和请求主体两个部分，其中请求报头包含了至关重要的信息，包括请求的方法（GET/POST)、目标URL、遵循的协议（HTTP/HTTPS/FTP…),返回的信息是否需要缓存，以及客户端是否发送cookie等。 4.传输层TCP传输报文位于传输层的TCP协议为传输报文提供可靠的字节流服务。它为了方便传输，将大块的数据分割成以报文段位单位的数据包进行管理，并为它们编号，方便服务器接收时能准确地还原报文信息。TCP协议通过“三次握手”等方法保证传输的安全可靠。“三次握手”的过程是，发送端先发送一个带有SYN标志的数据包给接收端，在一定的延迟时间内等待接收的回复。接收端收到数据包后，传回一个带有SYN/ACK标志的数据包以示传达确认信息。接收方收到后再发送一个带有ACL标志的数据包给接收端以示握手成功。在这个过程中，如果发送端在规定延迟时间内没有收到回复则默认接收方没有收到请求，而再次发送，直到收到回复为止。 5.网络层IP协议查询MAC地址IP协议的作用是把TCP分割好的各种数据包传送给接收方。而要保证确实能传到接收方还需要接收方的MAC地址，也就是物理地址。IP地址和MAC地址是一一对应的关系，一个网络设备的IP地址可以更换，但是MAC地址一般是固定不变的。ARP协议可以将IP地址解析成对应的MAC地址。当通信的双方不在同一个局域网时，需要多次中转才能到达最终的目标，在中转的过程中需要通过下一个中转站的MAC地址来搜索下一个中转目标。 6.数据到达数据链路层在找到对方的MAC地址后，就将数据发送到数据链路层传输。这时客户端发送请求的阶段结束。 7.服务器接收数据接收端的服务器在链路层接收到数据包，再层层向上直到应用层。这过程中包括在运输层通过TCP协议将分段的数据包重新组成原来得HTTP请求报文。 8.服务器响应请求服务接收到客户端发送的HTTP请求后，查找客户端请求的资源，并返回响应报文，响应报文中包括一个重要的信息————状态码。状态码由三位数字组成，其中比较常见的是200 OK表示请求成功。301表示永久重定向，即请求的资源已经永久转移到新的位置。在返回301状态码的同时，响应报文也会附带重定向的URL，客户端接收后将HTTP请求的URL做相应的改变再重新发送。404 not found表示客户端请求的资源找不到。 9.服务器返回相应文件请求成功后，服务器会返回相应的HTML文件。接下来就到了页面渲染阶段了。 二、页面渲染现代浏览器渲染页面的过程是这样的：解析HTML以构建DOM树——&gt;构建渲染树——&gt;布局渲染树——&gt;绘制渲染树。DOM树是由HTML文件中的标签排列组成，渲染树是在DOM树种加入CSS或HTML中的style样式而形成。渲染树只包含显示在页面中的DOM元素，像元素或display属性值为none的元素都不在渲染树中。在浏览器还没接收到完整的HTML文件时，它就开始渲染页面了，在遇到外部链入的脚本标签或样式标签或图片时，会再次发送HTTP请求重复上述的步骤。在收到CSS文件后会对已经渲染的页面重新渲染，加入它们应有的样式，图片文件加载完立刻显示在相应位置。在这一过程中可能会触发页面的重绘或重排。","categories":[],"tags":[],"keywords":[]},{"title":"DOM性能提升","slug":"DOM性能提升","date":"2017-05-26T07:42:01.000Z","updated":"2017-05-26T08:51:27.848Z","comments":true,"path":"2017/05/26/DOM性能提升/","link":"","permalink":"https://aliceflaviawang.github.io/2017/05/26/DOM性能提升/","excerpt":"","text":"DOM(文档对象模型)是针对HTNL和XML文档的一个API（应用程序编程接口），DOM可以将任何一个HTML或XML文档描绘成一个由多层节点构成的节点树，允许开发人员添加、移除和修改页面的某一部分。 DOM的核心问题DOM会导致一系列的重绘(repaint)、重新排版(reflow)操作。为了确保执行结果的准确性，所有的修改是按顺序同步进行的，大部分浏览器都不会在执行过程中更新DOM。相应的，这些浏览器将对DOM的操作放在一个队列，并在JavaScript脚本执行完毕以后按顺序一次执行完毕。也就是说，在JavaScript执行的过程，直到发生重新排版，用户一直被阻塞。一般的浏览器中（不含IE），repaint的速度远快于reflow，所以避免reflow更重要。reflow:例如某个子元素样式发生改变，直接影响到了其父元素以及往上追溯很多祖先元素（包括兄弟元素），这时候浏览器要重新渲染这个子元素相关联的所有元素的过程。reflow几乎无法避免。repaint:如果只是改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性，将只会引起浏览器的repaint。 解决方案关键：减少DOM操作引起的reflow。 1、使用DoucumentFragment一次性更新DOM12345678//使用容器保存临时变更，最后一次性更新DOMvar fragment=document.createDocumentFragment();for(var i=0;i&lt;items,length;i++)&#123; var item=document.createElement(&quot;li&quot;); item.appendChild(document.createTextNode(&quot;Option&quot;+i); fragment.appendChild(item); &#125;list.appendChild(fragment); 2、操作DOM前，先把DOM节点删除或隐藏，因为隐藏的节点不会发生重排1234567list.style.display=&quot;none&quot;;for(var i=0;i&lt;items,length;i++)&#123; var item=document.createElement(&quot;li&quot;); item.appendChild(document.createTextNode(&quot;Option&quot;+i); list.appendChild(item); &#125;list.style.display=&quot;&quot;; 3、一次性修改样式属性1234//这样做很引起多次重排element.style.backgroundColor=&quot;blue&quot;;element.style.color=&quot;red&quot;;element.style.fontSize=&quot;12em&quot;; 1234567//更好的做法是，把样式放在一个class下.newStyle&#123; background-color:blue; color:red; font-size:12em;&#125;element.className=&quot;newStyle&quot;; 4、使用缓存，缓存临时节点12//不好的做法document.getElementById(&quot;myDiv&quot;).style.left=document.getElementById(&quot;myDiv&quot;).offsetLeft+document.getElementById(&quot;myDiv&quot;).offsetWidth+&quot;px&quot;; 123//更好的做法var myDiv=document.getElementById(&quot;myDiv&quot;);myDiv.style.left=myDiv.offsetLeft+myDiv.offsetWidth+&quot;px&quot;;","categories":[],"tags":[],"keywords":[]},{"title":"跨浏览器事件对象———EventUtil","slug":"跨浏览器事件对象———EventUtil","date":"2017-05-24T02:12:22.000Z","updated":"2017-05-24T07:19:29.935Z","comments":true,"path":"2017/05/24/跨浏览器事件对象———EventUtil/","link":"","permalink":"https://aliceflaviawang.github.io/2017/05/24/跨浏览器事件对象———EventUtil/","excerpt":"","text":"前言EventUtil:在JavaScript中，DOM0级、DOM2级与旧版本IE（8-）为对象添加事件的方法不同，为了以跨浏览器的方式处理时间，需要编写一段“通用代码”，即跨浏览器的事件处理程序，这个方法属于一个名为EventUtil的对象，编写并使用该对象后，可保证处理事件的代码能在大多数浏览器下一致地运行。 EventUtil对象123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106var EventUtil=&#123; addHandler:function(element,type,handler)&#123;//添加事件 if(element.addEventListener)&#123; element.addEventListener(type,handler,false); //使用DOM2级方法添加事件，三个参数分别是：要处理的事件名、作为事件处理的函数和一个布尔值（布尔值表示在捕获阶段(true)还是冒泡阶段(false)调用事件处理程序） &#125; else if(element.attachEvent)&#123; element.attachEvent(&quot;on&quot;+type,handler); //使用IE方法添加事件，两个参数分别为：事件处理程序名称和事件处理程序的函数 &#125; else&#123; element[&quot;on&quot;+type]=handler; //使用DOM0级方法添加事件 &#125; &#125;， removeHandler:function(element,type,handler)&#123; //取消事件 if(element.removeEventListener)&#123; element.removeEventListener(type,handler,false); &#125; else if(element.detachEvent)&#123; element.detachEvent(&quot;on&quot;+type,handler); &#125; else&#123; element[&quot;on&quot;+type]=null; &#125; &#125;, getEvent:function(event)&#123; //使用这个方法跨浏览器取得event对象 return event?event:window.event; //在IE中，使用DOM0级添加事件处理程序时，event对象作为window对象的一个属性存在，而且在IE中，event对象的一些属性/方法跟其他支持DOM的浏览器不同，正是由于这些差异，EventUtil中的getEvent方法应运而生 &#125;, getTarget:function(event)&#123; //返回事件的实际目标 return event.target||event.srcEelment; //在IE中，获取事件的目标对象的方法为event.srcElement，而其他兼容DOM的浏览器中，获取事件目标对象的方法却为event.target &#125;, preventDefault:function(event)&#123; //阻止事件的默认行为 if(event.preventDefault)&#123; //在其他兼容DOM的浏览器中，阻止特定事件的默认行为只需要使用event对象自带的preventDefault()方法 event.preventDefault(); &#125;else&#123; //而IE中，则需要赋予event.returnValue的值为false才能阻止特定事件的默认行为 event.returnValue=false; &#125; &#125; stopPropagation:function(event)&#123; if(event.stopPropagation)&#123; event.stopPropagation(); //DOMO级或DOM2级取消事件进一步冒泡或者捕获 &#125;else&#123; event.cancelBubble=true; //IE中取消时间冒泡 &#125; &#125;, getRelatedTarget:function(event)&#123; //获取mouseover和mouseout相关元素//mouseover与mouseout有“主目标”和“相关元素”的概念，因为在发生mouseover或mouseout事件时，还会涉及到其他元素，这两个事件都会涉及把鼠标指针从一个元素移到另一个元素。具体来说，对mouseover事件，事件的主目标是获得光标的元素，而相关元素是那个失去光标的元素，对mouseout事件而言，事件的主目标是失去光标的元素，而相关元素是那个获得光标的元素。 if(event.relatedTarget)&#123; return event.relatedTarget; &#125; else if(event.toElement)&#123; //mouseout触发时，IE的toElement保存的相关元素属性 return event.toElement; &#125; else if(event.formElement)&#123; //mouseover触发时，IE的formElement保存相关元素属性 return event.formElement; &#125; else&#123; return null; &#125; &#125;, getButton:function(event)&#123; //获取mousedown或mouseup按下或释放的按钮是鼠标的哪一个 if(document.implementation.hasFeature(&quot;MouseEvents&quot;,&quot;2.0&quot;))&#123; return event.button; &#125;else&#123; switch(event.button)&#123;//将IE模型下的button属性映射为DOM模型下的button属性 case 0: case 1; case 3; case 5; case 7; return 0; //按下的是鼠标主按钮（一般是左键） case 2: case 6: return 2; //按下的是中间的鼠标按钮 case 4: return 1; //鼠标次按钮（一般是右键） &#125; &#125; &#125;, getWheelDelta:function(event)&#123; //获取表示鼠标滚轮滚动方向的数值//解决的是与Firefox的差异 if(event.wheelDelta)&#123; return event.wheelDelta; &#125; else&#123; return -event.detail*40; &#125; &#125;, getCharCode:function(event)&#123; //跨浏览器取得相同的字符编码，需在keypress事件中使用//在所有浏览器中，按下能够插入或删除的字符的按键都会触发keypress事件，但IE8-及Opera取得字符编码的方式与其他浏览器有差异 if(typeof event.charCode==&quot;number&quot;)&#123; return event.charCode; &#125;else&#123; return event.keyCode; &#125; &#125;&#125; 举例用法1234567//添加了EventUtil之后，获取了event对象、取消了事件进一步捕获或者冒泡、指定了事件的处理程序而无须担心浏览器兼容问题var btn=document.getElementById(&quot;#btn&quot;);var handler=function(event)&#123; event=EventUtil.getEvent(event); EventUtil.stopPropagation(event); &#125;Event.addHandler(btn,&quot;click&quot;,handler);","categories":[],"tags":[],"keywords":[]},{"title":"为什么js没有函数签名","slug":"为什么js没有函数签名","date":"2017-05-01T02:30:42.000Z","updated":"2017-05-02T01:18:01.450Z","comments":true,"path":"2017/05/01/为什么js没有函数签名/","link":"","permalink":"https://aliceflaviawang.github.io/2017/05/01/为什么js没有函数签名/","excerpt":"","text":"什么是函数签名MDN上关于函数签名的说明：A function signature(or type signature, or method signature) defines input and putput of functions or methods.A signature can include: parameters and their types a return value and type exceptions that might be thrown or passed back information about the availability of the method in an object-oriented program(such as the keywords public, static, or prototype).翻译过来就是函数签名定义了函数或方法的输入输出，签名包括参数个数和类型、返回值和类型、抛出或者往后传的异常、面向对象程序方法可行性的信息。为什么js没有函数签名在其他语言中，命名参数必须要求事先创建函数签名，将来调用也必须与该签名一致；而js的参数是由包含0个或多个值的数组来表示的，命名参数只是提供便利，但不是必须的，解析器也不会验证命名参数，所以js没有签名。举个例子：1234function sayHi()&#123; alert(&quot;Hi &quot;+arguments[0]+&quot;, &quot;+arguments[1]);&#125;sayHi(&quot;Alice&quot;,&quot;how are you?&quot;); 对这个例子，命名参数为空，但是照样可以按照两个参数的格式去调用该方法，是因为对ECMAScript，无论传递给函数的参数是什么，函数接收到的始终都是数组，通过arguments对象访问的参数数组。所谓的参数类型、参数个数、参数位置、出入参数，js都不关心，它所有的值都被放倒arguments中了，需要返回值的话直接return，不用声明。","categories":[],"tags":[],"keywords":[]},{"title":"slice(), substring(), substr()总结","slug":"slice-substring-substr-总结","date":"2017-04-25T13:47:05.000Z","updated":"2017-04-25T13:56:07.132Z","comments":true,"path":"2017/04/25/slice-substring-substr-总结/","link":"","permalink":"https://aliceflaviawang.github.io/2017/04/25/slice-substring-substr-总结/","excerpt":"","text":"slice(), substring(), substr()都是用来获取子字符串，，且不会修改字符串本身的值。区别：1、参数不同slice: slice(start, end) //start表示子字符串开始的位置，end是子字符串最后一个字符后面的位置substring: substring(start, end) //同slicesubstr: substr(start, num) //num表示返回字符的个数2、参数是负值的情况不同slice: 将负值与字符串长度相加substring： 将所有的负值转换成0，且会将较小的数作为开始位置，较大的数作为结束位置substr: 将负的第一个参数加上字符串长度，负数第二个参数转换为0```var s=”hello world”;s.slice(3,-4); //“lo w”s.substring(3,-4); //“hel”s.substr(3,-4); //“”（空字符串）","categories":[],"tags":[],"keywords":[]},{"title":"append和prepend","slug":"append和prepend","date":"2017-04-24T14:09:07.000Z","updated":"2017-04-24T14:17:54.922Z","comments":true,"path":"2017/04/24/append和prepend/","link":"","permalink":"https://aliceflaviawang.github.io/2017/04/24/append和prepend/","excerpt":"","text":"append()和prepend()方法都是jQuery文档操作方法，append()在被选元素的结尾插入指定内容，而prepend()则是在被选元素的前面插入制定内容。比如：1234&lt;div id=&quot;console&quot;&gt; &lt;h2&gt;Console Log&lt;/h2&gt; &lt;ul&gt;&lt;/ul&gt;&lt;/div&gt; 添加元素到ul中123456var $consoleLog = $(&quot;#console ul&quot;); var show = function(msg) &#123; var $msg = $(&quot;&lt;li&gt;&lt;/li&gt;&quot;); $msg.text(msg); $consoleLog.prepend($msg); &#125;; 此处采用prepend是从下往上的添加元素，最新添加的元素显示在最上面.注：$(&quot;&lt;li&gt;&lt;/li&gt;&quot;)是创建一个li元素并返回jQuery对象，不是选中它，因为这样创建的元素还不在html结构中，只是在内存中存在。","categories":[],"tags":[],"keywords":[]},{"title":"transform-origin,rotate实现绕中心旋转","slug":"transform-origin-rotate实现绕中心旋转","date":"2017-04-24T13:40:49.000Z","updated":"2017-04-24T14:00:43.434Z","comments":true,"path":"2017/04/24/transform-origin-rotate实现绕中心旋转/","link":"","permalink":"https://aliceflaviawang.github.io/2017/04/24/transform-origin-rotate实现绕中心旋转/","excerpt":"","text":"一般实现环形旋转可以通过animation动画的方式举个例子：1&lt;img src=&quot;images/min-iconfont-rocket-active.png&quot;&gt; 通过animation，对应的css代码为：1234567891011121314@keyframes spin&#123; to&#123; transform: rotate(1turn); &#125;&#125;img&#123; position: absolute; top:50px; left:50px; width:50px; height:50px; animation:spin 10s infinite linear; transform-origin:150px 150px;&#125; 也可以通过transform-origin+rotate的js实现，transform-origin对应旋转中心的位置，rotate可以设置旋转的角度。设置一个图片进行旋转，对于的css代码12345678img&#123; position: absolute; top:50px; left:50px; width:50px; height:50px; transform-origin: 150px 150px; //设置旋转的中心位置 &#125; 对应的js123456789var deg=0;var timer=setInterval(function()&#123; deg+=10; rotate(deg);&#125;,20)function rotate(deg)&#123; var my=&quot;rotate(&quot;+deg+&quot;deg)&quot; $(&quot;img&quot;).css(&quot;transform&quot;,my)&#125; 对于transform-orgin其默认的位置是元素的中心位置，可以通过设置重新确定中心。注：想了解更多transform实现环形路径平移动画，可以参看 http://www.open-open.com/lib/view/open1478661385568.html.","categories":[],"tags":[],"keywords":[]},{"title":"apply()和call()用法","slug":"apply-和call-用法","date":"2017-04-24T03:10:47.000Z","updated":"2017-04-24T06:38:18.222Z","comments":true,"path":"2017/04/24/apply-和call-用法/","link":"","permalink":"https://aliceflaviawang.github.io/2017/04/24/apply-和call-用法/","excerpt":"","text":"每个函数都有两个非继承的方法：apply（）和call()。这两个方法都是在特定作用域中调用函数，实际上等于设置函数体内this对象的值。 方法定义1、apply()方法——apply([thisObj[,argArray]])apply()接收两个参数：一个是运行函数的作用域，另一个是参数数组。其中第二个参数可以是Array的实例，也可以是arguments对象。 2、call()方法——call([thisObj[,arg1[, arg2[, [,.argN]]]]])与apply作用相同，区别在于接收参数方式不同。第一个参数this的值没有变化，其余参数是以列举的方式直接传递给函数。 作用1、扩充函数赖以运行的作用域12345678910window.color=&quot;red&quot;;var o=&#123;color:&quot;blue&quot;&#125;;function sayColor()&#123;alert(this.color)&#125;sayColor(); //redsayColor.call(this); //redsayColor.call(window); //redsayColor.call(o); //blue sayColor.call(o)与o.sayColor()效果一样，但是使用call()(或apply())是的对象不需要与方法有任何耦合关系。 2、实现继承1234567891011function Animal(name)&#123;this.name=name;this.showName=function()&#123;alert(this.name);&#125;&#125;function Cat(name)&#123;Animal.call(this,name);&#125;var cat=new Cat(&apos;Black Cat&apos;);cat.showName(); //Black Cat 3、实现多重继承12345678910111213141516171819202122var s1=function(name)&#123;this.name=name;&#125;var s2=function(sex)&#123;this.sex=sex;&#125;var s3=function(age)&#123;this.age=age;&#125;var Student=function(name,sex,age,score)&#123;s1.call(this,name);s2.call(this,sex);s3.call(this,age);this.score=score;&#125;Student.prototype.construction=Student;var s=new Student(&apos;jack&apos;,&apos;male&apos;,&apos;32&apos;,&apos;100&apos;);console.log(s.name); //jackconsole.log(s.sex); //maleconsole.log(s.age); //32console.log(s.score); //100","categories":[],"tags":[],"keywords":[]},{"title":"理解arguments","slug":"理解arguments","date":"2017-04-24T02:02:40.000Z","updated":"2017-04-24T02:38:43.554Z","comments":true,"path":"2017/04/24/理解arguments/","link":"","permalink":"https://aliceflaviawang.github.io/2017/04/24/理解arguments/","excerpt":"","text":"ECMAScript中的参数是用一个数组表示的。无论传递给函数的参数是什么（有或者没有），函数接收到的始终都是这个数组。在函数体内通过arguments对象来访问这个参数数组，从而获取传递给函数的每个参数。例如：1234function sayHi(name,message)&#123;return;alert(&quot;Hello &quot;+name+&quot;,&quot;+message);&#125; 可以用arguments重写不显示的使用命名参数：1234function sayHi()&#123;return;alert(&quot;Hello &quot;+arguments[0]+&quot;,&quot;+arguments[1]);&#125; arguments特性1、arguments对象的长度是由传入的参数的长度决定的，不是由定义函数时的命名参数的个数决定的123456function howManyArgs(&#123;alert(arguments.length);&#125;howManyArgs(&quot;string&quot;,45); //2howManyArgs(); //0howManyArgs(12) //1 2、arguments的值永远与对应命名参数的值保持同步1234function doAdd(num1,num2)&#123;arguments[1]=10;alert(arguments[0]+num2);&#125; 每次执行doAdd函数都会重写第二个参数（将其修改为10），因为arguments[1]的对象的值会自动反映到对应的命名参数，所以修改了arguments[1]也就修改了num2，他们的值会同步（但内存空间是独立的）。如果只传入了一个参数，arguments[1]的值不会反映到命名参数中（因为特性1）。 3、arguments对象有个callee属性callee属性是一个指针，指向拥有这个arguments对象的函数。1234567fucntion factorial(num)&#123;if(num&lt;=1)&#123;return 1;&#125;else&#123;return num*factorial(num-1);&#125;&#125; 上面的函数的执行与函数名紧紧耦合在一起，为了消除这种紧密耦合现象，可以用arguments.callee。1234567function factorial(num)&#123;if(num&lt;=1)&#123;return 1;&#125;else&#123;return num*arguments.callee(num-1);&#125;&#125; 这样，无论引用函数是时使用的什么名字，都可以保证正常递归调用。看一个例子：12345678910111213function factorial(num)&#123;if(num&lt;=1)&#123;return 1;&#125;else&#123;return num*arguments.callee(num-1);&#125;&#125;var trueFactoral=factorial;factorial=function()&#123;return 0;&#125;alert(trueFactoral(5)); //120alert(factorial(5)); //0 而使用函数名，则：12345678910111213function factorial(num)&#123;if(num&lt;=1)&#123;return 1;&#125;else&#123;return num*factorial(num-1);&#125;&#125;var trueFactoral=factorial;factorial=function()&#123;return 0;&#125;alert(trueFactoral(5)); //0alert(factorial(5)); //0 后记——函数对象的caller属性当一个函数调用另一个函数时，被调用的函数会自动生成一个caller属性，指向调用它的函数对象。若该函数未被调用或没有被其他函数调用，caller为null。而arguments.callee是函数被调用时，arguments.callee对象指向自身，是对自己的引用。注：arguments在函数调用时才有效，因为arguments.callee在函数未调用时是不存在的（即null.callee)。","categories":[],"tags":[],"keywords":[]},{"title":"translate(-50%,-50%)的作用","slug":"translate-50-50-的作用","date":"2017-04-22T14:01:12.000Z","updated":"2017-04-22T14:01:34.391Z","comments":true,"path":"2017/04/22/translate-50-50-的作用/","link":"","permalink":"https://aliceflaviawang.github.io/2017/04/22/translate-50-50-的作用/","excerpt":"","text":"当使用top:50%;left:50%的时候，是以左上角为原点，故元素不处于中心位置。translate(-50%,-50%)的作用是往上（x轴），左（y轴）移动自身长宽的50%，使得元素处于中心位置。例如：1234&lt;div id=&quot;outer&quot;&gt; &lt;div id=&quot;inner&quot;&gt; &lt;/div&gt;&lt;/div&gt; 如果不加transform属性1234567891011121314#outer&#123; position: relative; width: 500px; height: 500px; border: 1px solid black;&#125;#inner&#123; position: absolute; top: 50%; left: 50%; width: 100px; height: 100px; background-color: red;&#125; inner框的左上角处于中心位置，如果希望其中心居于中心位置，将应该向上和向左移动一半的边长长度。加上transform属性，就可以实现这个效果：123456789101112#inner &#123; position: absolute; top: 50%; left: 50%; width: 100px; height: 100px; background-color: red; -ms-transform: translate(-50%,-50%); -moz-transform: translate(-50%,-50%); -o-transform: translate(-50%,-50%); transform: translate(-50%,-50%); &#125;","categories":[],"tags":[],"keywords":[]},{"title":"阿里暑期前端面试总结","slug":"阿里暑期前端面试总结","date":"2017-04-19T10:40:53.000Z","updated":"2017-04-19T10:40:53.645Z","comments":true,"path":"2017/04/19/阿里暑期前端面试总结/","link":"","permalink":"https://aliceflaviawang.github.io/2017/04/19/阿里暑期前端面试总结/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"腾讯暑期实习面试前端面试总结","slug":"腾讯暑期实习面试前端面试总结","date":"2017-04-19T07:36:12.000Z","updated":"2017-04-19T08:25:23.576Z","comments":true,"path":"2017/04/19/腾讯暑期实习面试前端面试总结/","link":"","permalink":"https://aliceflaviawang.github.io/2017/04/19/腾讯暑期实习面试前端面试总结/","excerpt":"","text":"4月13号参加的腾讯面试，不得不说面试机制还是比较完善，通知的10点面试，9点20到达酒店之后，差不多10点就通知了面试地点去候场。因为房间门是开的，所以听到了前一个人的部分面试问题：1、http状态码有哪些，代表的什么意思2、用过缓存没有，local storage和session storage有什么区别3、你说你学过node js，讲一下于是我在门外默默的准备了一下，进去之后面试官看了我的简历上写本科是信息安全，于是问我公钥加密和私钥加密有什么区别。。。我大概记得，但是说反了，然后开始问我一串安全相关的问题，安全掌握的不怎么好，面试官大概没有很多兴趣，就简单问了下css和一个逻辑题就完了：1、Web安全2、url是怎么加密的3、css的优先级4、逻辑题：给一个不规则的5L和6L的桶，装一个3升的水然后很显然就没有然后了，通过此次面试，觉得自己还是要多注意Web安全方面的知识，另外简历上处处都有可能问到，主要看面试官比较擅长哪方面，所以只要写上去都要有所准备。","categories":[],"tags":[],"keywords":[]},{"title":"easyui两个datagrid的问题","slug":"easyui两个datagrid的问题","date":"2017-04-11T11:11:39.000Z","updated":"2017-04-11T11:21:49.478Z","comments":true,"path":"2017/04/11/easyui两个datagrid的问题/","link":"","permalink":"https://aliceflaviawang.github.io/2017/04/11/easyui两个datagrid的问题/","excerpt":"","text":"问题easyui框架下，当一个页面出现两个datagrid，或者说出现两个table的时候，datagrid的某些属性会失效，比如说pagination分页会失效. 解决办法使用两个div将两个datagrid分开，但是使用两个div后，页面不能填充整个屏幕，所以解决两个datagrid分页失效的问题转化为了如何让div填充整个屏幕的问题。解决方法如下：123456789&lt;style&gt;html, body&#123;margin:0;padding:0;&#125;div&#123;width:100%;&#125;&lt;/style&gt;","categories":[],"tags":[],"keywords":[]},{"title":"easyui表格查询","slug":"easyui表格查询","date":"2017-04-10T13:09:22.000Z","updated":"2017-04-10T13:24:40.892Z","comments":true,"path":"2017/04/10/easyui表格查询/","link":"","permalink":"https://aliceflaviawang.github.io/2017/04/10/easyui表格查询/","excerpt":"","text":"easyui表格查询非常简单，比如说对于一个datagrid如下1234567891011121314151617181920212223242526272829303132333435363738&lt;div id=&quot;toolbar1&quot;&gt; &lt;div style=&quot;padding:3px&quot;&gt; &lt;span&gt;部门 ID:&lt;/span&gt; &lt;input id=&quot;deptId&quot; style=&quot;line-height:26px;border:1px solid #ccc&quot;&gt; --&gt; &lt;span&gt;部门名称:&lt;/span&gt; &lt;input id=&apos;dd&apos; &gt; &lt;span&gt;岗位类型:&lt;/span&gt; &lt;input id=&apos;dd3&apos; &gt; &lt;span&gt;设岗科室名称:&lt;/span&gt; &lt;input id=&apos;dd2&apos; style=&quot;line-height:22px;border:1px solid #ccc;border-radius:5px;&quot;&gt; &lt;span&gt;指导老师:&lt;/span&gt; &lt;input id=&apos;dd1&apos; style=&quot;line-height:22px;border:1px solid #ccc;border-radius:5px;&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;easyui-linkbutton&quot; plain=&quot;true&quot; iconCls=&quot;icon-search&quot; onclick=&quot;doFind()&quot;&gt;查询&lt;/a&gt; &lt;/div&gt; &lt;div&gt;&lt;table id=&quot;tt1&quot; title=&quot;岗位申请&quot; class=&quot;easyui-datagrid&quot; style=&quot;width:100%;height:auto;&quot; singleSelect=&quot;true&quot; data-options=&quot;fit:true&quot; rownumbers=&quot;true&quot; idField=&apos;deptId&apos; method=&apos;post&apos; toolbar=&apos;#toolbar1&apos;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th rowspan=&quot;2&quot; field=&quot;deptId&quot; width=&quot;5%&quot; align=&quot;center&quot;&gt;学院/部门ID&lt;/th&gt; &lt;th rowspan=&quot;2&quot; field=&quot;deptName&quot; width=&quot;6%&quot; align=&quot;center&quot;&gt;学院/部门名称&lt;/th&gt; &lt;th rowspan=&quot;2&quot; field=&quot;jobTime&quot; width=&quot;6%&quot; align=&quot;center&quot;&gt;岗位时间&lt;/th&gt; &lt;th rowspan=&quot;2&quot; field=&quot;teacherName&quot; width=&quot;6%&quot; align=&quot;center&quot;&gt;指导老师&lt;/th&gt; &lt;th rowspan=&quot;2&quot; field=&quot;telephone&quot; width=&quot;7%&quot; align=&quot;center&quot;&gt;指导老师电话&lt;/th&gt; &lt;th rowspan=&quot;2&quot; field=&quot;guideTrain&quot; width=&quot;10%&quot; align=&quot;center&quot;&gt;指导与培训体系&lt;/th&gt; &lt;th colspan=&quot;6&quot; align=&quot;center&quot; &gt;岗位要求&lt;/th&gt; &lt;th rowspan=&quot;2&quot; field=&quot;statusCodeName&quot; align=&quot;center&quot; width=&quot;5%&quot;&gt;审核状态&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th field=&quot;officeName&quot; align=&quot;center&quot; width=&quot;9%&quot;&gt;设岗科室名称&lt;/th&gt; &lt;th field=&quot;typeName&quot; align=&quot;center&quot; width=&quot;8%&quot;&gt;岗位类型&lt;/th&gt; &lt;th field=&quot;jobNum&quot; align=&quot;center&quot; width=&quot;8%&quot;&gt;设岗科室岗位数&lt;/th&gt; &lt;th field=&quot;jobWork&quot; align=&quot;center&quot; width=&quot;8%&quot;&gt;科室工作量&lt;/th&gt; &lt;th field=&quot;responsibility&quot; align=&quot;center&quot; width=&quot;10%&quot;&gt;科室工作职责&lt;/th&gt; &lt;th field=&quot;ability&quot; align=&quot;center&quot; width=&quot;12%&quot;&gt;科室岗位培养的综合素质&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;/table&gt; 查询部分的js代码12345678910111213function doFind()&#123;//获取查询条件 var val = $(&apos;#dd&apos;).combobox(&apos;getValue&apos;); var teacherName = $(&apos;#dd1&apos;).val(); var officeName = $(&apos;#dd2&apos;).val(); var type = $(&apos;#dd3&apos;).combobox(&apos;getValue&apos;);//根据查询条件在表格tt中load出来$(&quot;#tt1&quot;).datagrid(&apos;load&apos;,&#123;deptId:val,teacherName:teacherName,officeName:officeName,type:type&#125;) 但是发现这样有问题，如果某项没填，比如teacherName为空，那么将会在表格中查询teacherName为空的项，从而查不到结果。因此采取先判断查询项是否为空，才能得出正确结果。123456789101112131415161718192021222324252627function doFind()&#123; var val = $(&apos;#dd&apos;).combobox(&apos;getValues&apos;);//允许多选的情况，首先要在id为dd的combobox设置multipl为true if (val[0] == &apos;&apos;) &#123; val = val.slice(1) &#125; var teacherName = $(&apos;#dd1&apos;).val(); var officeName = $(&apos;#dd2&apos;).val(); var type = $(&apos;#dd3&apos;).combobox(&apos;getValue&apos;) var deptIds = val.join(&apos;,&apos;);//将每项用,分开 var query = &#123;&#125; //判断查询条件是否为空，将查询条件保存到对象中 if(teacherName)&#123; query.teacherName=teacherName; &#125; if(officeName)&#123; query.officeName=officeName; &#125; if(type)&#123; query.type=type; &#125; if(deptIds)&#123; query.deptId=deptIds; &#125; $(&apos;#tt1&apos;).datagrid(&apos;load&apos;, query); &#125;","categories":[],"tags":[],"keywords":[]},{"title":"easyui的dialog中插入下拉框","slug":"easyui的dialog中插入下拉框","date":"2017-04-10T12:53:55.000Z","updated":"2017-04-10T13:06:30.491Z","comments":true,"path":"2017/04/10/easyui的dialog中插入下拉框/","link":"","permalink":"https://aliceflaviawang.github.io/2017/04/10/easyui的dialog中插入下拉框/","excerpt":"","text":"easyui是一个集成了各种用户界面的插件的框架，特别使用各种表格的开发，能大大节省时间。在项目中遇到的问题时，下dialog中无法使用combobox生成下拉框，于是只能通过打开dialog时插入一个下拉框。1234567891011121314151617181920212223$(&apos;#fm_deptId&apos;).append(&apos;&lt;option&gt;bitem6&lt;/option&gt;&apos;); var depts = []; var query = &#123; rows: 200, page: 1 &#125; var newHtml = &apos;&apos;; $.ajax(&#123; type: &apos;POST&apos;, async: false, url: url_queryDept,//向接口请求下拉框数据 contentType: &quot;application/json; charset=utf-8&quot;, data: JSON.stringify(query), dataType: &apos;json&apos;, success: function(data) &#123; $.each(data.result, function(i, val) &#123; var temp = val.deptId + val.deptName;数据由一个id和name组成 var option = &apos;&lt;option value=&apos; + val.deptId + &apos;&gt;&apos; + temp + &apos;&lt;/option&gt;&apos;; newHtml = newHtml + option; &#125;) $(&apos;#fm_deptId&apos;)[0].innerHTML = newHtml; &#125;&#125;) 注：如果想要选中下拉框的某一个选项作为下拉框的默认值1$(&apos;#fm_deptId option[value=&apos;+ current_deptId+&apos;] &apos;).attr(&quot;selected&quot;,true);","categories":[],"tags":[],"keywords":[]},{"title":"win10永久激活方方法","slug":"win10永久激活方方法","date":"2017-04-10T12:44:58.000Z","updated":"2017-04-10T12:48:18.180Z","comments":true,"path":"2017/04/10/win10永久激活方方法/","link":"","permalink":"https://aliceflaviawang.github.io/2017/04/10/win10永久激活方方法/","excerpt":"","text":"今天提示win10许可证要过期了，于是尝试了各种工具，Microsoft Toolkit、HEU_KMS_Activator、KMS10_Crack2都不行，最后在网上找到了这个方法，一分钟不到就搞定了，分享一下网址https://jingyan.baidu.com/article/73c3ce282431dbe50343d9a9.html。","categories":[],"tags":[],"keywords":[]},{"title":"JS与jQuery显示和隐藏div","slug":"JS与jQuery显示和隐藏div","date":"2017-04-10T12:25:07.000Z","updated":"2017-04-10T12:39:10.062Z","comments":true,"path":"2017/04/10/JS与jQuery显示和隐藏div/","link":"","permalink":"https://aliceflaviawang.github.io/2017/04/10/JS与jQuery显示和隐藏div/","excerpt":"","text":"关于div隐藏很显示的问题，经常遇到，JS和jQuery有不同的处理方式。1&lt;div id=&quot;div&quot;&gt;&lt;/div&gt; JS方式123document.getElementById(&quot;div&quot;).style.display=&quot;block&quot;;document.getElementById(&quot;div&quot;).style.display=&quot;none&quot;;//不占用空间document.getElementById(&quot;div&quot;).style.display=&quot;hidden&quot;;//仍然占用空间 jQuery方式123456//通过css方法设置属性$(&quot;#div&quot;).css(&quot;diaplay&quot;,&quot;block&quot;);//给元素换class，提前将换的class样式定义好display属性$(&quot;#div&quot;).attr(&quot;class&quot;,&quot;blockclass&quot;);//通过attr方法$(&quot;#div&quot;).attr(&quot;display&quot;,&quot;block&quot;); 注：jQuery的css方法和attr方法的区别,css顾名思义就是标签自带的css属性，atrr只能取自己定义的属性，例如，如果div中没有diaplay这个属性的话，不能用过attr给其赋值，但是可以用css方法。","categories":[],"tags":[],"keywords":[]},{"title":"JS与jQuery清空输入框","slug":"JS与jQuery清空输入框","date":"2017-04-10T12:12:09.000Z","updated":"2017-04-10T12:16:41.820Z","comments":true,"path":"2017/04/10/JS与jQuery清空输入框/","link":"","permalink":"https://aliceflaviawang.github.io/2017/04/10/JS与jQuery清空输入框/","excerpt":"","text":"input输入框输入之后，再次输入的时候需要清空输入框。对于input输入框，JS与jQuery清空方式不同。1&lt;input id=&quot;input&quot; type=&quot;text&quot; name=&quot;input&quot;&gt; JS方式1document.getElementById(&quot;input&quot;).value=&quot;&quot;; jQuery方式1$(&quot;#input&quot;).val(&quot;&quot;);","categories":[],"tags":[],"keywords":[]},{"title":"java二维排序数组查找元素","slug":"java二维排序数组查找元素","date":"2017-04-09T13:09:30.000Z","updated":"2017-04-09T13:14:14.944Z","comments":true,"path":"2017/04/09/java二维排序数组查找元素/","link":"","permalink":"https://aliceflaviawang.github.io/2017/04/09/java二维排序数组查找元素/","excerpt":"","text":"题目描述在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 简单做法看到这个题目，如果不考虑数组元素的排序，只考虑能不能找到的话，非常简单。12345678910public boolean Find(int target, int [][] array) &#123; for(int i=0;i&lt;array.length;i++)&#123; for(int j=0;j&lt;array[0].length;j++)&#123; if(array[i][j]==target)&#123; return true; &#125; &#125; &#125; return false; &#125; 运行效果 题目的本质因为数组是排序的，所以考虑用二分查找，而查找不能盲目的查找，比如从第一个元素开始查找，如果比目标元素小，是往下找还是往右找呢，同里也不能从最后一个元素开始查找，可以从第一行最右边开始查找，如果比目标元素大就往左查找，反之往下查找，同理也可以从第一列最下边开始查找。举例从第一行最右边开始查找，代码如下：12345678910111213141516public boolean Find(int target, int [][] array) &#123; int row=0; int col=array[0].length-1; while(row&lt;array.length&amp;&amp;col&gt;=0)&#123; if(array[row][col]==target) &#123; return true; &#125; else if(array[row][col]&lt;target)&#123; row++; &#125; else&#123; col--; &#125; &#125; return false; &#125; 运行效果 完整代码1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.company;import java.util.Scanner;public class Solution &#123; public boolean Find(int target, int [][] array) &#123; int row=0; int col=array[0].length-1; while(row&lt;array.length&amp;&amp;col&gt;=0)&#123; if(array[row][col]==target) &#123; return true; &#125; else if(array[row][col]&lt;target)&#123; row++; &#125; else&#123; col--; &#125; &#125; return false; &#125; public static void main(String srgs[])&#123; Scanner s=new Scanner(System.in); System.out.println(&quot;请输入数组的行和列&quot;); int x=s.nextInt(); int y=s.nextInt(); int [][]arr=new int[x][y]; System.out.println(&quot;请输入数组元素&quot;); for(int i=0;i&lt;x;i++)&#123; for(int j=0;j&lt;y;j++)&#123; arr[i][j]=s.nextInt(); &#125; &#125; System.out.println(&quot;请输入你想查找的数：&quot;); int t=s.nextInt(); Solution a=new Solution(); if(a.Find(t,arr))&#123; System.out.println(&quot;数组&quot;+arr+&quot;中有数&quot;+t); &#125;else&#123; System.out.println(&quot;数组&quot;+arr+&quot;中没有数&quot;+t); &#125; &#125;&#125;","categories":[],"tags":[],"keywords":[]},{"title":"基于easyui项目学习的总结（一）","slug":"基于easyui项目学习的总结（一）","date":"2017-04-09T12:59:26.000Z","updated":"2017-04-09T13:02:35.130Z","comments":true,"path":"2017/04/09/基于easyui项目学习的总结（一）/","link":"","permalink":"https://aliceflaviawang.github.io/2017/04/09/基于easyui项目学习的总结（一）/","excerpt":"","text":"最近在做的项目，是基于easyui框架，项目进度非常紧张，并没有太多时间来总结，就用零碎时间一点点总结吧，主要是从网上及大神同学身上学到了很多。 easyui placeholder解决方案因为easyui经常用到table、textbox，因此会遇到需要用placeholder来提示输入内容的时候，但是easyui不支持h5的placeholder,因此，为了实现这个效果，在网上找到了解决方案。1、给input标签添加placeholder1&lt;input id=&quot;fm_jobTime&quot;&quot; name=&quot;jobTime&quot; class=&quot;easyui-textbox&quot; required=&quot;true&quot; label=&quot;岗位时间:&quot; style=&quot;width:100%&quot; placeholder=&quot;xxxx年x月-xxxx年x月&quot;&gt; 2、页面加载完毕的时候，将easyui生成的input标签的placeholder重置12345678910111213141516$(function()&#123;window.onload = inputPlaceholder();&#125;);/**easyui number placeholder*/function numberinputPlaceholder()&#123;$(&quot;.easyui-textbox&quot;).each(function(i)&#123;var span = $(this).siblings(&quot;span&quot;)[0];var targetInput = $(span).find(&quot;input:first&quot;);if(targetInput)&#123;$(targetInput).attr(&quot;placeholder&quot;, $(this).attr(&quot;placeholder&quot;));&#125;&#125;);&#125;","categories":[],"tags":[],"keywords":[]},{"title":"git bash命令上传下载代代码","slug":"git bash命令上传下载代代码","date":"2017-04-08T12:37:28.000Z","updated":"2017-04-08T12:38:13.134Z","comments":true,"path":"2017/04/08/git bash命令上传下载代代码/","link":"","permalink":"https://aliceflaviawang.github.io/2017/04/08/git bash命令上传下载代代码/","excerpt":"","text":"git bash是window下的命令行工具，在官网上下载git for windows安装即可。如何通过git bash将代码传到git上和下载到本地的呢remote 上传到git1、安装完成后，在命令行输入下面的代码进行配置12$ git config --global user.name &quot;your real name&quot;$ git config --global user.email &quot;your eamil address&quot; 注：”your real name“是你的真实姓名，”your eamil address”是你的注册github的邮箱2、在主用户目录下，输入下面的代码1$ ssh-keygen -t rsa -C &quot;your eamil address 然后在自己电脑的C盘下找到.ssh文件夹，用记事本打开里面的id_rsa.pub,复制里面的内容。登陆Github，在账户设置里找到SSH keys页面，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容。3、利用”cd”命令将路径切换到你要上传的代码所在的文件夹下面（或者打开你要上传的代码的文件夹，右键git bash here）,输入一下代码：123$git init //把目录变成git可以管理的仓库$git add . //add后面加&quot;.&quot;表示上传所以的代码，如果想上传指定的，只需要把&quot;.&quot;改成文件名即可$git commit -m &quot;你对文件的描述&quot; //提交你对文件的描述 4、在本地仓库目录下输入下面命令将本地仓库和远程仓库关联（如果已经上传过代码了，可以直接跳到第6步）1$git remote add orgin git@github.com:yonghuming/kuming.git origin可是换成你想要的任何名字，但是要记住这个源名字（与第6步的origin对应，我每次都是新起一个名字因为经常提示origin已经存在了）5、输入如下代码，将自己的文件上传1$git push -u origin master 其实github上每次创建一个新的仓库的时候，都有命令提示 从git上下载$git clone git@github.com:yonghuming/kuming.git 更新$git pull origin master 经常遇到的问题error:src refspec master does not match any原因：本地版本库为空，空目录不能提交","categories":[],"tags":[],"keywords":[]},{"title":"Github Pages+Hexo搭建教程","slug":"Github-Pages-Hexo搭建教程","date":"2017-04-04T13:44:17.000Z","updated":"2017-04-07T03:11:41.888Z","comments":true,"path":"2017/04/04/Github-Pages-Hexo搭建教程/","link":"","permalink":"https://aliceflaviawang.github.io/2017/04/04/Github-Pages-Hexo搭建教程/","excerpt":"","text":"前言越来越感觉世界真是太大了，每天学习很多东西，希望能够记录下来自己学习的点点滴滴，也能分享给更多的人，因此搭建了这个博客。关于为什么选择github pages而不是wordpress，因为github pages有300M免费空间，资料自己管理，保存可靠，而且现在的项目开发，团队协作都需要用到github，通过搭建博客也更好的学习了如何使用github。 github安装在官网https://git-for-windows.github.io/上下载git，安装比较简单。访问http://www.github.com/，注册username和邮箱，注册过程也比较简单。 使用GitHub Pages建立博客github建立仓库登陆系统后，在github首页，点击页面右下角New Repository填写项目信息：project name:aliceflaviawang.github.io注：GitHub Pages的Repository名字是特定的，比如我的Github账号是aliceflaviawang,那么我的GitHub Pages Repository名字就是aliceflaviawang.github.io。点击Create Reposity完成创建。进入创建的仓库，打开Settings选择一个主题选择完毕，回到仓库页面，发现多了两个文件，_config.yml是配置文件。此时打开aliceflaviawang.github.io，可以看到index.md显示的内容。 安装node.js参考教程http://www.runoob.com/nodejs/nodejs-install-setup.html，非常简单。 用Hexo克隆主题Hexo介绍Hexo是一个简单、快速、强大的博客发布工具，支持Markdown格式 安装Hexo打开git bash或者cmd,进入node文件夹，安装hexo注：-g是全局安装的意思 部署Hexo在我的电脑中建立一个名叫Hexo的文件夹，然后在此文件夹中右键打开Git Bash.Hexo会自动在目标文件夹建立网站所需要的所有文件。 复制主题建立Hexo之后就可以复制主题了，网上有很多好看的主题可以自己选择。此处选择的是wuchong的主题。 启用主题修改Hexo目录下的_config.yml,将theme属性设置为jacman。 更新主题 本地查看调试 hexo g是生成，hexo d是部署，可是先后使用或者直接使用组合命令hexo d -g，发现Hexo文件夹生成了public文件。 查看搭建效果浏览器输入http://localhost:4000,查看搭建效果。如果localhost:4000无法访问，是因为你的电脑端口被占用了，而hexo默认的端口是4000，可以通过修改端口来解决这个问题。 比如将端口改成4040现在就可以看到效果了 Hexo设置网站搭建完成之后，可以根据需要对Hexo生产的网站进行设置，设置是修改_config.yml，我复制一下别人的设置，可以参考一下。 Hexo Configuration123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: XTong notessubtitle: Live beautifully, dream passionately, love completelydescription: You Never Know Who You Areauthor: X T Wlanguage: zh-Hanstimezone: Asia/Shanghai# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: https://aliceflaviawang.github.io/root: /permalink: :year/:month/:day/:title/permalink_defaults:# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: false tab_replace:# Category &amp; Tagdefault_category: othercategory_map:tag_map:# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 8pagination_dir: page# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: jacman# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/aliceflaviawang/aliceflaviawang.github.io.git branch: masterfeed: type: atom path: atom.xml limit: 20 hub: baidusitemap: path: baidusitemap.xmlsearch: path: search.xml field: post format: html limit: 10000 注：与gitgub pages建立关联（非常关键） 发表新文章使用hexo发表文章1$ hexo n #写文章 写完之后，推送到服务器上，执行12$ hexo g #生成$ hexo d #部署 或者hexo d -g 或者使用markdown来写文章常用命令1$ hexo new post &quot;postname&quot; #新建文章 注：如果 $ hexo d命令提示ERROR Deployer not found: git，解决办法 $ npm install hexo-deployer-git –save,然后再重新生成部署。hexo d实际上就是将博客部署到gitgub上去。hexo new post执行后会在项目source_posts中生成postname.md文件，用编辑器打开即可编辑，也可以直接在source_posts中新建一个md文件。写完之后，部署到服务器上12$ hexo g$ hexo d 打开aliceflaviawang.github.io,可以看到第一篇博客了 域名其实搭建博客不一定需要域名，当然如果你嫌github.io不够高大上，当然可以买个域名来装x.很多地方可以买域名，不只是godaddy，像腾讯云、万网…很多，我在godaddy中文网站上上买了aliceflaviawang.com这个网站，因为中文网站指引比较明确，就不详说了。 将域名与Github Pages空间绑定GitHub pages设置方法一：在Repository的根目录下面，新建一个名为CNAME的文本文件，里面写入你想要绑定的域名，比如aliceflaviawang.com方法二：点击setting，在custom domain下面天上你想要绑定的域名，点击save，会自动生成一个CNAME文件，里面保存的就是你的域名了。 DNS设置用DNSpod，我在腾讯云上注册了下，注意必须实名认证了才让你解析域名，由于我的域名已经退了，就直接使用别人的图片 添加域名，如下图设置其中A的两条记录指向的ip地址是github pages提供的地址，这个记录是云解析解析出来的结果，云解析会提示去godaddy修改dns地址。我采用的方式是自己添加，首先ping http://aliceflaviawang.github.io的地址，获得A的地址添加，然后添加www域名地址。 godaddy修改DNS点击我的账户里–&gt;点击域名–&gt;将godaddy的NameServer更改成f1g1ns1.dnspod.net和f1g1ns2.dnspod.net （域名解析后提示）。 访问博客现在就不需要访问aliceflaviawang.github.io了，可以直接访问aliceflaviawang.com注：如果访问的时候发现页面是github首页，说明需要清除一下缓存了。 后记本博客主要参考的是http://blog.sina.com.cn/s/blog_617ccc0c0101h84p.html。","categories":[],"tags":[],"keywords":[]},{"title":"我的第一篇博客","slug":"我的第一篇博客","date":"2017-04-04T13:28:41.000Z","updated":"2017-04-04T13:42:27.261Z","comments":true,"path":"2017/04/04/我的第一篇博客/","link":"","permalink":"https://aliceflaviawang.github.io/2017/04/04/我的第一篇博客/","excerpt":"","text":"感想清明节放假的最后一天，终于搭建了这个博客，心情还是比较激动的，希望以后能够通过博客这种方式记录下每天的进步！","categories":[],"tags":[],"keywords":[]}]}