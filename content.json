{"meta":{"title":"笑呵呵","subtitle":"We were moving mountains long before we knew we could","description":"You Never Know Who You Can Be","author":"Alice","url":"https://aliceflaviawang.github.io"},"pages":[{"title":"about","date":"2017-04-17T13:23:23.000Z","updated":"2017-04-17T13:23:23.052Z","comments":true,"path":"about/index.html","permalink":"https://aliceflaviawang.github.io/about/index.html","excerpt":"","text":""}],"posts":[{"title":"http请求头","slug":"http请求头","date":"2017-09-18T03:24:32.000Z","updated":"2017-09-18T09:14:25.794Z","comments":true,"path":"2017/09/18/http请求头/","link":"","permalink":"https://aliceflaviawang.github.io/2017/09/18/http请求头/","excerpt":"","text":"http由两部分组成：请求和响应。当你在web浏览器中输入一个url时，浏览器将根据你的要求创建并发送请求，该请求包含所输入的url以及一些与浏览器本身相关的信息。当服务器收到这个请求时将返回一个响应，该响应包括与请求相关的信息以及位于指定URL的数据。直到浏览器解析出该响应并显示出网页为止。 HTTP请求HTTP请求的格式如下： []请求行：用来说明请求类型、要访问的资源以及使用的HTTP版本；首部：用来说明服务器要使用的附加信息空行（必须要有）消息主体：键值对123456789POST / HTTP/1.1Host: www.baidu.comUser-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)Gecko/20050225 Firefox/1.0.1Content-Type: application/x-www-form-urlencodedContent-Length: 40Connection: Keep-Alivename=Professional%20Ajax&amp;publisher=Wiley HTTP响应与HTTP请求的格式十分类似： []状态行：状态码表示所请求资源的情况头部：返回一个Date的首部，用来说明响应生成的日期和时间，其他跟请求头差不多空行响应主体：包含的是请求资源的HTML文件","categories":[],"tags":[],"keywords":[]},{"title":"SQL性能优化","slug":"SQL性能优化","date":"2017-09-17T03:24:05.000Z","updated":"2017-09-17T04:03:27.315Z","comments":true,"path":"2017/09/17/SQL性能优化/","link":"","permalink":"https://aliceflaviawang.github.io/2017/09/17/SQL性能优化/","excerpt":"","text":"查询的模糊匹配避免在一个复杂查询里面使用LIKE ‘%parm1%’ 解决办法：只需要对该脚本略做改进，查询速度便会提高近百倍。方法如下：a、修改前台程序——将查询由文本输入改为下拉列表，即将模糊输入变为具体定位b、直接修改后台——根据输入，先查出符合条件的并把相关记录保存在一个临时表里，然后用临时表做复杂关联 索引问题缺少索引对性能影响较大。另外，不要在建立索引的数据列上进行下列操作： 避免对索引字段进行计算操作 避免在索引字段上使用not,&lt;&gt;,！= 避免在索引列上使用is null和is not null 避免在索引列上上出现数据类型转换 避免在索引字段上使用函数 避免建立索引的列中使用空值 复杂操作部分update、select语句写的很复杂（经常嵌套多级子查询）——可以适当拆成几步，先生成一些临时数据表，再进行关联操作 update同一个表的修改在一个过程中出现很多次，可以考虑将其整合在一个update语句来完成 在可以使用union all语句里，使用unionunion和union all都是将两个结果集合并为一个。union：可以去除重复值，并且按照字段的顺序进行排序union all:只是简单的将两个集合合并，既不去重也不排序，效率要高很多。因此从效率的角度，能用union all不要用union 在where语句中，尽量避免对索引字段进行计算操作因为这样很有可能导致索引不可用，损害了性能。 where语句的法则（1）避免在where字句中使用in,not in,or或者having可以使用exist和not exist代替in和not in；having可以用where代替，如果无法代替可以分为两步处理（2）不要以字符格式声明数字，要以数字格式声明字符值。（日期同样）否则会使索引无效，产生全表扫描。 对select语句的法则在应用程序、包和过程中限制使用select * form table这种方式 排序避免使用耗费资源的操作，带有distinct，union，minus，insert，order by的sql语句会启动sql引擎执行，耗费资源的排序（sort）功能。distinct需要一次排序操作，而其他的至少需要执行两次排序。 临时表慎重使用临时表可以极大的提高系统性能","categories":[],"tags":[],"keywords":[]},{"title":"三栏布局","slug":"三栏布局","date":"2017-09-04T13:42:47.000Z","updated":"2017-09-04T13:47:57.901Z","comments":true,"path":"2017/09/04/三栏布局/","link":"","permalink":"https://aliceflaviawang.github.io/2017/09/04/三栏布局/","excerpt":"","text":"绝对值法： margin负值法 123456&lt;div id=&quot;main&quot;&gt; &lt;div id=&quot;body&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;left&quot;&gt;&lt;/div&gt; &lt;div id=&quot;right&quot;&gt;&lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819202122232425html,body&#123; margin:0; //取消浏览器的设置的边界&#125;#main&#123; width:100%; height:200px; float:left;&#125;#main,#body&#123; background:black; height:200px; &#125;#left,#right&#123; width:200px; height:200px; float:left; background:red;&#125;//通过负值使得left和right移动到两边#left&#123; margin-left:-100%;&#125;#right&#123; margin-left:-200px;&#125;","categories":[],"tags":[],"keywords":[]},{"title":"两列等高","slug":"两列等高","date":"2017-09-04T12:21:13.000Z","updated":"2017-09-04T12:55:00.858Z","comments":true,"path":"2017/09/04/两列等高/","link":"","permalink":"https://aliceflaviawang.github.io/2017/09/04/两列等高/","excerpt":"","text":"面试的时候被问到，如何实现响应式的两列等高。下来查到了两种方式： 设置最小高度123min-height:200px;height:auto !important;height:200px; 实现两列等高：123456&lt;div id=&quot;container2&quot;&gt;&lt;div id=&quot;container1&quot;&gt; &lt;div id=&quot;col1&quot;&gt;Left Sidebar&lt;/div&gt; &lt;div id=&quot;col2&quot;&gt;Main Content&lt;/div&gt;&lt;/div&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132#container2 &#123; float: left; width: 100%; background: orange; position: relative; overflow: hidden; &#125; #container1 &#123; float: left; width: 100%; background: green; position: relative; left: 220px;/* 宽度大小等与边栏宽度大小*/ &#125; #col2 &#123; position: relative; margin-right: 220px;/* 宽度大小等与边栏宽度大小*/ &#125; #col1 &#123; width: 220px; float: left; position: relative; margin-left: -220px;/* 宽度大小等与边栏宽度大小*/ &#125; #col1,#col2 &#123; min-height: 100px; height: auto !important; height: 500px; &#125; padding补偿法首先把列的padding-bottom设为一个足够的大的值，再把列的margin-bottom设一个与前面的padding-bottom的正值相抵消的负值。将上面例子中的#col1,#col2换成下面的1234#col,#col2&#123; padding-bottom:2000px; margin-bottom:-2000px;&#125; padding-bottom的值取决于实际情况，但是设大一点无所谓。","categories":[],"tags":[],"keywords":[]},{"title":"div水平垂直居中的方式总结","slug":"div水平垂直居中的方式总结","date":"2017-09-01T14:19:43.000Z","updated":"2017-09-04T14:56:19.023Z","comments":true,"path":"2017/09/01/div水平垂直居中的方式总结/","link":"","permalink":"https://aliceflaviawang.github.io/2017/09/01/div水平垂直居中的方式总结/","excerpt":"","text":"1.绝对定位margin:0 auto可以实现水平居中，实际上margin:auto也可以实现垂直居中。12345.center&#123; margin:auto; position:absolute; top:0;left:0;bottom:0;right:0;&#125; 优点： 支持跨浏览器，包括IE8-IE10 无需其他标记，CSS代码量少 支持百分比属性 只用这一个类可以实现任何内容块居中 完美支持图片居中缺点： 必须声明高度或者宽度中的一种 居中方式一、容器内内容块的父容器设置为position：relative，使用上述绝对居中方式，可以使内容居中显示于父容器内。12345678910111213.parent&#123; position:relative; width:300px; height:200px;&#125;.Absolute-Center &#123; margin: auto; position: absolute; top: 0; left: 0; bottom: 0; right: 0; width:30%; height:20%; overflow:auto;&#125; 2.flexflex的justify-content和align-items分别决定元素水平方向和垂直方向的排列方向。将其设置成center即可实现水平和垂直居中。123&lt;div id=&quot;parent&quot;&gt; &lt;div id=&quot;child&quot;&gt;&lt;/div&gt; &lt;/div&gt; 12345678910111213#parent&#123; display:flex; width:100%; background:black; height:200px; align-items:center; justify-content:center;&#125;#child&#123; width:100px; height:100px; background:red;&#125; parent是容器，child是垂直居中的元素。 3. translate(-50%，50%)原理是将元素通过绝对定位移动到父元素的宽高的50%，这时候要将移动其自身宽高的-50%，才能让元素水平垂直居中。1234567891011121314151617#parent&#123; position:relative; width:100%; background:black; height:300px; &#125;#child&#123; width:100px; height:100px; background:red; position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); &#125; 注意，parent的position必须设成relative。这种方式有个缺点：必须知道元素的宽高。 4. 水平居中 inline-block仅inline-block无法让元素水平居中，关键还是要在元素的父容器中设置text-align属性为center。水平居中： 123456789101112#parent&#123; text-align:center; width:100%; background:black; height:300px; &#125;#child&#123; width:100px; height:100px; background:red; display:inlinblock&#125; fit-content（兼容性很差）fit-content是width的一个新属性，配合margin:auto，可以实现水平居中。 1234567&lt;ul&gt; &lt;li&gt;&lt;a href=&quot;/&quot;&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/&quot;&gt;关于我们&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/&quot;&gt;产品展示&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/&quot;&gt;客户支持&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/&quot;&gt;联系我们&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; 1234567ul&#123; width: -moz-fit-content; width: -webkit-fit-content; width: fit-content; margin: auto;&#125;li&#123;float:left&#125; 5. table-cell垂直剧中table-cell实现让内容元素垂直居中垂直居中：12345678#parent&#123; width:1500px; background:black; height:300px; display:table-cell; text-align:center; vertical-align:middle; &#125;","categories":[],"tags":[],"keywords":[]},{"title":"CSS相关知识","slug":"CSS相关知识","date":"2017-08-30T04:46:46.000Z","updated":"2017-08-31T10:52:42.834Z","comments":true,"path":"2017/08/30/CSS相关知识/","link":"","permalink":"https://aliceflaviawang.github.io/2017/08/30/CSS相关知识/","excerpt":"","text":"1. 盒模型IE（怪异模式）：宽度=border+padding+contentWidthW3C(标准):宽度=contentWidth 2. box-sizingcontent-box:宽、高对应到的元素的内容框，在宽、高之外绘制元素的padding和borderboder-box:宽高决定了元素的padding和border，从已定的宽、高中减去padding和border才是内容的宽高 3. margin塌陷挨着的、且没有任何东西分割的两个普通元素会在垂直方向上合并margin 父子毗邻元素毗邻元素的外边距会合并 上下毗邻元素 空块元素不会发生叠加的： 浮动元素与其他元素之间不发生外边距叠加 创建BFC的元素不会与它的子元素发生外边距叠加 绝对定位元素和其他任何元素之间不发生外边距叠加解决办法：为父元素设置BFC（包括overflow：auto）或padding或border（解决父子重叠），兄弟元素之间设置float或inline-block或absolute 4. BFCBFC就是一种布局方式，在这种布局方式下，盒子们自躲在的containing block顶部一个接一个垂直排列，水平方向上撑满整个宽度（除非内部盒子自己建立了新的BFC）。两个相邻的BFC之间的距离由margin决定，在同一个BFC内部，两个垂直方向相邻的块级元素的margin会发生塌陷。 如何创建BFC:1234float属性不为noneoverflow不为visible（可以是hidden、scroll、auto）position属性为absolute或fixeddisplay为inline-block、table-cell、table-caption BFC的作用： 清除浮动：对子元素设置浮动后，父元素发生高度塌陷，就是子元素脱离文档流，父元素没有东西能撑满，就塌陷了；解决的办法就是把父元素变成一个BFC。 垂直margin合并：CSS中，相邻的两个盒子的外边距可以结合成一个单独的外边距。这种方式合并外边距的方式被称为折叠，并且因而结合成外边距成为折叠外边距。折叠的结果：两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值两个相邻的外边距都是负数时，折叠结果是它们两者绝对值较大值两个外边距一正一负时，折叠结果是两者的相加的和 创建自适应两栏布局：很多网站是左图片+右文字的两栏布局，文字受到图片浮动的影响，我们可以为P元素的内容建立一个BFC，让其内容消除对外界浮动的影响。","categories":[],"tags":[],"keywords":[]},{"title":"浏览器标准模式和怪异模式","slug":"浏览器标准模式和怪异模式","date":"2017-08-30T03:10:18.000Z","updated":"2017-08-30T03:34:19.868Z","comments":true,"path":"2017/08/30/浏览器标准模式和怪异模式/","link":"","permalink":"https://aliceflaviawang.github.io/2017/08/30/浏览器标准模式和怪异模式/","excerpt":"","text":"目前浏览器排版引擎有三种模式：怪异模式、接近标准模式和标准模式。接近标准模式下，只有少数怪异行为被实现。由于历史原因，各个浏览器在对页面的渲染上存在差异，甚至同一浏览器的不用版本中，对页面的渲染也不同。W3C标准之前，浏览器对页面的渲染上没有统一规范，产生了怪异模式。由于W3C标准的推出，浏览器有了统一的标准，这是二者最简单的却别。为了兼容旧的页面，两种渲染方法共存于一个浏览器上。两种模式最主要的差别体现在对盒子模型的解释上。浏览器究竟用哪种模式渲染，这就引出了DTD，既是网页的头部声明，浏览器会通过识别DTD而采用相对应的渲染模式： 浏览器要使老旧的网页正常工作，但这部分网页是没有doctype声明的，所以浏览器对没有doctype声明的网页采用怪异模式解析 对于拥有doctype声明的网页，浏览器不能识别的doctype声明，采用怪异模式 使用HTML4以下的DTD声明时，基本所有的浏览器都是使用怪异模式 如何判定是标准模式还是怪异模式：方法一：123alert(window.top.document.compatMode);//BackCompat 怪异模式//CSS1Compat 标准模式 方法二：12alert($.boxModel)alert($.support.boxModel)","categories":[],"tags":[],"keywords":[]},{"title":"OS基础点","slug":"OS基础点","date":"2017-08-27T13:41:02.000Z","updated":"2017-08-28T04:50:29.161Z","comments":true,"path":"2017/08/27/OS基础点/","link":"","permalink":"https://aliceflaviawang.github.io/2017/08/27/OS基础点/","excerpt":"","text":"总结写OS的基本内容。 1. TCP和UDP的区别 TCP面向连接，UDP是无连接的，即发送数据之前不需要建立连接； TCP提供可靠的服务，通过TCP传送的数据，无差错，不丢失，不重复，且按序到达（TCP通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输）；UDP不保证可靠交付。 TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流；UDP是面向报文的，UDP没有拥塞控制，因此网络出现拥塞时不会是源主机发送速率降低（对实时应用很有用） 每一条TCP连接只能是点对点的；UDP支持一对一、一对多、多对一、多对都 TCP首部开销20字节；UDP首部开销小，只有8字节 TCP的逻辑通信通道是全双工的可靠信道；UDP是不可靠信道 2. TCP三次握手四次挥手三次握手TCP是主机对主机层的传输控制协议，提供可靠的连接服务，采用三次握手确认建立一个连接：位码即TCP标志位，有6中标示：SYN(synchronous建立连接)ACK（acknowledgement确认）PSH（push传送）fin(finish结束)URG(urgent紧急)Sequence number(顺序号码)Acknowledge number(确认号码) 各个状态的意义如下：LISTEN 侦听来自远方TCP端口的连接请求SYN-SENT 在发送连接请求后等待匹配的连接请求SYN-RECVEIVED 在收到和发送一个连接请求后等待连接请求的确认ESTABLISHED 代表一个打开的连接，数据可以传送给用户FIN-WAIT-1 等待远程TCP的连接中断请求，或先前的连接中断请求的确认FIN-WAIT-2 从远程TCP等待连接中断请求CLOSE-WAIT 等待从本地用户发来的连接中断请求CLOSING 等待远程TCP对连接中断请求的确认LAST-ACK 等待原来发向远程TCP的连接中断请求确认TIME-WAIT 等待足够的时间以确保远程TCP接收到连接中断请求的确认CLOSED 没有任何连接状态 三次握手过程：（1） 第一次握手：建立连接时，客户端A发送SYN包（SYN=j）到服务器B，并进入SYN_SEND状态，等待服务器B确认（2） 第二次握手：服务器B收到SYN包，必须确认客户A的SYN（ACK=j+1），同时也发送一个自己的SYN包（SYN=k），此时服务器B进入SYN_RECV状态（3） 第三次握手：客户端A接收服务器B的SYN+ACK包，向服务器B发送确认吧哦ACK(ACK=K+1)，此包发送完毕，客户端A和服务器B都进入ESTABLISED状态，完成三次握手。确认号：其数值等于发送方的发送序号+1 四次挥手：因为TCP连接是全双工的，因此每个方向都必须单独进行关闭。（1）客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送（2）服务器B收到这个FIN，它发回一个ACK（确认序号为收到的序号+1）；和SYN一样，一个FIN将占用一个序号（3）服务器关闭与客户端A的连接，发送一个FIN给客户端A（4）客户端A发回ACK报文确认，并将确认序号设置为收到序号+1 3. TCP拥塞控制拥塞控制：防止过多的数据注入到网络中，这样可能是网络的路由器或链路不至过载。拥塞控制方法：慢开始、拥塞避免、快重传、快恢复慢开始和拥塞避免：发送方维持一个拥塞窗口的状态变量，拥塞窗口的大小取决于网络的拥塞程度，并且动态变化。规则就是只要网络中没有出现拥塞，窗口就增大一些，以便把更多的分组发送出去，出现了拥塞，就减小窗口，减少注入网络的分组数。慢开始：如果开始发送大量数据可能引起网络拥塞，因此先探测一下，再从小到大逐渐增大发送窗口（每次增加窗口状态值cwnd加倍，最开始cwnd设置为1个报文段）为了防止拥塞窗口cwnd增长过大，设置慢开始门限ssthresh，用法如下： 当cwndssthresh时，停止使用慢开始算法使用拥塞避免 当cwnd=ssthresh时，两者都可以拥塞避免：让拥塞窗口缓慢增大（每次加1），这样增长速率比满开始慢得多但是无论是慢开始还是拥塞控制，只要判断网络出现拥塞，就要把门限设为出现拥塞时发送窗口值的一半，然后cwnd重新设为1，执行慢开始算法。 快重传和快恢复：快重传：快重传要求接收方没收到一个失序的报文后立即发出确认，比如发送M1,M2,M3,M4，发送方只要收到了M1,M2,M4的确认，就立即重传对方尚未收到的报文段M3而不必等待M3设置的重传计时器到期（使用快重传使整个网络吞吐量提升20%）。快恢复：当发送方收到三个重复确认，就执行乘法减小算法，把门限减半（这是为了避免发生拥塞），由于发送方现在认为网络很可能没有发生拥塞，因此与慢开始不同的是，不执行慢开始算法（即拥塞窗口现在不设置为1），而是将cwnd设为慢开始门限减半后的数值，然后执行拥塞避免算法。 4. 死锁产生的原因及四个必要条件产生死锁的原因主要是：（1）因为系统资源不足（2）进程运行推进的顺序不合适（3）资源分配不当产生死锁的四个必要条件：（1）互斥条件：一个资源每次只能被一个进程使用（2）请求与保持条件：一个进程因为请求资源而阻塞时，对已获得的资源保持不放（3）不剥夺条件：进行已经获得的资源，在未使用之前，不能强行剥夺（4）循环等待条件：若干进程之间形成一种首尾相连的循环等待资源关系 5. HTTP协议HTTP协议的主要特点： 支持客户/服务器模式 简单快速：客户向服务器请求服务时，只需要传送请求方法和路径。请求的方法常用的有GET,HEAD,POST等。由于HTTP协议简单，使得HTTP服务器的程序规模小，因为通信速度很快 灵活：HTTP允许传输任意类型的数据对象，传输的类型由Content-Type加以标记 无连接：每次只处理一个请求，服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间 无状态：无状态是指协议对事物没有记忆能力，缺少状态意味着如果要处理后续需要前面的信息，则它必须重传 HTTP1.0和HTTP1.1连接无法复用，导致每次请求都会经历三次握手和慢启动，三次握手在高延迟场景下影响较明显，慢启动则对文件类大请求响应较大另外队头阻塞，导致带宽无法被充分利用，后续请求被阻塞。 HTTP1.1引入持久连接和pipelining（管道机制）：持久连接即TCP连接默认不关闭，可以被多个请求复用，不用声明；pipelining允许在同一个TCP连接里面，客户端可以同时发送多个请求。HTTP1.1采用了pipelining，但是也存在缺陷： 只有幂等请求能使用pipelining，非幂等请求比如post不能使用，因为请求之间可能会存在先后依赖关系 队头阻塞不能完全解决，server的response还是要求一次返回，遵循FIFO原则，如果请求1的response没有回来，2、3、4、5的response也不会被送回来。 HTTP1.X于HTTP2.X的区别 HTTP1头信息肯定是文本，数据体可以使文本也可以是二进制；HTTP2则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为帧。二进制的优势是解析数据非常方便 HTTP2支持多路复用，通过多个请求steam共享一个tcp连接的方式，降低了延迟同时提高了带宽的利用率因为steam有id，所以可以通过steam id来判断究竟是哪个流从而定位到哪个http请求而且客户端和服务器都可以同时发送多个请求，这样就避免了队头阻塞 http2将每个请求或回应的所有数据包成为一个数据流，每个数据流都有一个独一无二的编号，从而可以区分数据流发送到一半的时候，可以通过发送信号(RST_STREAM)取消这个数据流；1.1版本取消数据流的唯一办法是关闭TCP连接；而HTTP2可以在TCP连接还打开的时候取消某一次请求 头信息压缩，HTTP2引入头信息压缩机制，一方面使用gzip或compress压缩后再发送，另一方面客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样的字段，只发送索引号，这样就提高了速度 HTTP2服务器推送，服务器在未请求时主动向客户端发送资源 补充：HTTP幂等性幂等性的意思是同一个请求，发送一次和发送N次效果是一样的（这里是指具有相同的副作用而不是每次结果都一样）。HTTP GET方法用于获取资源，不应有副作用，所以是幂等的。HTTP DELETE方法用于删除资源，有副作用，但它应该满足幂等性HTTP POST方法用于创建资源，所对应的URI并非创建的资源本身，而是去执行创建动作的操作者，有副作用，不满足幂等性（两次相同的post请求会在服务器创建两份资源）HTTP PUT方法用于创建或更新操作，所对应的URI是要创建或更新的资源本身，有副作用，它应该满足幂等性 HTTPSHTTPS是基于SSL的HTTP协议，但HTTPS使用不同HTTP协议的默认端口及一个加密、身份验证层（HTTP与TCP之间）。客户端使用HTTPS的URL与Web服务器通信时步骤如下：（1）客户端使用HTTPS的URL访问Web服务器，要求与服务器建立SSL连接（2）Web服务器收到请求后，会将网站的证书信息（包含公钥）传送一份给客户端（3）客户端浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级（4）客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站（5）web服务器利用自己的私钥解密出会话密钥（6）web服务器利用会话密钥进行与客户端之间的通信 HTTPS的优点： 确保数据发送到正确的客户机和服务器 防止数据在传输过程中不被窃取、改变、保证数据的完整性 不是绝对安全，但是大幅增加了中间人攻击的成本缺点： 效率低，加载时间比http延长了近50% 安全范围有限，对拒绝服务器攻击、服务器劫持等几乎起不到作用 SSL证书的信用链体系并不安全 证书需要购买，成本增加 SEO抓取HTTPS有一些困难，目前谷歌做的好一点，百度还不太完善","categories":[],"tags":[],"keywords":[]},{"title":"Generator","slug":"Generator","date":"2017-08-27T12:33:07.000Z","updated":"2017-08-27T13:32:12.393Z","comments":true,"path":"2017/08/27/Generator/","link":"","permalink":"https://aliceflaviawang.github.io/2017/08/27/Generator/","excerpt":"","text":"Generator函数是ES6提供的一种异步编程解决方案，Generator函数是一个状态机，封装了多个内部状态。除了状态机，还是一个遍历器对象生成函数，返回的遍历器对象，可以依次遍历Generator函数内部的每一个状态。 形式上，Generator是一个普通函数，但有两个特征：一是，function关键字与函数名之间有个星号；二是，函数体内部使用yield表达式，定义不同的内部状态。1234567function* helloWorldGenerator() &#123; yield &apos;hello&apos;; yield &apos;world&apos;; return &apos;ending&apos;;&#125;var hw = helloWorldGenerator(); 上述定义了一个Generator函数helloWorldGenerator，它的内部有两个yield表达式，即函数有三个状态：hello,world和return语句（结束执行）。 Generator函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用Generator函数后，该函数并不执行，返回的也不是一个函数运行结果，而是一个指向内部状态的指针对象（遍历器对象）。 下一步，必须调用遍历器对象的next方法，使得指针移向下一个状态。每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield表达式（或return语句）为止。换言之，Generator函数是分段执行的，yield表达死是暂停执行的标记，而next方法可以恢复执行。 每一次调用遍历器对象的next方法，都会返回一个有着value和done两个属性的对象。value表示当前内部状态的值，是yield表达式后面那个表达式的值，done属性是一个布尔值，表示是否遍历结束。 协程协程是一种程序运行的方式，可以理解成“写作的线程”或“协作的函数”。协程既可以用单线程实现，也可以用多线程实现。前者是一种特殊的子例程，后者是一种特殊的线程。 协程与子例程的差异传统的子例程采用堆栈后进先出的执行方式，只有当调用的子函数完全执行完毕，才会结束执行父函数。协程与其不同，多个线程可以并行执行，但是只有一个线程处于正在运行状态，其他都处于暂停，线程之间可以交换执行权。这种可以并行执行、交换执行权的线程，成为协程。 协程与普通线程的区别相同点，都有自己的执行上下文、可以分享全局变量；不同之处，同一时间可以有多个线程处于运行状态，但是运行的协程只有一个，其他协程都处于暂停状态。另外普通线程是抢先式的，哪个线程优先得到资源，由运行环境决定，但是协程是合作式的，执行权由协程自己分配。 Generator是ES6对协程的不完全实现，因为只有Generator的调用者才能将执行权还给Generator函数，如果完全执行的协程，任何函数都可以将暂停的协程继续执行。","categories":[],"tags":[],"keywords":[]},{"title":"leetcode contest","slug":"leetcode-contest","date":"2017-08-27T08:10:58.000Z","updated":"2017-08-27T08:58:25.131Z","comments":true,"path":"2017/08/27/leetcode-contest/","link":"","permalink":"https://aliceflaviawang.github.io/2017/08/27/leetcode-contest/","excerpt":"","text":"8-27 contest第1题Non-decreasing Array My SubmissionsBack to ContestUser Accepted: 1054User Tried: 1755Total Accepted: 1080Total Submissions: 7519Difficulty: EasyGiven an array with n integers, your task is to check if it could become non-decreasing by modifying at most 1 element. We define an array is non-decreasing if array[i] &lt;= array[i + 1] holds for every i (1 &lt;= i &lt; n). Example 1:Input: [4,2,3]Output: TrueExplanation: You could modify the first 4 to 1 to get a non-decreasing array.Example 2:Input: [4,2,1]Output: FalseExplanation: You can’t get a non-decreasing array by modify at most one element.Note: The n belongs to [1, 10,000].解题思路：通过不断尝试出错发现：对于nums[i-1],nums[i],nums[i+1]来说，如果nums[i]","categories":[],"tags":[],"keywords":[]},{"title":"JS继承实现方式","slug":"JS继承实现方式","date":"2017-08-24T08:45:01.000Z","updated":"2017-08-25T09:10:04.245Z","comments":true,"path":"2017/08/24/JS继承实现方式/","link":"","permalink":"https://aliceflaviawang.github.io/2017/08/24/JS继承实现方式/","excerpt":"","text":"今天来总结下继承实现的方式既然要实现继承，那么首先要有个父类：12345678910111213//定义一个动物类function Animal(name)&#123; //属性 this.name=name||&quot;Animal&quot;; //实例方法 this.sleep=function()&#123; console.log(this.name); &#125; &#125;//原型方法Animal.prototype.eat=function(food)&#123; console.log(this.name+&quot;正在吃：&quot;+food);&#125; 1.原型链继承核心：将父类的实例作为子类的原型1234567891011function Cat()&#123;&#125;Cat.prototype=new Animal();Cat.prototype.name=&apos;cat&apos;;var cat=new Cat(); console.log(cat.name); //catconsole.log(cat.eat(&apos;fish&apos;)); //cat正在吃fishconsole.log(cat.sleep()); //catconsole.log(cat instanceof Animal); //trueconsole.log(cat instanceof Cat); //true 特点： 非常纯粹的继承关系，实例是子类的实例，也是父类的实例 父类新增原型方法/原型属性，子类都能访问到 简单，易于实现缺点： 要想为子类新增属性和方法，必须要在new Animal()这样的语句之后，不能放在构造器中 无法实现多继承 来自原型对象的引用属性是所有实例共享的，即一个实例改变了另外的也会改变 创建子类实例时，无法向父类构造器传参 2.构造继承核心：使用父类的构造函数来增强子类实例，等于复制父类的实例属性给子类（没用到原型）12345678910function Cat(name)&#123; Animal.call(this); this.name=name||&apos;Tom&apos;;&#125;var cat=new Cat(); console.log(cat.name); //Tomconsole.log(cat.eat(&apos;fish&apos;)); //error:cat.eat is not a functionconsole.log(cat.sleep()); //Tomconsole.log(cat instanceof Animal); //falseconsole.log(cat instanceof Cat); //true 特点： 解决了1中，子类实例共享父类引用属性的问题 创建子类实例时，可以向父类传递参数 可以实现多继承（call多个父类对象）缺点： 实例并不是父类的实例，只是子类的实例 只能继承父类的实例属性和方法，不能继承原型属性/方法 无法实现函数复用，每个子类都有父类实例函数的副本，影响性能 3.实例继承核心：为父类实例添加新特性，作为子类实例返回123456789101112131415161718function Cat(name)&#123; var instance=new Animal(); instance.name=name||&apos;Tom&apos;; return instance;&#125;var cat=new Cat();console.log(cat.name); //Tomconsole.log(cat.sleep()); //Tomconsole.log(cat instanceof Animal); //trueconsole.log(cat instanceof Cat); //false``` 特点： 1. 不限制调用方式，不管是new 子类子类（），返回的对象具有相同的效果缺点： 1. 实例是父类的实例，不是子类的实例 2. 不支持多继承### 4.拷贝继承 function Cat(name){ var animal=new Animal(); for(var p in animal){ Cat.prototype[p]=animal[p]; } Cat.prototype.name=name||’Tom’;}var cat=new Cat();console.log(cat.name); //Tomconsole.log(cat.sleep()); //Tomconsole.log(cat instanceof Animal); //falseconsole.log(cat instanceof Cat); //true123456789特点： 1. 支持多继承缺点： 1. 效率较低，内存占用高（因为要拷贝父类的属性） 2. 无法获取父类不可枚举的方法（不可枚举的方法，不能使用for in访问到）### 5.组合继承核心：通过调用父类方法，继承父类的属性并保留传参的优点，然后通过父类实例作为子类原型，实现函数复用。 function Cat(name){ Animal.call(this); this.name=name||’Tom’; }Cat.prototype=new Animal();var cat=new Cat();console.log(cat.name); //Tomconsole.log(cat.sleep()); //Tomconsole.log(cat instanceof Animal); //trueconsole.log(cat instanceof Cat); //true123456789101112特点： 1. 既弥补了方式2的缺陷，可以实现实例属性/方法，也可以继承原型属性/方法 2. 既是子类的实例，也是父类的实例 3. 不存在引用属性共享问题 4. 可传参 5. 函数可复用缺点： 1. 调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了）### 6.寄生组合继承核心：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免组合继承的缺点。 function Cat(name){ Animal.call(this); this.name=name||’Tom’;}(function(){ //创建一个没有实例方法的类 var Super=function(){ } Super.prototye=Animal.prototype; Cat.prototype=new Super();})(); var cat=new Cat();console.log(cat.name); //Tomconsole.log(cat.sleep()); //Tomconsole.log(cat instanceof Animal); //falseconsole.log(cat instanceof Cat); //true12### ES6继承 class Animal{ constructor(){ this.type=’animal’ } says(say){ console.log(this.type+” says “+say) }}let animal=new Animal(); //animal says helloanimal.says(‘hello’);class Cat extends Animal{ constructor(){ super() this.type=’cat’ }}let cat=new Cat()cat.says(‘hello’); //cat says hello12345678910ES6定义了类class，里面有一个construtor方法，就是构造方法，而this关键字则代表实例对象。constructor内定义的方法和属性是实例对象自己的，而construtor外定义的方法和属性则是所有实例对象可以共享的。class之间通过extends实现继承，这比ES5通过修改原型链实现继承，要清晰和方面很多。super关键字，它指代父类的实例（即父类的this对象），子类必须在constructor方法中调用super方法，否则新建实例时会报错，这是因为子类没有自己的this对象，而是继承父类的this对象，然后再用子类的构造函数修改this。如果不调用super方法，子类就得不到this对象。ES6的继承机制，实质上是先创建父类的实例对象this（所以必须调用先super方法），然后再用子类的构造函数修改this。ES6中同样有prototype以及在ES5中用来指向构造函数原型的__proto__属性，这个属性在ES6中的指向有一些主动的修改。一个继承语句同时存在两条继承链：一条实现属性继承，一条实现方法继承。 class A extends B{ A.proto===B; //属性继承 A.prototype.proto===B.prototype; //方法继承}1234567ES6的子类的__proto__是父类，子类的原型的__proto__是父类的原型第二条继承链理解起来没有什么问题，对应到ES5中的A.prototype=new B，A.prototype是B构造的实例，指向构造函数B的原型B.prototype。但是在ES5中A.__proto__指向Function.prototype，因为每个构造函数其实都是Function这个对象构造的，ES6中子类的__proto__指向父类可以实现属性的继承，在ES5中在没有用借用集成的时候，由于父类属性被子类原型继承，所有的子类实例实际上都是同一个属性应用。在ES6中实现了子类继承父类属性，在构造实例时会直接拿到子类的属性，不需要查找到原型属性上面去，ES6新的静态方法和静态属性（只能在构造函数上访问）也是通过这样类的直接继承来实现，至于普通函数复用方法还是放在原型链桑，道理和实现和ES5一样的。ES6的继承是在父类创建this对象，在子类constructor中来修饰父类的this，ES5是在子类创建this，将父类的属性方法绑定到子类，由于原生的构造函数（Function,Array）没有this，子类无法通过call/apply(this)获得其内部属性，所以在ES5无法继承，ES6实现后可以为原生构造函数封装一下有趣的接口，比如： class VersionedArray extends Array{ constructor(){ super(); this.history=[[]]; } commit(){ this.history.push(this.slice()); } revert(){ this.splice(0,this.length,…this.history[this.history.length-1]); }}var x=new VersionedArray();x.push(1);x.push(2);x //[1,2]x.history //[[]] x.commit();x.history; //[[],1,2]x.push(3);x //[1,2,3]x.revert();x.history //[1,2]```","categories":[],"tags":[],"keywords":[]},{"title":"const, let, var的区别 ","slug":"const-let-var的区别","date":"2017-08-23T02:07:46.000Z","updated":"2017-08-23T02:36:53.372Z","comments":true,"path":"2017/08/23/const-let-var的区别/","link":"","permalink":"https://aliceflaviawang.github.io/2017/08/23/const-let-var的区别/","excerpt":"","text":"constconst比较简单，通俗的来说就是用来定义常量，必须初始化，且初始化后不能修改。 var与letvar和let作用比较相似，let可以说是更完美的var，var声明的变量是全局的或者是函数级的，let声明的变量作用域是在块级作用域。 声明后未赋值，var和let表现相同：都是undefined 1234567&apos;use strict&apos;(function()&#123; var varTest; let letTest; console.log(varTest); //undefined console.log(letTest); //undefined&#125;()) 使用未声明的变量，表现不同：var是undefined，let则报错 123456(function()&#123; console.log(varTest); //undefined console.log(letTest); //报错：ReferenceError:letTest is not defined var varTest; let letTest;&#125;()) 重复声明同一个变量时，表现不同:var后声明的会覆盖前者，而let则直接报错 12345678(function()&#123; var varTest=&quot;hi&quot;; let letTest=&quot;hello&quot;; var varTest=&quot;changed&quot;; let letTest=&quot;error&quot;; console.log(varTest); //changed console.log(letTest); //报错：SyntaxError:Indentifier &apos;letTest&apos; has already been declared&#125;()) 变量作用范围不同：var作用在全局作用域或函数作用域，let作用在块级作用域，在函数内部使用let后，对外部无影响 123456789101112(function() &#123; var varTest = &apos;test var OK.&apos;; let letTest = &apos;test let OK.&apos;; &#123; var varTest = &apos;varTest changed.&apos;; let letTest = &apos;letTest changed.&apos;; &#125; console.log(varTest); //输出&quot;varTest changed.&quot;，内部&quot;&#123;&#125;&quot;中声明的varTest变量覆盖外部的letTest声明 console.log(letTest); //输出&quot;test let OK.&quot;，内部&quot;&#123;&#125;&quot;中声明的letTest和外部的letTest不是同一个变量&#125;()); 举个经典例子：12345for(var i=0;i&lt;3;i++)&#123; setTimeout(function()&#123; console.log(i)&#125;,1000)&#125; 控制台输出了3个3，是因为循环本身及三次timeout回调均共享唯一变量i。而使用let就不一样可以获得预期的效果：12345for(let i=0;i&lt;3;i++)&#123; setTimeout(function()&#123; console.log(i)&#125;,1000)&#125; 输出的是0，1，2，因为循环每次迭代时都为i创建新的绑定，就是捕捉每一个循环变量的不同值作为副本。","categories":[],"tags":[],"keywords":[]},{"title":"页面提速","slug":"页面提速","date":"2017-08-17T07:48:25.000Z","updated":"2017-08-18T02:17:47.611Z","comments":true,"path":"2017/08/17/页面提速/","link":"","permalink":"https://aliceflaviawang.github.io/2017/08/17/页面提速/","excerpt":"","text":"一、减少对服务器的文件请求常规的HTTP请求属于“请求”-“应答”-“断开”形式的短连接，每一个独立的资源我们都会向服务器发去一份get请求，再等服务端将我们需要的文件传回来。每一个资源的请求都会耗费“连接”-“等待”-“接收”的时间。因此减少服务器文件的请求次数，可以节省页面等待时间，也可以减少服务器负担。 有以下方案可以实现： 使用css sprite合并多个图片为单个图片文件，实际使用时通过backgroud-position来定位背景图片； 合并多个css样式文件为单个样式文件，合并多个脚本为单个脚本，再在页面中引用合并后的样式； 使用base64来展示图片，base64可以随着HTML的下载同时下载到本地，减少http请求，缺点是使用base64比原图的尺寸大； 将小块的css,js代码段直接写在页面上，而非在页面引入独立的样式/脚本文件，直接把小段的、复用率低的样式/脚本直接写在页面上带来的利还是大于弊的（弊端就是可能增大了页面代码量，不太好维护）； 利用http-equiv=”expires”元标签，设定一个未来的某时间点作为页面文件的过期时间，用户在过期时间之前所获取到的页面文件都仅从缓存中去取。 二、减少文件大小文件太大导致加载时间较长，因此可以： 压缩样式/脚本文件，可以使用gulp或者grunt来实现这点，它们均能很好地减少css/js文件的大小； 针对性选择图片格式，在无透明背景需求下，对于颜色较单一、无色彩渐变的图片仅使用gif格式，对于jpg图片也可以按照其清晰度要求，在导出jpg的时候选择对应的品质进行优化； 三、适度使用CDN使用CDN有几个好处：如果用户在其它站点下载过这个CDN资源，那么来我们站点仅仅从缓存中获取即可；减少了对自己站点服务器的文件请求，减少服务器负担；但是使用CDN有个很大的问题–增加了DNS解析，如果一个页面同时引入了多个CDN资源，可能会因为dns解析而陷入较多的等待时间，导致得不偿失。 四、延迟请求、异步加载脚本将脚本请求标签放到结束标签之前，使得页面上的脚本成为最后被请求的资源，自然也不会组赛其它页面资源的请求事件了。但是异步下载不代表异步执行，为了严格保证脚本逻辑顺序和依赖关系的正确性，会按照脚本被请求的顺寻来执行脚本。但是如果脚本依赖关系不大，这样就增加了页面请求的阻塞时间。解决的办法，可以给标签加上defer和async属性，但是这都不是良好的解决方案，要么有兼容问题，要么处理麻烦。网上推荐使用requireJS(AMD规范)或seaJS(CMD规范)来异步加载脚本并处理模块依赖的，前者将“依赖前置”（预加载所有被依赖脚本模块，执行速度最快），后者走的“依赖就近”（懒加载被依赖脚本模块，请求脚本更科学）。 五、延迟请求首屏外的文件首屏就是页面初始化时页面内容显示区域，也就是一加载，用户首先看到的区域。比如京东淘宝，对于需要滚动页面才能看到的图片内容，都进行了lazyload的处理，看起来的效果是这个页面更快加载完了，实际上后面的文件还没加载。 注：懒加载的原理：先将img标签中的src链接设为同一张图片（空白图片），将其整正的图片地址存储在img标签的自定义属性中（比如data-src）。当js监听到该图片元素进入可视窗口时，即将自定义属性中的地址存储到src属性中，以达到懒加载的效果。这样能防止页面一次性向服务器响应大量请求导致服务器响应慢，页面卡顿或崩溃的问题。 可以使用getBoundingClientRect，可以用来获取某个元素相对于视窗的位置集合。集合中由top,right,bottom,left等属性。-语法：这个方法没有参数rectObject=object.getBoundingClientRect();-返回值类型 ：TextRectangle对象，每个矩形具有四个整数性质（上，右，下，左）表示坐标的矩形，以像素为单位。rectObject.top:元素上边到视窗上边的距离；rectObject.right:元素上边到视窗右边的距离；rectObject.bottom:元素上边到视窗下边的距离；rectObject.left:元素上边到视窗左边的距离； getBoundingClientRect由于可以获取元素相对于当前屏幕的距离，所以可以判断当前元素是否在屏幕内，因此可以实现懒加载：1234567891011121314151617181920212223242526272829303132333435&lt;img src=&quot;&quot; alt=&quot;&quot; data-src=&quot;http://hdn.xnimg.cn/photos/hdn421/20170121/0000/h_main_D0cG_b0dc00061386195a.jpg&quot;&gt;&lt;script&gt;//绑定事件function bindEvent()&#123; document.addEventListener(&apos;scroll&apos;,lazyLoad,false);&#125;//判断当前元素是否在视窗内function ifIntoView(dom)&#123; var info=dom.getBoundingClientRect(); clientHeight=window.innerHeight; if(0&lt;info.top&amp;&amp;info.top&lt;clientHeight)&#123; showImage(dom); &#125;&#125;//显示图片function showImage(dom)&#123; //延时是为了展示懒加载效果 setTimeout(function()&#123; dom.setAttribute(&apos;src&apos;,dom.dataset.src) &#125;,500)&#125;function lazyLoad()&#123; var selectArray=Array.prototype.slice.call(document.querySlectorAll(&quot;img&quot;)); 将类数组对象变为数组 selectorArray.forEach(function(element,index)&#123; if(!element.getAttribute(&quot;src&quot;))&#123; ifIntoView(); &#125; &#125;)&#125;bindEvent();&lt;/script&gt; 如果直接将函数绑定到scroll事件上，当页面滚动时，函数会被高频触发，这非常影响浏览器的性能。可以通过限制触发频率，来优化性能。节流函数：只允许一个函数在N秒内执行一次。12345678910111213141516171819function throttle(fun,delay,time)&#123;//fun是要执行的函数，delay表示延迟，time指在time时间内必须执行一次 var timeout, startTime=new Date(); return funtion()&#123; var context=this, args=arhuments, curTime=new Date(); clearTimeout(timeout); //如果达到了时间间隔，触发handle if(curTime-startTime&gt;=time)&#123; fun.apply(context,args); startTime=curTime; &#125;//如果没达到触发时间间隔，重新设定定时器 else&#123; timeout=setTimeout(fun,delay); &#125; &#125; &#125;//所以，上面懒加载document.addEventListener(&apos;scroll&apos;,lazyLoad,false)里面的lazyLoad换成throttle(lazyLoad,500,1000); 另外还有两种懒加载的方式： jquery lazyload 123456789$(document).ready(function() &#123; $(&quot;img.lazy-load&quot;).lazyload(&#123; effect : &quot;fadeIn&quot;, //渐现，show(直接显示),fadeIn(淡入),slideDown(下拉) threshold : 180, //预加载，在图片距离屏幕180px时提前载入 event: &apos;click&apos;, // 事件触发时才加载，click(点击),mouseover(鼠标划过),sporty(运动的),默认为scroll（滑动） container: $(&quot;#container&quot;), // 指定对某容器中的图片实现效果 failure_limit：2 //加载2张可见区域外的图片,lazyload默认在找到第一张不在可见区域里的图片时则不再继续加载,但当HTML容器混乱的时候可能出现可见区域内图片并没加载出来的情况 &#125;); &#125;); 轻量级图片延时加载插件echo.js 1234Echo.init(&#123; offset: 0,//离可视区域多少像素的图片可以被加载 throttle: 0 //图片延时多少毫秒加载&#125;);","categories":[],"tags":[],"keywords":[]},{"title":"一些类似于null==0之类的判断","slug":"一些类似于null-0之类的判断","date":"2017-08-17T02:35:10.000Z","updated":"2017-08-17T03:10:19.725Z","comments":true,"path":"2017/08/17/一些类似于null-0之类的判断/","link":"","permalink":"https://aliceflaviawang.github.io/2017/08/17/一些类似于null-0之类的判断/","excerpt":"","text":"null==0 //flasenull&gt;=0（null&lt;=0） //true原因：关系运算符和相等运算符并不是一个类别的，关系运算符在设计上总是尝试转为一个number，而相等运算符并没有这方面的考虑。更进一步：关系运算符，是先算出原始值，如果两个都是String类型进行字符串比较，否则转换成Number，之后比较；相等运算符只在两数分别是String和Number类型或者其中之一为Boolean进行数字转换外，其他类型都不进行转换成数字。 所以：“”==0 //trueflase==0 //trueundefined==0 //flase ,Number(undefinded)是NaN []==![] //true这个实际上也是涉及==运算的规则，来个详细的首先[]==![]匹配的是规则7，会递归调用[]==ToNumber(flase)进行比较（！[]是false），9.3节定义了ToNumber原语，ToNumber(false)等于0，于是比较[]==0；此时采用规则9，比较ToPrimitive([])==0,ToPrimitive默认调用ToString方法，于是ToPrimitive([])等于””；现在就是比较””==0,按照规则5，比较ToNumber(“”)==0,ToNumber(“”)的结果是0，所以结果为true。","categories":[],"tags":[],"keywords":[]},{"title":"JS的堆栈及深浅拷贝","slug":"JS的堆栈及深浅拷贝","date":"2017-08-14T02:39:57.000Z","updated":"2017-08-14T08:25:58.801Z","comments":true,"path":"2017/08/14/JS的堆栈及深浅拷贝/","link":"","permalink":"https://aliceflaviawang.github.io/2017/08/14/JS的堆栈及深浅拷贝/","excerpt":"","text":"堆栈堆栈是两种数据结构，只能在一端对数据项进行插入和删除。 栈：由操作系统自动分配释放，存放函数的参数值，局部变量的值等。 堆：动态分配的空间一般由程序员分配释放，若程序员不释放，则程序释放时可能由OS回收。 JS中的堆栈与基本类型、引用类型js中的数据类型分为两种 ： 基本类型：undefined,bool,number,string,null，这5中基本数据类型可以直接访问，它们是按照值进行分配的，存放在栈内存中的简单数据段，数据大小确定，内存空间大小可以分配。 引用类型：存放在堆中的对象，变量实际保存的是一个指针，这个指针指向另一个位置。 浅拷贝基本类型的拷贝只是在内存中又开辟了新的空间，和它的父元素（称被拷贝的对象为父元素）互不相干，因此深浅拷贝是相对于引用类型的，以便于对引用类型父对象的保存。12345678910111213141516171819202122var father1=&#123;name:&apos;shanghai&apos;,age:1000,job:[&apos;teacher&apos;,cook]&#125;;//浅拷贝函数function copy(obj)&#123; var childs=&#123;&#125;; for(var key in obj)&#123; childs[key]=obj[key]; &#125; return childs;&#125;var child1=copy(father1);console.log(child1); //&#123;name:&apos;shanghai&apos;,age:1000,job:Array(2)&#125;console.log(typeof child1); //object//改变子对象的name属性，发现对父对象的name没有影响child1.name=&apos;chengdu&apos;;console.log(father1); //&#123;name:&apos;shanghai&apos;,age:1000,job:Array(2)&#125;console.log(child1); //&#123;name:&apos;chengdu&apos;,age:1000,job:Array(2)&#125;//注意：这次改变子对象的job属性也就是改变数组，发现对都对象的job受到了影响child1.job.push(&apos;programmer&apos;);console.log(father1) ;//&#123;name:&apos;shanghai&apos;,age:1000,job:[&apos;teacher&apos;,&apos;cook&apos;,&apos;programmer&apos;]&#125;console.log(child1) ;//&#123;name:&apos;chengdu&apos;,age:1000,job:[&apos;teacher&apos;,&apos;cook&apos;,&apos;programmer&apos;]&#125; 由上，浅拷贝的时候，子对象数组改变时父对象也跟着改变，说明子对象和父对象在浅拷贝的时候指向同一个内存的数组。 如果想让子对象拷贝和父对象没有关联，就必须使用深度拷贝。 深拷贝深拷贝就是父对象拷贝到子对象上，而且两者的内存和以后的操作都互不影响。1234567891011121314151617181920212223242526272829function deepCopy(obj)&#123; var o; switch(typeof obj)&#123; case &apos;undefined&apos;:break; case &apos;string&apos;:o=obj+&apos;&apos;;break; case &apos;number&apos;:o=obj-0;break; case &apos;boolean&apos;:o=obj;break; case &apos;object&apos;: if(obj===null)&#123; o=null; &#125;else&#123; if(obj instanceof Array)&#123; o =[]; for(var i=0,len=obj.length;i&lt;len;i++)&#123; o.push(deepCopy(obj[i])); &#125; &#125;else&#123; o=&#123;&#125;; for(var k in obj)&#123; o[k]=deepCopy(obj[k]); &#125; &#125; &#125; break; default: o=obj; break; &#125; return o;&#125;","categories":[],"tags":[],"keywords":[]},{"title":"JS异步编程","slug":"JS异步编程","date":"2017-08-14T01:51:34.000Z","updated":"2017-08-15T06:24:55.444Z","comments":true,"path":"2017/08/14/JS异步编程/","link":"","permalink":"https://aliceflaviawang.github.io/2017/08/14/JS异步编程/","excerpt":"","text":"ES6增加了Promise和Generator等解决办法。大致整理一下到ES6为止的JS异步解决方法及其优缺点。 setTimeout常用于：定时器，动画效果用法：setTimeout(func|code,delay) 缺点：不精准。比如，通过setTimeout设定了一个任务在10毫秒之后执行，但是在9毫秒之后，有一个任务占用了5毫秒的CPU时间片，再轮到定时器执行时，时间就已经过期了4毫秒。 事件监听任务执行不取决于代码的顺序，而取决于某个事件是否发生。用法：f1.on(‘done’,f2)优点：比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以去耦合，有利于实现模块化。缺点：整个程序都要变成事件驱动型，运行流程会变得不是很清晰。 回调函数js对异步编程的实现就是回调函数。所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，直接调用这个函数。 回调函数是实现JS异步的一种方法，并不是说回调函数就是异步的。只是我们用的大部分回调函数都是用于异步。 Promise对象Promise原理状态机一个Promise可以理解为一个状态机1234567891011121314const PENDING = 0const FULFILLED = 1const REJECTED = 2function Promise ()&#123; // 存储该 Promise 的状态信息 let state = PENDING // 存储 FULFILLED 或 REJECTED 时带来的数据 let value = null // 存储 then 或 done 时调用的成功或失败回调 var handlers = []&#125; 状态迁移指定状态机的状态后，可以实现基本的状态迁移功能，即fullfill和reject这两个用于改变状态的函数：12345678910111213141516171819202122232425const PEDNDING=0const FULFILLED=1const REJECTED=2function Promise()&#123; //存储Promise的状态信息 let state=PENDING //存储FULFILLED和REJECTED时带来的数据 let value=null //存储then或done时调用的成功或失败回调 let handlers=[] funtion fulfill(result)&#123; state=FULFILLED value=result &#125; function reject(error)&#123; state=REJECTED value=error &#125;&#125; 在此基础上需要实现一种更高级的状态迁移方式，这就是resolve123456789101112131415161718192021222324252627282930313233343536const PENDING = 0const FULFILLED = 1const REJECTED = 2function Promise ()&#123; // 存储该 Promise 的状态信息 let state = PENDING // 存储 FULFILLED 或 REJECTED 时带来的数据 let value = null // 存储 then 或 done 时调用的成功或失败回调 let handlers = [] function fulfill (result)&#123; state = FULFILLED value = result &#125; function reject (error)&#123; state = REJECTED value = error &#125; function resolve(result)&#123; try&#123; let then=getThen(result) if(then) &#123; //递归resolve，待解析的Promise ,doResolve(then.bind(result),resolve,reject) return &#125; fulfill(result) &#125;catch(e)&#123; reject(e) &#125; &#125; resolve既可以接收一个Promise，也可以接收一个基本类型。当resolve一个Promise时，就是用doResolve辅助函数来执行这个Promise并等待其完成。通过resolve隐藏了底层的fulfill接口。在这个过程中用到的辅助函数有：1234567891011121314151617181920212223242526272829303132/**检查一个值是否为Promise，若为Promise则返回该Promise的then方法*/function getThen(value)&#123; let t=typeof value if(value&amp;&amp;(t===&apos;object&apos;||t===&apos;function&apos;))&#123; const then=value.then //可能需要更负责的thenable判断 if(typeof then===&apos;function&apos;) return then &#125; return null &#125;/**传入一个需被resolve的函数，该函数可能存在不确定的行为*确保onFulfilled和onRejected只会被调用一次*在此不保证该函数一定会被异步执行*/function doResolve(fn,onFulfilled,onRejected)&#123; let done=false try&#123; fn(function(value)&#123; done=true //执行由resolve传入的resolve回调 onFulfilled(value) function(reason)&#123; if(done) return done=true onRejected(reason) &#125; &#125;) &#125;&#125; done接口到此形成了一个完整的状态机，但仍没有暴露一个合适的方法来观察其状态变更。最终目标是实现then，但是由于事先done接口容易一下，因此先实现done。下面的例子是要实现promise.done(onFulfilled,onRejected)，使得： onFulfilled与onRejected二者只有一个被调用 该接口只会被调用一次 该接口总是被异步执行 调用done的执行时机与调用时Promise是否已reoslevd无关123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869const PENDING = 0const FULFILLED = 1const REJECTED = 2function Promise (fn)&#123; // 存储该 Promise 的状态信息 let state = PENDING // 存储 FULFILLED 或 REJECTED 时带来的数据 let value = null // 存储 then 或 done 时调用的成功或失败回调 let handlers = [] function fulfill (result)&#123; state = FULFILLED handlers.forEach(handle) handlers = null &#125; function reject (error)&#123; state = REJECTED value = error handlers.forEach(handle) handlers = null &#125; function resolve (result)&#123; try &#123; let then = getThen(result) if (then) &#123; // 递归 resolve 待解析的 Promise doResolve(then.bind(result), resolve, reject) return &#125; fulfill(result) &#125; catch (e) &#123; reject(e) &#125; &#125; // 保证 done 中回调的执行 function handle (handler)&#123; if (state === PENDING) &#123; handlers.push(handler) &#125; else &#123; if (state === FULFILLED &amp;&amp; typeof handler.onFulfilled === &apos;function&apos;) &#123; handler.onFulfilled(value) &#125; if (state === REJECTED &amp;&amp; typeof handler.onRejected === &apos;function&apos;) &#123; handler.onRejected(value) &#125; &#125; &#125; this.done = function (onFulfilled, onRejected)&#123; // 保证 done 总是异步执行 setTimeout(function ()&#123; handle(&#123; onFulfilled: onFulfilled, onRejected: onRejected &#125;) &#125;, 0) &#125; doResolve(fn, resolve, reject)&#125; then方法12345678910111213141516171819202122this.then = function (onFulfilled, onRejected)&#123; const _this = this return new Promise(function (resolve, reject)&#123; return _this.done(function (result)&#123; if (typeof onFulfilled === &apos;function&apos;) &#123; try &#123; return resolve(onFulfilled(result)) &#125; catch (ex) &#123; return reject(ex) &#125; &#125; else return resolve(result) &#125;, function (error)&#123; if (typeof onRejected === &apos;function&apos;) &#123; try &#123; return resolve(onRejected(error)) &#125; catch (ex) &#123; return reject(ex) &#125; &#125; else return reject(error) &#125;) &#125;)&#125;","categories":[],"tags":[],"keywords":[]},{"title":"JS严格模式","slug":"JS严格模式","date":"2017-08-09T13:53:55.000Z","updated":"2017-08-09T14:56:07.914Z","comments":true,"path":"2017/08/09/JS严格模式/","link":"","permalink":"https://aliceflaviawang.github.io/2017/08/09/JS严格模式/","excerpt":"","text":"概述除了正常模式，ES5添加了第二种运行模式：“严格模式”。设立严格模式的目的： 消除JS语法的一些不合理、不严谨之处，减少一些怪异行为 消除代码运行的一些不安全之处，保证代码运行的安全 提供编译器效率，增加运行速度 为未来新版本的JS做好铺垫进入标志1&quot;use strict&quot; 如何调用针对单个脚本文件将”use strict”放在脚本文件的第一行，则整个脚本都将以“严格模式”运行，如果这行语句不在第一行，则无效，整个脚本以“正常模式”运行。1234567&lt;script&gt; &quot;use strict&quot; console.log(&quot;这是严格模式&quot;)&lt;/script&gt;&lt;script&gt; console.log(&quot;这是正常模式&quot;)&lt;/script&gt; 针对单个函数将”use strict”放在函数体的第一行，则整个函数以“严格模式”运行。12345678function strict()&#123; &quot;use strict&quot;; return &quot;这是严格模式。&quot;; &#125; function notStrict() &#123; return &quot;这是正常模式。&quot;; &#125; 脚本文件的变通写法第一种调用方法不利于文件合并，所以更好的做法是，借用第二种方法，将整个脚本文件放在一个立即执行的匿名函数之中。1234567(function ()&#123; &quot;use strict&quot;; // some code here &#125;)(); 语法和行为改变严格模式对JS的语法和行为，都做了一些改变。 1.全局变量显示声明在正常模式中，如果一个变量没有声明就赋值，默认是全局变量，严格模式禁止这种用法，全局变量必须显式声明，否则报错。 2.静态绑定JS允许“动态绑定”，即某些属性和方法到底属于哪个对象，不是在编译时确定，而是在运行时确定。严格模式对动态绑定做了一些限制，某些情况下，只允许静态绑定。也就是说，属性和方法到底归属于哪个对象，在编译阶段就确定，这样做有利于编译效率的提供，也使得代码更易读。具体涉及以下方面： 禁止使用with语句 因为with语句在编译时就无法确定，属性到底归属哪个对象 创设eval作用域 正常模式下，JS语言有两种变量作用域：全局作用域和函数作用域。严格模式下创设了第三种作用域：eval作用域。正常模式下，eval作用域，取决于它处于全局作用域，还是处于函数作用域。严格模式下，eval语句本身就是一个作用域，不能再生成全局变量了，它生成的变量只能用于eval内部。1234&quot;use strict&quot;var x=2;console.info(eval(&quot;var x=5;x&quot;)); //5console.info(x); //2 如果将var x=2去掉，console.info(x)将报错。 3.增加安全措施 禁止this关键字指向全局对象12345function f()&#123; &quot;use strict&quot; this.a=1;&#125;f();//报错，this未定义 执行f()时，this指向全局对象，严格模式下报错，使用构造函数var aa=new f()；aa.a则正常，此时this指向aa。 禁止在函数内部遍历栈123456function f1()&#123; &quot;use strict&quot; f1.caller;//报错 f1.arguments;//报错&#125;f1(); 4.禁止删除变量严格模式下无法删除变量。只有configurable为true时才能被删除。123456789101112&quot;use strict&quot;; var x; delete x; // 语法错误 var o = Object.create(null, &#123;&apos;x&apos;: &#123; value: 1, configurable: true &#125;&#125;); delete o.x; // 删除成功 5.显式报错正常模式下，对一个对象的只读属性进行赋值，不会报错，只会默默失败，严格模式下，将报错。1234567&quot;use strict&quot;; var o = &#123;&#125;; Object.defineProperty(o, &quot;v&quot;, &#123; value: 1, writable: false &#125;); o.v = 2; // 报错 6.重名错误 对象不能有重名的属性(经测试谷歌浏览不会报错，但是IE浏览器会报错）正常模式下，如果对象有多个重名的属性，最后赋值的那个属性会覆盖前面的值。严格模式下会报错。123456&quot;use strict&quot;; var o = &#123; p: 1, p: 2 &#125;; // 语法错误 2.函数不能有重名的参数1234567&quot;use strict&quot;; function f(a, a, b) &#123; // 语法错误 return ; &#125; 7.禁止八进制表示法正常模式下，整数的第一位如果是0，表示是八进制数，比如0100等于十进制的64。严格模式禁止这种表达方式，整数第一位为0会报错。 8.arguments对象的限制1.不允许对arguments赋值2.不再追踪参数的变化123456789101112131415161718192021function f(a) &#123; a = 2; return [a, arguments[0]]; &#125; f(1); // 正常模式为[2,2] function f(a) &#123; &quot;use strict&quot;; a = 2; return [a, arguments[0]]; &#125; f(1); // 严格模式为[2,1] 禁止使用arguments.callee这意味着，无法在匿名函数内部调用自身了1234 &quot;use strict&quot;; var f = function() &#123; return arguments.callee; &#125;; f(); // 报错 9.函数声明必须在顶层(经测试IE10以上及谷歌浏览器取消了这个)JS的新版本引入块级作用域，为了与新版本接轨，严格模式只允许在全局作用域或函数作用域的顶层声明函数。也就是说，不允许在非函数的代码块内声明函数。1234567&quot;use strict&quot;; if (true) &#123; function f() &#123; &#125; // IE10及以下报错 &#125; 10.保留字为了向将来Javascript的新版本过渡，严格模式新增了一些保留字：implements, interface, let, package, private, protected, public, static, yield。 使用这些词作为变量名将会报错。 此外，ECMAscript第五版本身还规定了另一些保留字（class, enum, export, extends, import, super），以及各大浏览器自行增加的const保留字，也是不能作为变量名的。","categories":[],"tags":[],"keywords":[]},{"title":"箭头函数","slug":"箭头函数","date":"2017-08-09T12:10:13.000Z","updated":"2017-08-09T13:47:57.638Z","comments":true,"path":"2017/08/09/箭头函数/","link":"","permalink":"https://aliceflaviawang.github.io/2017/08/09/箭头函数/","excerpt":"","text":"基本用法ES6允许使用“箭头”定义函数1var f= v =&gt; v; 上面的箭头函数等同于：123var f = function(v)&#123; return v;&#125; 如果箭头函数不需要参数或者需要多个参数，就使用一个圆括号代表参数部分。1var sum=(num1,num2) =&gt; num1+num2; 如果箭头函数的代码部门多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。1var sum=(num1,num2) =&gt; &#123;return num1+num2; &#125; 由于大括号被解释为代码块，如果箭头函数直接返回一个对象，必须在对象外面加上括号。1var getTempItem =id =&gt; (&#123;id:id,name:&quot;Temp&quot;&#125;) 箭头函数可以与变量结构结合使用1const full=(&#123;first,last&#125;) =&gt; first+&apos; &apos;+last; 使用注意点 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象 不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误 不可以使用arguments对象，该对象在函数体内不存在，如果要用，可以用Rest参数代替 不可以使用yield命令，因为箭头函数不能用作Generator函数 this指向固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正因为它没有this，所以也就不能用作构造函数。 除了this以外，以下三个变量在箭头函数中也是不存在的，指向外层函数的对应变量：arguments、super、new.target。1234567function foo()&#123; setTimeout(() =&gt; &#123; console.log(&apos;args:&apos;, arguments); &#125;, 100);&#125;foo(2,4,6,8)//[2,4,6,8] 注意此处箭头函数内部的变量arguments，是函数foo的arguments变量，因为foo是普通函数，具有arguments。如果将function foo(){}换成var foo=()=&gt;{}，将会报arguments is undefined的错。使用rest参数代替arguments：123456var foo=(...numbers)=&gt;&#123;setTimeout(() =&gt; &#123; console.log(&apos;args:&apos;, numbers); &#125;, 100);&#125;foo(2,4,6,8) 另外，由于箭头函数没有自己的this，所以当然也就不能用call,apply,bind这些方法改变this的指向。123456(function()&#123; return [ (()=&gt;this.x).bind(&#123;x:&apos;inner&apos;&#125;)() ]&#125;).call(&#123;x:&apos;outer&apos;&#125;)//outer 箭头函数没有自己的this，所以bind方法无效，内部的this指向外部的this，相当于：123456var x=&apos;outer&apos;;(function() &#123; return [ (() =&gt; this.x).bind(&#123; x: &apos;inner&apos; &#125;)() ]; &#125;)(); 函数绑定箭头函数可以绑定this对象，大大减少了显式绑定this对象的写法（call、bind、apply）。但是很多场合不适用，于是ES7提出了”函数绑定”运算符来取代call、bind、apply调用。函数绑定运算符是并排两个双冒号(::)，双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（this对象），绑定到右边的函数上面。1234567foo::bar//等同于bar.bind(foo)foo:bar(...arguments)//等同于bar.apply(foo,arguments) 如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定到该对象上面。123let log=::console.log//等同于var log=console.log.bind(console)","categories":[],"tags":[],"keywords":[]},{"title":"ES6箭头函数的this与普通函数的this对比","slug":"ES6箭头函数的this与普通函数的this对比","date":"2017-08-09T03:16:19.000Z","updated":"2017-08-09T09:26:32.764Z","comments":true,"path":"2017/08/09/ES6箭头函数的this与普通函数的this对比/","link":"","permalink":"https://aliceflaviawang.github.io/2017/08/09/ES6箭头函数的this与普通函数的this对比/","excerpt":"","text":"普通函数中的this有以下几种情况 this总是代表它的直接调用者，例如obj.func，那么func中的this就是obj 在默认情况（非严格模式下，未使用’use strict’），没找到直接调用者，则this指向window 1234567891011var obj=&#123; func:function()&#123;&#125;, say:function()&#123; var that=this; setTimeout(function()&#123; console.log(this) //window that.func() &#125;); &#125;&#125;obj.say(); 匿名函数、定时器中的函数，由于没有默认的宿主对象，所以默认指向window。如果想使用这个对象的引用，通常是使用一个变量提前把正确的this引用保存起来，我们通常使用that=this或者_this=this来保存我们需要的this指针。12345678910111213window.val=1;var obj=&#123; val:2, dbl:function()&#123; this.val*=2; val*=2; console.log(val); console.log(this.val); &#125;&#125;;obj.dbl();var func=obj.dbl;func(); 结果：2 4 8 8val变量在没有指定对象前缀，默认从函数中找，找不到则从window中找全局变量，即val=2就是window.val=2,this.val默认指的是obj.val(因为dbl()第一次被obj直接调用)。func()没有任何前缀，类似于全局函数，即window.func调用，所以第二次调用的时候，this指的是window，val指的是window.val，obj.dbl()使得window.val的结果变成了2，this.val和val都是指向全局的val，因此this.val2使得全局的val变成了4，再val2使其变为8，最后val和this.val就都等于8。 在严格模式下，没有直接调用者的函数中的this是undefined 12345function test()&#123; &apos;use strict&apos;; console.log(this);&#125;test(); //undefined 使用call、apply、bind绑定的，this指向绑定的对象 箭头函数中的this默认指向在定义它时它所处的对象，而不是执行时的对象，定义它的时候，可能环境是window。箭头函数根本就没有绑定自己的this，实际上箭头函数中调用this是沿着作用域链向上寻找，找到最近的一个this拿来使用。12345678var obj=&#123; say:function()&#123; setTimeout(() =&gt; &#123; console.log(this); &#125;) &#125;&#125;obj.say(); //obj 此时this是定义它的对象，最近的this就是obj而不是window。1234567891011var obj=&#123; say:function()&#123; var f1=() =&gt; &#123; console.log(this); //obj setTimeout(() =&gt; &#123; console.log(this); //obj &#125;) &#125; f1(); &#125;&#125; f1最近的作用域的this就是obj，不管f1有几层嵌套，都是obj。123456789101112var obj=&#123; say:function()&#123; var f1=function()&#123; console.log(this); //window setTimeout(() =&gt; &#123; console.log(this); //window &#125;) &#125; f1(); &#125;&#125;obj.say(); 第一个this:f1调用时，this指向window对象第二个this：找到最近的作用域的this即f1的this，f1的this指向window","categories":[],"tags":[],"keywords":[]},{"title":"DNS解析","slug":"DNS解析","date":"2017-08-01T14:03:18.000Z","updated":"2017-08-01T14:27:51.148Z","comments":true,"path":"2017/08/01/DNS解析/","link":"","permalink":"https://aliceflaviawang.github.io/2017/08/01/DNS解析/","excerpt":"","text":"由来：IP地址由21位二进制数字组成，用户与因特网上某台主机通信，32位的IP地址显然很难记忆，因此使用比较容易记忆的主机名字（域名）。但是域名长度不固定，机器处理比较困难，而IP地址长度固定，因此处理数据报时用的IP地址。 解析过程：当某一个应用需要把主机名解析为IP地址时，该应用进程就调用解析程序，并成为DNS的一个客户，把待解析的域名放在DNS请求报文中，以UDP用户数据报方式发送给本地域名服务器。本地域名服务器在查找域名后，把对应的IP地址放在回答报文中返回。应用程序获得目的主机的IP地址后即可进行通信。 具体的解析过程： 主机向本地域名服务器的查询一般都是采用递归查询。所谓递归查询是:如果主机所询问的本地域名服务器不知道被查询的域名的IP地址，那么本地域名服务器就以DNS客户的身份，向其他根域名服务器继续发出查询请求报文（即替主机继续查询），而不是让主机自己进行下一步查询。因此，递归查询返回的查询结果或者是所要查询的IP地址，或者是报错，表示无法查询到所需的IP地址。 本地域名服务器向根域名服务器的查询是迭代查询。迭代查询：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的IP地址，要么告诉本地服务器下一步向哪个域名服务器进行查询。然后本地服务器进行后续查询。根域名服务器通常是把自己知道的顶级域名服务器的IP地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询。","categories":[],"tags":[],"keywords":[]},{"title":"for...of的优势","slug":"for-of的优势","date":"2017-08-01T06:51:45.000Z","updated":"2017-08-01T07:18:12.512Z","comments":true,"path":"2017/08/01/for-of的优势/","link":"","permalink":"https://aliceflaviawang.github.io/2017/08/01/for-of的优势/","excerpt":"","text":"以数组为例，js提供了多种遍历语法。 最原始的是for循环。123for(var index=0;index&lt;arr.length;index++)&#123; console.log(arr[index]);&#125; 这种写法比较麻烦，于是数组提供内置的forEach方法。123arr.forEach(function(value)&#123; console.log(value);&#125;) forEach的缺点在于中途无法退回出forEach循环，break命令或return命令无法生效。 for…in循环可以遍历数组的键名。123for(var index in arr)&#123; console.log(arr[index]);&#125; for…in循环的缺点： 数组的键名是数字，但是for…in循环是以字符串作为键名，如”0”,”1”等； for…in循环不仅遍历数字键名，还会遍历手动添加其他的键，甚至包括原型链上的键； 某些情况下，for…in循环会以任意顺序遍历键名。for…in循环主要是为了遍历对象而设计的，不适用于遍历数组。 for…of循环相比上面几种做法的有点，有一些显著的优点。 有着同for…in一样简洁语法，但是没有for…in那些缺点； 不同于forEach方法，它可以与break、continue、return配合使用 提供了遍历所有数据结构的统一操作接口。12345for(var n of fibonacci)&#123; if(n&gt;1000) break; console.log(n);&#125; 注：ES6引入for…of作为遍历所有数据结构的统一的方法。一个数据结构只要部署了Symbol.iterator属性，就被视为具有iterable接口，就可以用for…of循环遍历它的成员。for…of可以使用的范围包括数组、Set和Map、类数组的对象、Generator对象以及字符串。","categories":[],"tags":[],"keywords":[]},{"title":"Promise","slug":"Promise","date":"2017-07-31T01:33:29.000Z","updated":"2017-08-01T07:46:02.026Z","comments":true,"path":"2017/07/31/Promise/","link":"","permalink":"https://aliceflaviawang.github.io/2017/07/31/Promise/","excerpt":"","text":"Promise含义Promise是一种异步编程的解决方案，比传统的回调函数和事件更合理和更强大。Promise简单来说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上来说，Promise是一个对象，从它可以获取异步操作的消息。 Promise对象有一下两个特点： 对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：Pending(进行中)、Resolved(已完成，或者Fullfilled)、Rejected(已失败)。只有异步操作能决定当前是哪一种状态，任何其他操作都无法改变这个状态。 一旦状态改变，就不会变，任何时候都可以得到这个结果。Promise对象状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只要这两种情况发生，状态就不会再变了。如果改变已经发生，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。 Promise的优点和缺点： 优点：将异步操作以同步流程表达出来，避免层层嵌套的回调函数；另外Promise对象提供统一的接口，使得异步操作更加容易。 缺点：无法取消Promise，一旦新建它就会立即执行，无法中途取消；其次如果不设置回调函数，Promise内部抛出的错误，不会反应到外部；第三当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。 基本用法1234567var promise=new Promise(function(resolve,reject)&#123; if(/*异步操作成功*/)&#123; resolve(value); &#125;else&#123; reject(error); &#125;&#125;) resolve和reject是两个函数，由JS引擎提供。resolve将Promise的状态从Pending变为Resolved，在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject将状态由Pending变为Rejected，在异步操作失败时调用，并将异步操作报出的错误作为参数传递出去。 Promise实例生成之后，可以用then方法分别指定Resolved状态和Rejected状态的回调函数。12345promise.then(function(value)&#123; //success&#125;,function(error)&#123; //error&#125;) Promise.prototype.then()then方法是定义在原型对象Promise.prototype上的，then方法的第一个参数是Resolved状态的回调函数，第二个参数是Rejected状态的回调函数。 then方法返回的是一个新的Promise实例，因此可以采用链式写法，即then方法后面再调用另一个then方法（第一个回调函数完成后会将结果作为参数，传入第二个回调函数）。 Promise.prototype.catch()Promise.prototype.catch方法是.then(null,rejection)的别名，用于指定错误发生时的回调函数。123p.then((val)=&gt;console.log(&apos;fullfilled:&apos;,val)).catch((err)=&gt; console.log(&apos;rejected&apos;,err));等同于p.then((val)=&gt;console.log(&apos;fullfilled:&apos;,val)).then(null,(err)=&gt;console.log(&apos;rejected&apos;,err)) Promise.all()Promise.all将多个Promise实例，包装成一个新的Promise实例。参数可以不是数组，但必须具有Iterator接口，且返回的每个成员都是Promise实例。1var p=Promise.all([p1,p2,p3]); p的状态取决于p1、p2、p3，分成两种情况： 只有p1、p2、p3的状态都变成fullfilled，p的状态才会变成fullfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。 只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被rejected的实例的返回值，会传递给p的回调函数。123456789// 生成一个Promise对象的数组var promises = [2, 3, 5, 7, 11, 13].map(function (id) &#123; return getJSON(&apos;/post/&apos; + id + &quot;.json&quot;);&#125;);Promise.all(promise).then(function(posts)&#123;//...&#125;).catch(function(reason)&#123;//...&#125;) Promise.race()Promise.race方法同样是将多个Promise实例，包装成一个新的Promise实例。1var promise=new Promise.race([p1,p2,p3]) p1,p2,p3只要有一个状态改变，p的状态就跟着改变。那个率先改变的Promise实例的返回值，就传给p的回调函数。 Promise.resolve()Promise.resolve方法可以将现有对象转为Promise对象。Promise.resolve方法的参数分为四种情况 参数是一个Promise实例如果参数是Promise实例，Promise.resolve将不做任何修改原封不动的返回这个实例 参数是一个thenable对象thenable对象指的是具有then方法的对象，Promise.resolve会将这个对象转为Promise对象，然后立即执行thenable对象的then方法。 123456789let thenable=&#123; then: function(resolve,reject)&#123; resolve(42); &#125;&#125;let p1=Promise.resolve(thenable);p1.then(function(value)&#123; console.log(value); //42&#125;) 参数不是具有then方法的对象，或者根本不是对象如果参数是一个原始值，或者一个不具有then方法的对象，则Promise.resolve方法返回一个新的Promise对象，状态为Resolved。 1234var p=Promise.resolve(&apos;Hello&apos;);p.then(function(s)&#123; console.log(s); //Hello&#125;) 不带有任何参数Promise.resolve方法允许调用时不带参数，直接返回一个Resolved状态的Promise对象。 需要注意的是，立即resolve的Promise对象，实在本轮”事件循环（event loop）”结束时，而不是在下一轮”事件循环”开始时。12345678910setTimeout(function()&#123; console.log(&apos;three&apos;);&#125;,0);Promise.resolve().then(function()&#123; console.log(&apos;two&apos;);&#125;)console.log(&apos;one&apos;);//one//two//three setTimeout(fn,0)是在下一轮“事件循环”开始时执行，Promise.resolve()在本轮“时间循环”结束时执行，而console.log(‘one’)立即执行。 Promise.reject()Promise.reject(reason)方法也会返回一个新的Promise实例，该实例的状态为rejected。123456var p=Promise.reject(&apos;出错了&apos;);//等同于var p=new Promise(resolve,reject)=&gt;reject(&quot;出错了&quot;);p.then(null,function(s)&#123; console.log(s);&#125;) 额外提供的两个方法 done()Promise对象的回调链，不管是以then方法还是catch方法结尾，要是最后一个方法抛出错误，都有可能无法捕捉到（因为Promise内部的错误不会冒泡到全局）。因此提供done方法，总是处于回调链的尾端，保证抛出任何可能的错误。12345ayncFunc() .then(f1) .catch(r1) .then(f2) .done(); done方法的实现1234567Promise.prototype.done=function(onFulfilled,onRejected)&#123; this.then(onFulfilled,onRejected) .catch(function(reason)&#123; //抛出一个全局错误 setTimeout(()=&gt;&#123; throw reason&#125;,0); &#125;)&#125; finally()finally方法用于指定不管Promise对象的最后状态如何，都会执行的操作，它与done方法最大的区别，它接收一个普通的回调函数作为参数，该函数不管怎样都必须执行。它的实现：1234567Promise.prototype.finally=function(callback)&#123; let P=this.constructor; return this.then( value =&gt; P.resolve(callback()).then(()=&gt;value), reason =&gt; P.resolve(callback()).then(()=&gt;&#123;throw reason&#125;) ); &#125;; Promise.try()实际开发中：不知道或者不想区分，函数f是同步还是异步操作，但是想用Promise来处理。这样不管f是同步还是异步操作，都用then方法指定下一步流程，用catch方法来处理f抛出的错误。12345const f=()=&gt;console.log(&quot;now&quot;);Promise.resolve().then(f);console.log(&quot;next&quot;);//next//now 上面写法的一个缺点，如果f是同步函数，那么它会在本轮事件循环的末尾执行。上面函数f是同步的，经过Promise包装之后就变成异步执行了。 现在想让同步函数同步执行，异步函数异步执行，有两种方法： async函数12345const f=()=&gt;console.log(&apos;now&apos;);(async ()=&gt;f())();console.log(&apos;next&apos;);//now//next 上面第二行是一个立即执行的匿名函数，会立即执行里面的async函数，因此f是同步的，就会得到同步的结果；如果f是异步的，就可以用then指定下一步。（注意async ()=&gt;f()会吃掉f()抛出的错误，如果响应抛出错误，要使用Promise.catch方法。（async ()=&gt;f())().then(…).catch()）。 new Promise()123456789const f=()=&gt;console.log(&apos;now&apos;);( ()=&gt;new Promise( resolve=&gt;resolve(f) ))();console.log(&apos;next&apos;);//now//next 上面也是使用匿名函数，执行new Promise()。 基于上面的需求，提供了Promise.try方法替代了上面的写法。12345const f=()=&gt;console.log(&apos;now&apos;);Promise.try(f);console.log(&apos;next&apos;);//now //next","categories":[],"tags":[],"keywords":[]},{"title":"猜数游戏","slug":"猜数游戏","date":"2017-07-29T08:44:01.000Z","updated":"2017-07-29T09:29:45.325Z","comments":true,"path":"2017/07/29/猜数游戏/","link":"","permalink":"https://aliceflaviawang.github.io/2017/07/29/猜数游戏/","excerpt":"","text":"牛客上的猜数题，分析过程非常有意思，记录一下。12345678牛牛和羊羊在玩一个有趣的猜数游戏。在这个游戏中,牛牛玩家选择一个正整数,羊羊根据已给的提示猜这个数字。第i个提示是&quot;Y&quot;或者&quot;N&quot;,表示牛牛选择的数是否是i的倍数。例如,如果提示是&quot;YYNYY&quot;,它表示这个数使1,2,4,5的倍数,但不是3的倍数。注意到一些提示会出现错误。例如: 提示&quot;NYYY&quot;是错误的,因为所有的整数都是1的倍数,所以起始元素肯定不会是&quot;N&quot;。此外,例如&quot;YNNY&quot;的提示也是错误的,因为结果不可能是4的倍数但不是2的倍数。现在给出一个整数n,表示已给的提示的长度。请计算出长度为n的合法的提示的个数。例如 n = 5:合法的提示有:YNNNN YNNNY YNYNN YNYNY YYNNN YYNNYYYNYN YYNYY YYYNN YYYNY YYYYN YYYYY所以输出12 输入描述:输入包括一个整数n(1 ≤ n ≤ 10^6),表示已给提示的长度。输出描述:输出一个整数,表示合法的提示个数。因为答案可能会很大,所以输出对于1000000007的模输入例子1:5输出例子1:12 分析：首先看有几种可能： 如果第i个数是素数，前面除了1没有能除尽的，所以i有Y和N两种可能 如果第i个数是素数的幂次，比如输入的是12，那么其中2、4、8是素数2的幂次，分析下2、4、8，有YYY、NNN、YNN、YYN四种可能，3、9是素数3的幂次，有YY、NN、YN两种可能…总结规律得出如果有n个幂次，就有n+1种可能的情况。 如果第i个数不是素数的幂次，比如6、10，可以发现，6取决于2、3，如果2、3为YY，6必然为Y，其他情况都为N，也就是6、10这种并非素数的幂次的数并不影响可能的情况 因此，只需要考虑素数幂次的个数（素数是特殊的幂次即一次幂，如果有n个幂次，就有n+1种可能）。对12来说：有43222种可能，对应的分别是（2、4、8）、（3、9）、（5）、（7）、（9）.代码如下：123456789101112131415161718192021function count(n)&#123; var mod=Math.pow(10,9)+7; //防止答案过大，输出对于1000000007的模 var ans=1;//结果 var arr=[];//定义布尔数组 for(var i=2;i&lt;=n;i++)&#123; var count=0; //统计幂次 //找出素数 if(arr[i]) continue; for(var j=i+i;j&lt;=n;j+=i)&#123; arr[j]=true; &#125; var mi=i; while(mi&lt;=n)&#123; count++; mi*=i; &#125; ans=ans*(count+1)%mod; &#125; console.log(ans);&#125;","categories":[],"tags":[],"keywords":[]},{"title":"ORACLE导入dmp文件详解","slug":"ORACLE导入dmp文件详解","date":"2017-07-27T02:19:16.000Z","updated":"2017-09-07T02:13:09.190Z","comments":true,"path":"2017/07/27/ORACLE导入dmp文件详解/","link":"","permalink":"https://aliceflaviawang.github.io/2017/07/27/ORACLE导入dmp文件详解/","excerpt":"","text":"折腾了一天终于导入成功并查看到了，决定写个教程。准备：下载oracle 11g和pl/sql developer，我使用的是64位，据说用32位可能错误要少一点。 安装oracle 11g这个比较简单，百度上很多教程如：http://www.cnblogs.com/qfb620/p/4577255.html。 需要注意的是这一步不要填电子邮件，否则会报连接错误这一步填写口令的时候主要开头不要是数字，否则安装完会报错（但是不确定有没有影响） 安装完成后修改用户名和密码在控制台用sqlplus / as sysdba登陆oracle系统使用命令修改用户名密码alter user 用户名 indentified by “密码” 打开pl/sql developer初始打开时用户名和密码为第2步修改的用户名和密码，数据库是“ip/数据库名（默认是orcl）” 点击登录，报错解决办法：在未登陆的情况下进入pl/sql，在工具-&gt;首选项-&gt;连接里面设置Oracle主目录名和OCI库（其中Oracle主目录在Oracle安装目录下，OCI在安装目录的BIN目录下） 再次登陆，依然报错，原因是无法load BIN目录下的oci.dll文件解决办法： 在这个地址http://download.csdn.NET/detail/shenkxiao/4181424下载包含oci.dll文件包，解压到&quot;D:\\Program Files\\”下，然后将上一步OCI目录改成”D:\\Program Files\\instantclient_10_2\\instantclient_10_2\\oci.dll”。 重新登陆，发现出现了“连接为”这一项，并且自动出现了用户名和数据库地址，点击出现了”Oracle client ORA-12541: TNS:no listener [closed]”错误。解决办法：首先找到Oracle安装目录下的listener.ora和tnsnames.ora(我的是在E:\\app\\Alice\\product\\11.2.0\\dbhome_1\\NETWORK\\ADMIN下)，将host=localhost改成host=ip然后重启Oracle服务，WinKey+r 再次打开pl/sql，点击确定登录成功 导入dmp文件打开工具-&gt;导入表-&gt;Oracle导入（dmp文件选择Oacle导入）在“导入可执行文件”栏填入的是可执行的文件，比如Oracle安装目录的BIN目录下的imp.exe文件（我的地址是”E:\\app\\Alice\\product\\11.2.0\\dbhome_1\\BIN\\imp.exe”），导入文件就是你要导入的dmp文件的地址。 导入成功，下方会有提示 点击左侧的Table的项，刷新，可以看到导入的表，然后右键编辑表可以看到新导入的表结构 此时你可能会发现表里有些乱码，解决办法是：新建环境变量NLS_LANG，值为SIMPLIFIE DCHINESE_CHINA.ZHS16GBK，保存后重启pl/sql，如果还是乱码，则将环境变量值改为AMERICAN_AMERICA.ZHS16GBK（我将值改为AMERICAN_AMERICA.ZHS16GBK才成功）。 至此，Oracle安装、导入及查看dmp文件过程完成。 补充(修改用户名密码)Ip地址换了之后，需要修改安装环境下的tnsnames.ora和listener.ora两个文件里的ip；另外过一段时间用户名密码可能会失效，因此需要修改。（注意每条命令后要加;） 打开命令提示符，输入命令sqlplus/nolog，进入oracle控制台，并输入conn/as sysdba;以DBA角色进入。 连接成功后，输入”select username from dba_users;”查看用户列表 修改用户密码“alter user 用户名 identified by 新密码;” 看是否能连接上数据库“conn 用户名/新密码;”","categories":[],"tags":[],"keywords":[]},{"title":"尾递归","slug":"尾递归","date":"2017-07-24T07:59:48.000Z","updated":"2017-07-24T13:49:17.787Z","comments":true,"path":"2017/07/24/尾递归/","link":"","permalink":"https://aliceflaviawang.github.io/2017/07/24/尾递归/","excerpt":"","text":"函数调用自身，成为递归。如果尾调用自身，就称为尾递归。 递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误（出自阮一峰ECMAScript6入门，但是亲测尾递归还是会出现栈溢出，只不过情况要比普通的递归情况好很多）。 举个例子：123456function factorial(n)&#123; if(n===1) return 1; return n*factorial(n-1);&#125;factorial(5)&#125; 上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度O(n)。如果改成尾递归，只保留一个调用记录，复杂度O(1)。12345function factorial(n,total)&#123; if(n&lt;=1) return total; return factorial(n-1,n*toatl);&#125;factorial(5,1) 非常经典的例子，Fibonacci数列：1234567function Fibonacci(n)&#123; if(n&lt;=1)&#123;return 1&#125;; return Fibonacci(n-1)+Fibonacci(n-2);&#125;Fibonacci(10); //89Fibonacci(100); //堆栈溢出Fibonacci(1000); //堆栈溢出 如果将其改为尾递归实现：1234567function Fibonacci(n,ac1=1,ac2=1)&#123; if(n&lt;=1)&#123;return ac2&#125;; return Fibonacci(n-1,ac2,ac1+ac2);&#125;Fibonacci(100) //573147844013817200000Fibonacci(1000) //7.0330367711422765e+208Fibonacci(10000) //栈溢出 递归函数的改写尾递归的实现往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。有两种方法可以解决： 在尾递归之外，再提供一个正常行驶的函数。 12345678funtion tailFactorial(n,total)&#123; if(n===1) return total; return tailFactorial(n-1,n*total);&#125;function factorial(n)&#123; tailFactorial(n,1)&#125;factorial(5); 采用ES6的函数默认值 12345function factorial(n,toatl=1)&#123; if(n===1) return toatl; return factorial(n-1,n*total);&#125;factorial(5); 递归本质上是一种循环操作，循环可以用递归代替，而一旦使用递归，最好使用尾递归。","categories":[],"tags":[],"keywords":[]},{"title":"inline-block和float的区别","slug":"inline-block和float的区别","date":"2017-07-17T05:38:48.000Z","updated":"2017-07-17T05:59:31.968Z","comments":true,"path":"2017/07/17/inline-block和float的区别/","link":"","permalink":"https://aliceflaviawang.github.io/2017/07/17/inline-block和float的区别/","excerpt":"","text":"inline-block:块状内联元素。inline属性使元素内联展示，内联设置宽度无效，相邻的inline元素会在一行显示不换行，直到本行排满为止。block元素始终会独占一行，呈块状显示，可设置宽高。inline-block让元素容器属性为block，内容为inline。 float：设置元素浮动时，相邻元素会根据自身大小，排满一行，如果父容器宽度不够则换行。浮动元素脱离了文档流，相邻元素会呈现环绕状排列。 共同点：都能实现元素在一行显示，并且可以自由设置元素大小 区别：inline-block：水平排列一行，即使元素高度不一，也会以最大元素高度为行高，即使高度小的元素周围留空，也不会有第二行元素上浮补位（inline-block仍在文档流里，减少了程序对DOM的更改操作，因为DOM的每一次更改，浏览器会重绘DOM树）float：让元素脱离文档流，呈环绕状排列，如遇上行有空白，而当前元素的大小可以挤进去，这个元素会在上行补位排列","categories":[],"tags":[],"keywords":[]},{"title":"http头：Expires,Cache-Control,Last-Modified,ETag","slug":"http头：Expires-Cache-Control-Last-Modified-ETag","date":"2017-07-17T02:01:46.000Z","updated":"2017-08-21T09:12:02.342Z","comments":true,"path":"2017/07/17/http头：Expires-Cache-Control-Last-Modified-ETag/","link":"","permalink":"https://aliceflaviawang.github.io/2017/07/17/http头：Expires-Cache-Control-Last-Modified-ETag/","excerpt":"","text":"缓存分为很多种：服务器缓存，第三方缓存，浏览器缓存。其中浏览器缓存是代价最小的，因为浏览器缓存依赖客户端，而且几乎不耗费服务器端资源。 HTTP报文HTTP报文就是浏览器和服务器间通信时发送及响应的数据块。浏览器向服务器请求数据，发送请求（request）报文；服务器向浏览器返回数据，返回响应（response）报文。报文信息主要分为两部分： 包含属性的首部（header）：附加信息（cookie，缓存信息等）与缓存相关的规则信息，均包含在header中 包含数据的主体部分（body）：HTTP请求真正想要传输的部分。 缓存规则解析在客户端第一次请求数据时，此时缓存数据库中没有对应的缓存数据，需要请求服务器，服务器返回后，将数据缓存到缓存数据库中。HTTP缓存有多种规则，根据是否需要重新向服务器发起请求来分类，这里将其分为两大类(强制缓存，对比缓存)：可以看出，强制缓存如果生效，不需要再和服务器发生交互，而对比缓存不管是否生效，都需要与服务端发生交互，两类缓存规则可以同时存在，强制缓存优先级高于对比缓存，也就是说，当执行强制缓存的规则时，如果缓存生效，直接使用缓存，不再执行对比缓存规则。 强制缓存强制缓存，响应的header中有两个字段来标明失效规则（Expires/Cache-Control）。 ExpiresExpires的值为服务端返回到期的时间，即下一次请求时，请求时间小于服务端返回的到期时间，直接使用缓存数据。但是由于到期时间是服务器端生成的，客户端时间可能跟服务端时间有误差，这就会导致缓存命中的误差。所以HTTP1.1中用Cache-Control代替。 Cache-ControlCache-Control是最重要的规则。常见的取值有private、public、no-cache、no-store，默认是private。private： 客户端可以缓存public： 客户端和服务器端都可缓存max-age=xxx: 缓存的内容在xxx秒后失效no-cache: 需要对比缓存来验证缓存数据no-store: 所有内容都不会缓存，强制缓存、对比缓存都不会触发 对比缓存需要判断是否可以使用缓存。浏览器第一次请求数据时，服务器会将缓存标识与数据一起返回给客户端，客户端将二者备份至缓存数据库中。再次请求数据时，客户端将备份的缓存标识发送给服务器，服务器根据缓存标识进行判断，判断成功后，返回304状态码，通知客户端比较成功，可以使用缓存数据。可以看到，在对比缓存生效时，状态码为304，并且报文大小和请求时间大大减少，原因是，服务端进行标识之后，只返回header部分，通过状态码通知客户端使用缓存，不再需要将报文主体部分返回给客户端。 Last-Modified服务器在响应第一次请求时，告诉浏览器资源的最后修改时间If-Modified-Since:再次请求时，通过此字段通知服务器上次请求时，服务器返回资源的最后修改时间。服务器收到请求后发现有头If-Modified-Since，则与被请求资源的最后修改时间进行对比。若资源的最后修改时间大于If-Modified-Since,说明资源又被改动过，则响应整片资源内容，返回状态码200;若资源的最后修改时间小于或者等于If-Modified-Since，说明资源无新修改，则响应HTTP 304，告知游览器继续使用所保存的cache。 Etag/If-None-Match(优先级高于Last-Modified/If-Modified-Since)Etag:服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）。 If-None-Match:再次请求服务器时，通过此字段通知服务器客户端缓存数据的唯一标识。服务器收到请求发现头部有If-None-Match，则与被请求资源的唯一标识进行对比不同，说明资源又被改动过，则响应整片资源内容，返回状态码200；相同，说明资源无新修改，则响应HTTP 304，告知浏览器继续使用所保存的cache。 总结对于强制缓存，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，不在时间内，执行比较缓存策略。对于比较缓存，将缓存信息中的Etag和Last-Modified通过请求发送给服务器，由于服务器校验，返回304状态码时，浏览器直接缓存。 这篇文章写的非常好，来自http://www.cnblogs.com/chenqf/p/6386163.html，下面是之前写的（调理没有上面的清晰）。 1. Expires（过期时间）Http头信息Expire属性是Http控制缓存的基本手段，这个属性告诉缓存器：相关副本在多长时间内是新鲜的。 缺点： 客户端与服务器时间不同步导致Expire的配置出现问题 很容易在配置后忘记具体的过期时间，导致过期来临出现浪涌现象 2. Cache-Control（缓存控制） Http头信息Cache-Control让网站发布者可以更全面的控制他们的内容，并定位过期时间的限制。 public响应头，通知浏览器无条件缓存该响应 private响应头，通知浏览器只针对单个用户缓存响应。且可以具体指定某个字段。如：private-“username” no-cache请求头，浏览器去服务器取数据并验证缓存。响应头告诉浏览器必须要回复服务器校验，不管有没有缓存。如果确定没有被改，可以使用缓存中的数据 no-store要求浏览器任何情况下都不要缓存 max-age 强制浏览器根据该值校验缓存。即自身age值，与请求时间做比较，如果超过max-age值，则强制去服务器端验证。以确保返回一个新鲜的响应。其功能与传统的Expire类似，但区别在于Expire是根据某个特定日期值做比较，一旦客户端自身的时间不准确，则结果可能就是错误的，而max-age则是客户端时间比较。max-age的优先级高于Expire。 Expire指定的时间可以是相对文件的最后访问时间（Atime）或者修改时间（Mtime），而max-age相对的是文档的请求时间（Atime） 3. Last-Modified/If-Modified-Since客户端第一次访问资源的时候，服务器返回资源内容的同时返回Last-Modified:Wed, 07 Aug 2013 15:32:18 GMT，服务器告诉客户端你获取的文件最后修改时间是这个时间。浏览器在获取这个文件到缓存中的时候，给缓存中的文件同时记录上这个最后修改时间。 第二次访问的时候，服务器访问资源的时候会带上If-Modified-Since:Wed, 07 Aug 2013 15:32:18 GMT. 客户端询问服务器：这个资源我这边已经缓存了，我的缓存文件的最后修改时间是这个，如果你那边资源没有修改的话，你就告诉我一下就好了，不需要返回实际的资源的内容；反之要是你有修改的话，你就把内容返回给我吧。 4. ETag/If-None-Match是实现与最近修改数据检查同样的功能的另一种方法，没有变化时不重新下载数据。第一次客户端访问资源的时候，服务端返回资源内容的同时返回ETag:1234，告诉客户端这个文件的标签是1234，如果修改了的话，这个标签就会不一样。 第二次客户端访问资源的时候，由于缓存中已经有了ETag为1234的资源，客户端要去服务端查询的是这个资源有没有过期呢？所以带上If-None-Match:1234。告诉服务端：如果你那边的资源还是1234标签的资源，你就返回304告诉我，不需要返回资源内容了；如果不是的话你就返回内容给我。 总结：Exipire/Cache-Control header是控制浏览器是否直接从浏览器缓存中获取数据还是重新发送请求到服务器取数据。只是Cache-Control比Expires控制的多些，而且Cache-control会重写Expires规则。 Last-Modified/ETag是浏览器发送请求到服务器后判断文件是否修改过，如果没有修改过就只发送一个304给浏览器，告诉浏览器从本地缓存取数据；如果修改过那就返回200连同整个数据重新发送给浏览器。 补充：刷新理解了上面的缓存标签之后就很好理解各种刷新了，刷新有三种：浏览器中写地址、回车,F5,Ctrl+F5三种。 假设对一个资源:浏览器第一次访问，获取资源内容和cache-control:max-age:600,last-modified:Wed, 07 Aug 2013 15:32:18 GMT，于是浏览器把资源文件放到缓存中，并且决定下次使用的时候直接去缓存中取了。 浏览器url回车浏览器发现缓存中有这个文件，就不发送人任何请求，直接去缓存中获取展现。（最快） F5F5告诉浏览器别偷懒，去服务器看下这个文件是否有过期。于是浏览器就发送一个请求带上If-Modified-Since:Wed, 07 Aug 2013 15:32:18 GMT，然后浏览器发现，这个文件我在找个时间后还没修改过，不需要给你任何信息了，返回304就行了。于是浏览器获取到304后就去缓存中获取资源了。 3.Crtl+F5这个告诉浏览器先要把缓存中的这个文件给删了，然后再去服务器请求整个完整的资源文件下来，于是客户端就完成了强行更新的操作。","categories":[],"tags":[],"keywords":[]},{"title":"border-radius:50%和100%","slug":"border-radius-50-和100","date":"2017-07-16T13:27:16.000Z","updated":"2017-07-16T13:50:30.142Z","comments":true,"path":"2017/07/16/border-radius-50-和100/","link":"","permalink":"https://aliceflaviawang.github.io/2017/07/16/border-radius-50-和100/","excerpt":"","text":"用来画圆border-radius必不可少，我们把这个值设成50%，发现设成100%也有效。 下面是一个150px x 150px大小的方形，将它的四个角的半径都设置成50%。根据W3C的规范定义，如果border-radius的值是百分比，就是相对于border box的宽度和高度的百分比。在本例中，50%就是75px。 border-radius工作原理如果两个相邻的角的半径和超过了对应的盒子的边的长度，那么浏览器要重新计算保证它们不会重合。 如果左上角的圆角被设置成100%，那么圆角就会从这个方形左下角跨到右上角，相当于把圆角半径设置成150px。如果右上角的圆角半径也设置成100%，则两个相邻的圆角合起来就有200%。这种情况自然是不允许的，所以浏览器会重新计算，匀出空间给右边的圆角，同时缩放两个圆角的半径直到它们刚好符合这个方形，所以半径就变成了50%。 实际上方形所能拥有的最大半径是其宽高的50%，超过了就会重新计算。","categories":[],"tags":[],"keywords":[]},{"title":"TCP连接与关闭过程","slug":"TCP连接与关闭过程","date":"2017-07-16T11:58:42.000Z","updated":"2017-07-16T12:23:33.084Z","comments":true,"path":"2017/07/16/TCP连接与关闭过程/","link":"","permalink":"https://aliceflaviawang.github.io/2017/07/16/TCP连接与关闭过程/","excerpt":"","text":"建立连接：三次握手在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接，如图： 客户端A发送SYN包（SYN=j）到服务器B，并进入SYN_SEND状态，等待服务器B确认； 服务器B收到SYN包，必须确认客户A的SYN（ACK=J+1）,同时也发送一个SYN包（SYN=k），即ACK+SYN包，此时服务器B进入SYN_RECV状态； 客户端A收到服务器B的SYN+ACK包，，向服务器B发送确认包ACK（ACK=K+1）。此包发送完毕，客户端A和服务器B进入ESTABLISHED状态，完成三次握手。客户端与服务器端开始传送数据。 断开连接：四次挥手由于TCP是双全工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务就能发送一个FIN来终止这个方向的连接。收到一个FIN只意味着一个方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方进行主动关闭，而另一方执行被动关闭。 客户A发送一个FIN，用来关闭客户A到服务器B的数据传送 服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序列号。 服务器B关闭与客户端A的连接，发送一个FIN给客户端A。 客户端A发回ACK报文确认，并将确认序号设置为收到序号加1。","categories":[],"tags":[],"keywords":[]},{"title":"如何选择图片格式GIF,JPG,PNG","slug":"如何选择图片格式GIF-JPG-PNG","date":"2017-07-16T08:37:15.000Z","updated":"2017-07-16T09:13:34.310Z","comments":true,"path":"2017/07/16/如何选择图片格式GIF-JPG-PNG/","link":"","permalink":"https://aliceflaviawang.github.io/2017/07/16/如何选择图片格式GIF-JPG-PNG/","excerpt":"","text":"JPEG（简写jpg）JPEG是一种大小与质量相平衡的压缩图片格式。通俗的说：高的压缩比=低的图片质量=小的文件大小。由于JPEG无法保持100%的原始图像的像素数据，所以它不被认为是一种无损图像格式。 它支持上百万种颜色。适合轻微是真的像素色彩丰富的图片唱歌，并不适合简单色彩的图片如logo，icons。 它不支持图形渐进、北京透明，更不支持动画，有损压缩不可恢复 GIF是为了使图片能够应用在在线应用程序上所特别开发的图片格式。GIF，是一种无损（100%保持原始图片像素数据信息），8位图片格式（一个8位图像仅能支持256中不同颜色，多于将出现失真）。 压缩特性：采用LZW算法进行压缩 透明特性：支持基本的透明性 支持隔行扫描：隔行扫描能够令图片在浏览器中更快的加载和显示 动画GIF：支持动画。Flash动画出来之前，GIF动画可以说是唯一的动画。GIF将单帧的图像组合起来，然后轮流播放每一帧而成为动画。 PNGPNG也是一种无损压缩，但与GIF不同的是，PNG同时支持8位和24位的图像。 8位PNG图片的用途与GIF格式基本相同 24位PNG：24位PNG，支持160万种不同的像素颜色且支持Alpha透明效果。也就是说无论透明度设为多少，PNG图片均能够与背景很好的融合在一起。 不支持动画，高级压缩，支持全彩图像，对色彩丰富的图像取得不错的视觉效果 总比较大小：PNG≈JPG&gt;GIF透明性：PNG&gt;GIF&gt;JPG色彩丰富度：JPG&gt;PNG&gt;GIF兼容度：GIF≈JPG&gt;PNG","categories":[],"tags":[],"keywords":[]},{"title":"childNodes和children的区别","slug":"childNodes和children的区别","date":"2017-07-16T04:07:05.000Z","updated":"2017-07-16T08:37:23.723Z","comments":true,"path":"2017/07/16/childNodes和children的区别/","link":"","permalink":"https://aliceflaviawang.github.io/2017/07/16/childNodes和children的区别/","excerpt":"","text":"childNodes标准的，它返回指定元素的子元素集合，包括HTML节点，属性节点和文本节点。可以通过nideType来判断是哪个类型的节点，只有当nodeType==1时才是元素节点，2是属性节点，3是文本节点。 children非标准的，它只返回HTML节点（IE中包含注释节点）。","categories":[],"tags":[],"keywords":[]},{"title":"渐进增强和优雅降级","slug":"渐进增强和优雅降级","date":"2017-07-16T03:56:59.000Z","updated":"2017-07-16T04:02:31.988Z","comments":true,"path":"2017/07/16/渐进增强和优雅降级/","link":"","permalink":"https://aliceflaviawang.github.io/2017/07/16/渐进增强和优雅降级/","excerpt":"","text":"渐进增强针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。 优雅降级一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。 区别： 优雅降级是从复杂的现状开始，并试图减少用户体验的供给； 渐进增强是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要； 降级（功能衰退）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带。","categories":[],"tags":[],"keywords":[]},{"title":"立即执行函数的作用","slug":"立即执行函数的作用","date":"2017-07-15T14:39:58.000Z","updated":"2017-07-15T14:58:37.352Z","comments":true,"path":"2017/07/15/立即执行函数的作用/","link":"","permalink":"https://aliceflaviawang.github.io/2017/07/15/立即执行函数的作用/","excerpt":"","text":"(function(){})()是立即执行函数（IIFE），它会默认将函数作为表达式去解析，而不是函数声明（注意圆括号内不能包含声明）。它的作用： 最主要的作用是隔离作用域，直到ES5JS没有块作用域，用来隔离作用域避免污染。 惰性，利用立即执行特性，返回需要的业务函数或对象，避免每次通过条件判断来处理。 惰性函数惰性载入表示函数执行的分支只会在函数第一次调用的时候执行，在第一次调用的过程中，该函数会被覆盖为另一个按照合适方式执行的函数，这样任何对原函数的调用就不用再经过执行的分支了。举个经典的例子1234567891011function addEvent(type,element,fun)&#123; if(element.addEventListener)&#123; element.addEventListener(type,element,fun); &#125; else if(element.attachEvent)&#123; element.attachEvent(type,element,fun); &#125; else&#123; element[&apos;on&apos;+type]=fun; &#125;&#125; 上面注册监听函数主要是为了兼容浏览器。由于浏览器差异，不得不再用的时候做能力检测。但是这样做，每次绑定监听，都会对能力做一次检测，然而真正的应用中，同一个应用环境，其实只需要做一次检测即可。下面重写addEvent:1234567891011121314151617function addEvent(type,element,fun)&#123; if(element.addEventListener)&#123; addEvent=function(type,element,fun)&#123; element.addEventListener(type,fun,false); &#125; &#125; else if(element.attachEvent)&#123; addEvent=function(type,element,fun)&#123; element.attachEvent(&quot;on&quot;+type,fun); &#125; &#125; else&#123; addEvent=function(type,element,fun)&#123; element[&apos;on&apos;+type]=fun; &#125; &#125;&#125; 由于第一调用addEvent会对浏览器做能力检测，然后重写addEvent。下次再调用的时候，由于函数被重写，不会再做能力检测。 惰性函数的应用场景： 应用频繁。用的次数也多越能体现出优势来； 固定不变。一次判断，在固定的应用环境中不会发生改变； 复杂的分支判断。没有差异性的，不需要用这种模式。","categories":[],"tags":[],"keywords":[]},{"title":"同步和异步","slug":"同步和异步","date":"2017-07-15T13:11:06.000Z","updated":"2017-07-15T14:29:16.945Z","comments":true,"path":"2017/07/15/同步和异步/","link":"","permalink":"https://aliceflaviawang.github.io/2017/07/15/同步和异步/","excerpt":"","text":"延伸 摘自阮一峰es6入门： 于是，这个问题又回到了最开始的起点：JavaScript是单线程的。 JavaScript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。那么，为什么JavaScript不能有多个线程呢？这样能提高效率啊。 JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？ 所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。 为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。 单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。于是就有一个概念，任务队列。 如果排队是因为计算量大，CPU忙不过来，倒也算了，但是很多时候CPU是闲着的，因为IO设备（输入输出设备）很慢（比如Ajax操作从网络读取数据），不得不等着结果出来，再往下执行。 JavaScript语言的设计者意识到，这时主线程完全可以不管IO设备，挂起处于等待中的任务，先运行排在后面的任务。等到IO设备返回了结果，再回过头，把挂起的任务继续执行下去。 于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。 具体来说，异步执行的运行机制如下。（同步执行也是如此，因为它可以被视为没有异步任务的异步执行。） （1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。（2）主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。（3）一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。（4）主线程不断重复上面的第三步。下图就是主线程和任务队列的示意图。 只要主线程空了，就会去读取”任务队列”，这就是JavaScript的运行机制。这个过程会不断重复。 “任务队列”是一个事件的队列（也可以理解成消息的队列），IO设备完成一项任务，就在”任务队列”中添加一个事件，表示相关的异步任务可以进入”执行栈”了。主线程读取”任务队列”，就是读取里面有哪些事件。 “任务队列”中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入”任务队列”，等待主线程读取。 所谓”回调函数”（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。 “任务队列”是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，”任务队列”上第一位的事件就自动进入主线程。但是，由于存在后文提到的”定时器”功能，主线程首先要检查一下执行时间，某些事件只有到了规定的时间，才能返回主线程。 进程和线程一个程序就是一个进程，而一个程序中的多个任务则被称为线程。进程是表示资源分配的基本单位，又是调度运行的基本单位。线程是进程中执行运算的最小单位，亦即执行处理机调度的基本单位。进程和线程的关系： 一个线程只属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程是操作系统可以识别的最小执行和调度单位。 资源分配给进程，同一个进程的所有线程共享该进程的所有资源。同一进程中的多个线程共享代码段、数据段、扩展段。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。 处理机分给线程。即真正在处理机上运行的是线程。 线程在执行过程中，需要同步写作，不同的线程间要利用消息通信的办法实现同步。","categories":[],"tags":[],"keywords":[]},{"title":"src和href的区别","slug":"src和href的区别","date":"2017-07-15T12:00:43.000Z","updated":"2017-07-16T14:45:25.556Z","comments":true,"path":"2017/07/15/src和href的区别/","link":"","permalink":"https://aliceflaviawang.github.io/2017/07/15/src和href的区别/","excerpt":"","text":"hrefhref标志超文本引用，用在link和a元素上，href是引用和页面关联，是在当前元素和引用资源之间建立联系。 当浏览器解析到这一句的时候会识别该文档为css文件，会下载并且不会停止对当前文档的处理，这也是为什么建议使用link来加载css而不是使用@import。 src一般用在img,script,frame等元素上。指向外部资源的位置，指向的内部会嵌入到当前标签所在的位置；在请求src资源时会将其指向的资源下载并应用到当前文档中。 当浏览器解析到这一句的时候会暂停其他资源的下载和处理，直至将该资源加载、编译执行完毕（这也是为什么要把js放到底部而不是头部），图片和框架元素也是如此，类似于该元素所指向的资源嵌套到当前标签内。 顺便提一下css,js的放置位置css放在页面头部，页面渲染时是根据DOM结构生成了一个DOM树然后加上css样式生成渲染树，如果css放在后面可能页面会出现闪跳的感觉，白屏或者布局混乱直到css加载完成。 js一般放在之前：因为 执行到这句的时候，会中断其他资源的下载和处理(因为js有可能会修改DOM，所以会阻塞其他的下载和呈现)，知道其下载、解析、执行完毕，因此不能放在头部会组阻塞页面 不能将需要访问dom元素的放在body之前，因为此时还没生成dom，在body之前访问dom元素会出错（ 但也不能将所有的放在body之后，一些页面的效果的实现，是需要预先动态的加载一些js脚本的）","categories":[],"tags":[],"keywords":[]},{"title":"li元素逆序","slug":"li元素逆序","date":"2017-07-14T13:41:08.000Z","updated":"2017-07-24T13:53:47.268Z","comments":true,"path":"2017/07/14/li元素逆序/","link":"","permalink":"https://aliceflaviawang.github.io/2017/07/14/li元素逆序/","excerpt":"","text":"直接上代码1234567var ul=document.getElementById(&quot;ul&quot;);var children=Array.prototype.slice.call(ul.getElementsByTagName(&quot;li&quot;),0);var str=&quot;&quot;;children.reverse();for(var i=0;i&lt;children.length;i++)&#123; str+=children[i].outerHTML;&#125; getElementsByTagName(“li”)实际上返回的就是类数组，为什么要用Array.prototype.slice.call(ul.getElementsByTagName(“li”),0)呢？在此之前先说说js的类数组对象：HTMLCollection，NodeList,arguements.类数组：拥有length的属性，但不是数组（使用instanceof检查返回false），没有forEach,map,slice等数组方法。 类数组常见的三个对象1. 函数的argumentsarguments:函数通过arguments访问传入函数的参数。它是个对象（不是数组），有length属性。 2. HTMLCollection对象HTMLCollection是一个借口，表示HTML元素的集合，提供可以遍历的列表的方法和属性。拥有length,item,nameItem属性（可以访问元素的name和id属性）。返回HTMLCollection集合的有：document.getElementsByTagName,document.getElementsByClassName。 3. NodeList对象NodeList代表乐意个有顺序的节点列表（不光有元素，还有其他节点如文本节点、注释节点）。有length,item属性。返回NodeList集合的有：document.getElementsByName，document.querySelectorAll，document.getElementById(“table”).childNodes，document.styleSheets。 类数组转化成数组1.argumentsarguments的数组话，只需要运用[].slice.call()方法便可以将传递给函数的参数数组化。12345function person()&#123; var args=[].slice.call(arguments); console.log(args);&#125;person(10,20); 2.HTMLCollection和NodeList对于这两类数组对象的元素集合，如果我们使用[].slice.call()方法，IE8及以下的浏览器竟然会报错，报错的内容是：”Array.prototype.slice:’this’不是javascript对象”，很明显HTMLCollection和NodeList并不是Object的子类。所以为了让类数组转化成纯数组，需要进行处理： jQuery早期的makeArray做法 123456789101112131415161718var div=document.getElementsByTagName(&quot;div&quot;);function makeArray(array)&#123; var ret=[]; if(array!=null)&#123; var i=array.length; //The window,strings (and functions) also have length if(i==null||typeof array===&quot;string&quot;||array.setInterval)&#123; ret[0]=array; &#125;else&#123; while(i)&#123; ret[--i]=array[i]; //此处将类数组转化成数组，因为类数组可以遍历，因此适用于所有的类数组对象，将其取出放入数组中 &#125; &#125; &#125; return ret;&#125;var arr=makeArray(div);console.log(arr); prototype的做法 12var div=document.getElementsByTagName(&quot;div&quot;);var array=Array.prototype.slice.call(div,0); 其中，第一种做法兼容性比较好，很通用，第二种做法比较高级，但是只适合高版本主流浏览器。 ES6增加的Array.from方法Array.from可将两类对象转为整正的数组：类似数组的对象（array-like object,类数组对象的本质特征是必须有length属性，即任何有length属性的对象，都可以通过Array.from方法转为数组）和可遍历（iterator）的对象。12var div=document.getElementsByTagName(&quot;div&quot;);var array=Array.from(div); 后记HTMLCollection的集合访问dom元素必须要加上[0]，比如document.getElementsByTagName(“li”)[0]","categories":[],"tags":[],"keywords":[]},{"title":"阿里面试题","slug":"阿里面试题","date":"2017-07-13T13:08:21.000Z","updated":"2017-07-20T02:15:31.697Z","comments":true,"path":"2017/07/13/阿里面试题/","link":"","permalink":"https://aliceflaviawang.github.io/2017/07/13/阿里面试题/","excerpt":"","text":"1. 判断一个对象是否为空目前知道两种方式：第一种将JSON对象变成字符串，看字符串是否为“{}”12345var a=&#123;&#125;;if(JSON.stringify(a)==&quot;&#123;&#125;&quot;)&#123; console.log(&quot;是空对象&quot;);&#125;//是空对象 另外可以使用jQuery的isEmptyObject()方法12345678var a=&#123;&#125;;function isEmptyObject(e)&#123; for(var t in e)&#123; return !1; &#125; return !0;&#125;console.log(isEmptyObject(a)); //true 2. 判断一个数组是数组方法很多:比如：使用instanceof看是不是Array的实例12var arr=[];console.log(arr instanceof Array); //true 或者看arr是否具有push方法（push方法是数组独有的，其他数组独有的方法都可以）12345678var arr=[];function judgeArray(arr)&#123; if(arr.push)&#123; return !0; &#125;return !1;&#125;judgeArray(arr);//true 或者使用Object.prototype.toString.call()方法12var arr=[];Object.prototype.toString.call(arr); //&quot;[Object Array]&quot; Object.prototype.toString.call()方法的原理toString被调用时，执行以下步骤： 获取this对象的[[class]]属性值 计算出三个字符串”[Object”, “第一步的操作结果”,”]”连接的新字符串 返回第二步的操作结果[[class]]是一个内部属性，所有对象都具有该属性。通过[[class]]属性达到判断对象类型的目的。（jQuery的$.type()就是干这个的）通过Object.prototype.toString.call()可以判断： 判断基本类型Object.prototype.toString.call(null);//“[Object Null]”Object.prototype.toString.call(undefined);//“[Object Undefined]”Object.prototype.toString.call(“abc”);//“[Object String]”Object.prototype.toString.call(123);//“[Object Number]”Object.prototype.toString.call(true);//“[Object Boolean]” 判断引用类型函数类型Function fn(){console.log(“test”);}Object.prototype.toString.call(fn);//”[object Function]”日期类型var date = new Date();Object.prototype.toString.call(date);//”[object Date]”数组类型var arr = [1,2,3];Object.prototype.toString.call(arr);//”[object Array]”正则表达式var reg = /[hbc]at/gi;Object.prototype.toString.call(arr);//”[object Array]”自定义类型function Person(name, age) { this.name = name; this.age = age;}var person = new Person(“Rose”, 18);Object.prototype.toString.call(arr); //”[object Object]”很明显这种方法不能准确判断person是Person类的实例，而只能用instanceof 操作符来进行判断，如下所示：console.log(person instanceof Person);//输出结果为true 判断原生JSON对象：var isNativeJSON = window.JSON &amp;&amp; Object.prototype.toString.call(JSON);console.log(isNativeJSON);//输出结果为”[object JSON]”说明JSON是原生的，否则不是； 3. 正则表达式的惰性和非捕获性 正则表达式的贪婪与懒惰贪婪匹配：当表达式中接受重复的限定符时，通常的行为是匹配尽可能多的字符。懒惰匹配：匹配尽可能少的字符。（加上？，使得整个匹配成功的前提下使用最少重复）懒惰限定符12345var str=&apos;aaba-baabb&apos;var reg=/a.b/gstr.match(reg); // [&quot;aab&quot;, &quot;a-b&quot;, &quot;aab&quot;]var reg1=/a.&#123;3,4&#125;?b/gstr.match(reg1) //[&quot;aaba-b&quot;] 正则表达式捕获语法(pattern):匹配pattern并捕获改匹配的子表达式(?:pattern):匹配pattern，与（pattern）区别在于不捕获子表达式(?=pattern):先行断言，匹配pattern但不出现在匹配结果里(?!pattern):先行否定断言，与（？=pattern）相反 12345var data=&apos;windows 98 is ok&apos;;data.match(/windows (\\d+)/); //[&quot;windows 98&quot;,&quot;98&quot;,&quot;0&quot;,&quot;windows 98 is ok&quot;]data.match(/windows (?:\\d+)/); //[&quot;windows 98&quot;,&quot;0&quot;,&quot;windows 98 is ok&quot;]data.match(/windows (?=\\d+)/); //[&quot;windows &quot;,&quot;0&quot;,&quot;windows 98 is ok&quot;]data.match(/windows (?!\\d+)/); //null ES6推出了后行断言(?&lt;=pattern):与先行断言相反，匹配顺序从右到左，匹配pattern但不出现在结果里12/(^(\\d+)(\\d+)$)/.exec(&apos;1053&apos;) //[&apos;1053&apos;,&apos;105&apos;,&apos;3&apos;]/(?&lt;=(\\d+)(\\d+))$/.exec(&apos;1053&apos;) //[&apos;&apos;,&apos;1&apos;,&apos;105&apos;] 没有后行断言时，第一个括号是贪婪模式（保证匹配到的情况下的最长匹配），第二个括号只能捕获一个字符，所以结果是105和3。而后行断言，由于执行顺序是从右到左，第二个括号时贪婪模式，第一个括号只能捕获一个字符，所以结果是1和053。 正则表达式中的exec和match方法的区别字符串的正则方法有：match(),replace(),search(),split()正则表达式的方法有：exec(),test() 1. match()match()属于String正则表达式方法语法：str.match(regexp) //str是要匹配的字符串，regexp是正则表达式match的用法区分是正则表达式有无g全局标志 如果有g全局标志，那么返回的数组保存的是所有的匹配内容，不包括子匹配 12345var objStr=&quot;我的手机号13522222222，他的手机号13288888888，她的手机号码13699999999&quot;; //设置正则表达式，匹配以13开头11位字符串，全局匹配var reg=/13(\\d)(\\d&#123;8&#125;)/g; var arr=objStr.match(reg); arr //[&quot;13522222222&quot;, &quot;13288888888&quot;, &quot;13699999999&quot;] 如果没有g全局标志，那么返回的数组arr.arr[0]保存的是完整匹配,1-n元素包含了匹配中曾经出现过的任一个子匹配，并有index(匹配开始的位置)和input(整个被查找的字符串)两个属性。 12345var objStr=&quot;我的手机号13522222222，他的手机号13288888888，她的手机号码13699999999&quot;; //非全局匹配var reg=/13(\\d)(\\d&#123;8&#125;)/; var arr=objStr.match(reg); arr //[&quot;13522222222&quot;, &quot;5&quot;, &quot;22222222&quot;, index: 5, input: &quot;我的手机号13522222222，他的手机号13288888888，她的手机号码13699999999&quot;] replace()进行字符串替换，然后返回替换后的副本(字符串本身不变)语法：str.replace(regexp,replaceText)123var objStr=&quot;我的手机号13522222222，他的手机号13288888888，她的手机号码13699999999&quot;; var reg=/13(\\d)(\\d&#123;8&#125;)/g; objStr.replace(reg,&quot;-&quot;) //&quot;我的手机号-，他的手机号-，她的手机号码-&quot; search()search()方法指明是否存在相应的匹配，如果找到，返回索引值，否则返回-1。语法：str.search(regexp)与exec()方法不同，只能执行一次，如果regexp含有全局标志将自动忽略，也忽略lastIndex属性。即只能返回第一个匹配的索引值。1234var objStr=&quot;我的手机号13522222222，他的手机号13288888888，她的手机号码13699999999&quot;; var reg=/13(\\d)(\\d&#123;8&#125;)/g; var index=objStr.search(reg);index; //5 split()方法将一个字符串分割为子字符串，结果作为数组返回。语法：str.split(seperator,limit) //limit限制返回的个数123var objStr=&quot;我的手机号13522222222，他的手机号13288888888，她的手机号码13699999999&quot;; var reg=/13(\\d)(\\d&#123;8&#125;)/g; objStr.split(reg); // [&quot;我的手机号&quot;, &quot;5&quot;, &quot;22222222&quot;, &quot;，他的手机号&quot;, &quot;2&quot;, &quot;88888888&quot;, &quot;，她的手机号码&quot;, &quot;6&quot;, &quot;99999999&quot;, &quot;&quot;] 2. exec()与match()方法不同，exec()属于正则表达式的方法语法：regexp.exec(str)exec(exec有无g都无影响)与match的关联就是exec等价于没有g标志的matchexec()只执行一次12345var objStr=&quot;我的手机号13522222222，他的手机号13288888888，她的手机号码13699999999&quot;; var reg=/13(\\d)(\\d&#123;8&#125;)/; //执行exec函数，尽管是全局匹配的正则表达式，但是exec方法只对指定的字符串进行一次匹配（有无g都只执行一次），获取字符串中第一个与正则表达式想匹配的内容，并且将匹配内容和子匹配的结果存储到返回的数组中var arr=reg.exec(objStr); arr //[&quot;13522222222&quot;, &quot;5&quot;, &quot;22222222&quot;, index: 5, input: &quot;我的手机号13522222222，他的手机号13288888888，她的手机号码13699999999&quot;] 如果将regexp设为全局标志，每次执行exec()时以lastIndex属性值表示的位置开始查找；如果没有设置全局标志，将忽略lastIndex的值，从字符串的起始位置开始搜索。如果想找到字符串的所有匹配，可以循环执行exec()方法直到找不到了为止，此时必须设置全局标志，否则是个死循环。123456789var objStr=&quot;我的手机号13522222222，他的手机号13288888888，她的手机号码13699999999&quot;; var reg=/13(\\d)(\\d&#123;8&#125;)/; var arr; while((arr=reg.exec(objStr))!=null)&#123; console.log(arr.index+&quot;-&quot;+reg.lastIndex+&quot;\\t&quot;+arr); //**注意lastIndex属性是属于reg的**zhen &#125;//5-16 13522222222,5,22222222//22-33 13288888888,2,88888888//40-51 13699999999,6,99999999 test()test()的语法与exec一致，test()方法检查在字符串中是否存在一个匹配指定模式的字符串，存在返回true，不存在返回false。123var objStr=&quot;我的手机号13522222222，他的手机号13288888888，她的手机号码13699999999&quot;; var reg=/13(\\d)(\\d&#123;8&#125;)/g; reg.test(objStr) **4. ES6的声明变量的方法ES5本身的var,function，ES65. Doctype的类型**&lt;!DOCTYPE&gt;声明位于第一行，告知浏览器文档所使用的规范。HTML 4.01规定了三种DOCTYPE类型：Strict,Transitional,Frameset stric:需要干净的标记，免于表现层混乱，与CSS配合使用 transitional：包含W3C所期望移入样式表的呈现属性和元素。不支持CSS的浏览器可以使用 frameset：被用于带有框架的文档 HTML5只有一种&lt;!DOCTYPE HTML&gt; 6. link和@import的区别1）link属于HTML标签，@import是css提供的2）页面加载时，link同时被加载，而@import页面加载完后被加载的3）link无兼容问题4）link的样式权重高于@import7. 状态码（302，304，307重点关注）8. 七层网络，各种协议属于哪一层9. css实现省略号使用text-overflow属性规定当文本溢出包含元素时发生的事情。有三种可能的值： clip:修剪文本 ellipsis：显示省略符号来代表被修剪的文本 string:使用给定的字符串来代表被修剪的文本注：要在文本所在div声明 overflow:hidden;10. null和undefined区别undefined:声明了变量但未对其初始化123var message;console.log(message); //undefinedconsole,log(typeof message); //undefined null:尚未存在的对象，常用来表示函数企图返回一个不存在的对象。从逻辑 角度来看，null值表示一个空对象指针。1234var car=null; //一般没有必要显示的将变量设为undefined，但是应该明确让变量保存null值，这样可以体现null作为空对象指针的惯例，也有助于区别undefined和nullconsole.log(typeof car); //objectnull==undefined //true,**undefined的值实际上派生自null**null===undefined //false,**==只需要值相等，===还要比较类型** NaN:即非数值(not a number)是一个特殊的数值，这个数值用于表示本来要返回数值的操作数未返回数值的情况。NaN有两个特点：1.任何涉及NaN的操作都返回NaN；2.NaN与任何值都不相等，包括NaN本身。isNaN()判断一个数是否是NaN（非数值）。123456console.log(typeof NaN) //numberNaN==NaN //falseisNaN(NaN) //trueisNaN(&quot;10&quot;) //false，可以转化成数值10isNaN(&quot;blue&quot;) //true，不能转换成数值isNaN(true) //false，可以转换成数值1 判断undefined、null和NaN的方法： 判断undefined 12var a=undefined;console.log(typeof a==&quot;undefined&quot;); true 判断null 1234var a=null;if(typeof a==&quot;object&quot;&amp;&amp;a==undefined)&#123; console.log(true);&#125; 还可以通过Object.ptototype.toString.call()方法判断是null还是undefined 判断NaN使用isNaN()方法","categories":[],"tags":[],"keywords":[]},{"title":"常见的数据结构算法","slug":"常见的数据结构算法","date":"2017-07-13T07:12:24.000Z","updated":"2017-07-14T00:40:42.967Z","comments":true,"path":"2017/07/13/常见的数据结构算法/","link":"","permalink":"https://aliceflaviawang.github.io/2017/07/13/常见的数据结构算法/","excerpt":"","text":"二分查找二分查找是基于有序表，是一种在有序数组中查找特定元素的搜索算法。查找过程可以分为： 首先从有序数组的中间的元素开始搜索，如果改元素正好的目标元素即要查找的元素，则搜索过程结束，否则进行下一步 如果目标元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半区域查找，然后重复第一步的操作 如果某一步数组为空，则表示找不到目标元素下面用js分别以递归和不递归的方法写了二分查找（还有对于有重复数组）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950var arr=[1,2,3,4,5,6,7,10,10,10,11,23,44,86]; // function search(arr,key,low,high)&#123; // if(low&gt;high)&#123; // return -1; // &#125; // var mid=parseInt((low+high)/2); // if(key==arr[mid])&#123; // while(mid&gt;=0)&#123; // mid--; // if(arr[mid]&lt;key)&#123; // return mid+1; // &#125; // &#125; // &#125;else if(key&lt;arr[mid])&#123; // high=mid-1; // return search(arr,key,low,high); // &#125; // else if(key&gt;arr[mid])&#123; // low=mid+1; // return search(arr,key,low,high) // &#125;else &#123; // return -1; // &#125; // &#125; // var result=search(arr,10,0,13); // alert(result) function search(arr,key)&#123; var low=0; var high=arr.length-1; while(low&lt;=high)&#123; var mid=parseInt((low+high)/2); if(arr[mid]==key)&#123; while(mid&gt;=0)&#123; mid--; if(arr[mid]&lt;key)&#123; return mid+1; &#125; &#125; &#125;else if(key&lt;arr[mid])&#123; high=mid-1; &#125;else if(key&gt;arr[mid])&#123; low=mid+1; &#125;else&#123; return -1; &#125; &#125; &#125; var result=search(arr,10); alert(result); 冒泡排序冒泡排序基于两两比较和交换，每次冒出一个关键字最大的记录（升序）或关键字最小的记录（降序）。第一趟：第一个和第二个比较，反序则交换，第二个和第三个比较…直到最后冒出最大的一个数放在最后；第i趟的时候，只需要第一个和第二个比较…直到第n-i个和第n-i+1个比较了。最后得出排序结果。12345678910111213141516var arr=[1,22,13,4,5,15,21,10,10,10,11,23,44,86];function bubble(arr)&#123; var n=arr.length-1; for(var i=0;i&lt;n;i++)&#123; for(var j=0;j&lt;n-i;j++)&#123; if(arr[j]&gt;arr[j+1])&#123; var temp=arr[j]; arr[j]=arr[j+1]; arr[j+1]=temp; &#125; &#125; &#125;return arr;&#125;var result=bubble(arr);alert(result); 冒泡算法的改进：如果最后面的若干记录未发生交换，那么这最后的记录已经具有了正序，不需要再进行冒泡了。因此可以通过记录最后一次交换顺序的位置，来改进冒泡算法：12345678910111213141516171819var arr=[1,22,13,4,5,15,21,10,10,10,11,23,44,86];function proBubble(arr)&#123; var i=arr.length-1; while(i&gt;0)&#123; var lastChangeIndex=0; for(var j=0;j&lt;i;j++)&#123; if(arr[j]&gt;arr[j+1])&#123; var temp=arr[j]; arr[j]=arr[j+1]; arr[j+1]=temp; lastIndexChange=j; &#125; &#125; i=lastIndexChange; &#125;return arr;&#125;var result=proBubble(arr);alert(result); 快速排序从数组的中间拿一个值，然后通过这个值挨个和数组里面的值进行比较，如果大于的放在一边，小于的放在一边，然后把这些合并，再进行比较，如此反复即可。1234567891011121314151617181920212223242526var arr=[1,22,13,4,5,15,21,10,10,10,11,23,44,86];function fast(arr)&#123; //如果只有一位，就没有必要比较 if(arr.length&lt;=1)&#123; return arr; &#125; //获取中间值的索引 var len=Math.floor(arr.length/2); //截取中间值 var cur=arr.splice(len,1); //小于中间值放这里面 var left=[]; //大于中间值放这里面 var right=[]; if(var i=0;i&lt;arr.length;i++)&#123; //判断是否大于 if(cur&gt;arr[i])&#123; left.push(arr[i]); &#125;else&#123; right.push(arr[i]); &#125; &#125;return fast(left).concat(cur,fast(right));//arrObject.concat(arrayX,arrayX,...,arrayX)用于连接两个或多个数组，返回一个新的数组。arrayX可以为具体的值也可以是数组对象 &#125;var result=fast(arr);alert(result); 后记 关于parseInt和Math.floorparseInt：解析一个字符串，并返回一个整数，这里可以简单理解成返回舍去参数的小数部分后的整数。如parseInt(5.57) //5,parseInt(-1.5) //-1.Math.floor:返回小于等于参数的最大整数。如：Math.floor(5.57) //5,Math.floor(-1.5) //-2.Math.round:四舍五入。如：Math.round(5.57) //6,Math.round(-1.5) //-1.Math.ceil:返回大于等于参数的最小整数。如：Math.ceil(5.57) //6，Math.ceil(-1.5) //-1","categories":[],"tags":[],"keywords":[]},{"title":"HTML网页布局","slug":"HTML网页布局","date":"2017-07-13T02:58:01.000Z","updated":"2017-07-13T03:31:38.249Z","comments":true,"path":"2017/07/13/HTML网页布局/","link":"","permalink":"https://aliceflaviawang.github.io/2017/07/13/HTML网页布局/","excerpt":"","text":"HTML网页的四种布局方式：静态布局、自适应布局、流式布局、响应式布局。 静态布局静态布局就是传统的网站形式：对于PC设计一个居中布局，窗口缩小时，内容被遮挡，呈现横竖向滚动条。对于移动设备，单独见一个m.域名及相应的移动网站。 自适应布局自适应布局的特点是分别为不同的屏幕分辨率定义布局（采用媒体查找）。布局切换时页面元素发生改变，但在每个布局中，页面元素不随窗口大小调整发生变化。可以把自适应布局看作是静态布局的一个系列。 流式布局流式布局的特点是页面元素的宽度按照屏幕进行适配调整，主要的问题是如果屏幕尺度跨度太大，那么相对其原始设计而言过小或过大的屏幕不能正常显示。流式布局之所以能按照屏幕进行适配是因为划分区域的参数使用百分比（搭配min-,max-属性使用）。然后后来出现弹性布局，包裹文字的个元素的尺寸采用em作单位，em的实际大小是相对于其上下文的字体大小而言的。如果给body标签设置文字大小是100%，给其他文字都使用相对单位em，那这些文字都会受body上的初始声明的影响。 响应式布局响应式布局的特点是分别为不同的屏幕分辨率定义布局，同时，在每个布局中，应用流式布局的概念，即页面元素的宽度随着窗口调整而自动适配。响应式布局看作是流式布局和自适应布局设计理念的融合。 具体效果可以参照：http://wow.techbrood.com/fiddle/1753","categories":[],"tags":[],"keywords":[]},{"title":"css3 box-sizing属性","slug":"css3-box-sizing属性","date":"2017-07-12T13:54:21.000Z","updated":"2017-07-12T14:35:29.803Z","comments":true,"path":"2017/07/12/css3-box-sizing属性/","link":"","permalink":"https://aliceflaviawang.github.io/2017/07/12/css3-box-sizing属性/","excerpt":"","text":"box-sizing属性可以为三个值之一：content-box(默认),border-box,padding-box。content-box:border和padding不计算入width之内padding-box:padding计算入width内border-box:border和padding计算如入width之内，其实就是怪异模式。1234567891011121314151617181920212223242526272829&lt;style type=&quot;text/css&quot;&gt; .content-box&#123; box-sizing:content-box; -moz-box-sizing:content-box; width: 100px; height: 100px; padding: 20px; border: 5px solid #E6A43F; background: blue; &#125; .padding-box&#123; box-sizing:padding-box; -moz-box-sizing:padding-box; width: 100px; height: 100px; padding: 20px; border: 5px solid #186645; background: red; &#125; .border-box&#123; box-sizing:border-box; -moz-box-sizing:border-box; width: 100px; height: 100px; padding: 20px; border: 5px solid #3DA3EF; background: yellow; &#125;&lt;/style&gt; 后记 CSS calc()calc()可以理解成一个函数，用来指定元素的长度。可以使用calc()给元素的border、margin、padding、font-size和width等属性设置动态值（如：width: calc(100% - 100px)）。calc()使用规则 使用”+”、 “-“、 “*”、 “/“四则运算 可以使用百分比、px、em、rem等单位 表达式中有”+”和”-“时，其前后必须有空格，如：width: calc(100%++5px)这种写法是错误的例子：使用三列布局的时候，使用calc()可以动态设定中间列的宽度12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;test&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .wrapper&#123; width: 100%; &#125; .left&#123; float: left; width: 100px; background-color: blue; &#125; .right&#123; float: left; width: 100px; background-color: red; &#125; .main&#123; float: left; width: calc(100% - 200px); background-color: #ccc; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;wrapper&quot;&gt; &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt; &lt;div class=&quot;main&quot;&gt;main&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; inline-block使用inline-block也可以实现三列布局，但是因为inline-block中会自带缝隙（是由于标签段之间的空格造成的），所以会造成main的宽度设为 calc(100% - 200px)时将right挤出去了。解决办法有很多，比如设置margin值为负，也可以将wrapper的font-size设为0，将子div的font-size设成正常值。flexflex的话要更方便123456789101112131415.wrapper&#123; display: flex; &#125; .left&#123; flex: 0 1 100px;/*设置成占据主轴的空间 */ background-color: blue; &#125; .right&#123; flex: 0 1 100px; background-color: red; &#125; .main&#123; flex:auto;/*实际上为1 1 auto */ background-color: #ccc; &#125;","categories":[],"tags":[],"keywords":[]},{"title":"Flex布局","slug":"Flex布局","date":"2017-07-12T08:43:23.000Z","updated":"2017-07-12T12:51:04.654Z","comments":true,"path":"2017/07/12/Flex布局/","link":"","permalink":"https://aliceflaviawang.github.io/2017/07/12/Flex布局/","excerpt":"","text":"网页布局是CSS的一个重点应用。布局的传统的解决方案，基于盒装模型，依赖于display属性+position属性+float属性。它对于那些特殊布局非常不方便，比如垂直居中就不容易实现。Flex布局，可以简便、完整、响应式地实现各种页面布局。 Flex布局是什么？Flex是Flexible Box的缩写，意为弹性布局，用来为盒状模型提供最大的灵活性。任何一个元素都可以指定为Flex布局，设为Flex布局之后，子元素float、clear和vertical-align属性将失效。 基本概念采用Flex布局的元素，成为Flex容器(flex container)，它的所有子元素自动成为容器成员，称为项目（flex item)。容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end;交叉轴的开始位置叫做cross start，结束位置叫做cross end。项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 容器的属性 flex-dirction flex-wrap flex-flow justify-content align-items align-contentflex-directionflex-direction决定主轴的方向（即项目的排列方向）1234567.box&#123; flex-direction:row|row-reverse|column|column-reverse //row(默认值):主轴为水平方向，起点在左端 //row-reverse:主轴在水平方向，起点在右端 //column:主轴在垂直方向，起点在上沿 //column-reverse:主轴在垂直方向，起点在下沿&#125; flex-wrap默认情况下，项目都排在一条线上（又称“轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。123456.box&#123; flex-wrap:nowrap|wrap|wrap-reverse //nowrap(默认)：不换行 //warp:换行，第一行在上方 //wrap-reverse:换行，第一行在下方&#125; flex-flowflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值是row nowrap.123.box&#123; flex-flow:&lt;flex-direction&gt;||&lt;flex-wrap&gt;&#125; justify-content属性justify-content属性定义了项目在主轴上的对齐方式。12345678.box &#123; justify-content: flex-start | flex-end | center | space-between | space-around; //flex-start（默认值）：左对齐 //flex-end：右对齐 //center：居中 //space-between：两端对齐，项目之间的间隔都相等 //space-around：每个项目两侧的间隔相等。&#125; align-itemsalign-items属性定义项目在交叉轴上如何对齐12345678.box&#123; align-items:flex-start|flex-end|center|baseline|stretch; //flex:交叉轴的起点 //flex-end:交叉轴的终点对齐 //center:交叉轴的重点对齐 //baseline:项目第一行文字的基线对齐 //stretch(默认值):如果项目未设置高度或设为auto，将占满整个容器的高度&#125; align-contentalign-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。123456789.box &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch; //flex-start：与交叉轴的起点对齐。 //flex-end：与交叉轴的终点对齐。 //center：与交叉轴的中点对齐。 //space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 //space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 //stretch（默认值）：轴线占满整个交叉轴。&#125; 项目属性◾order◾flex-grow◾flex-shrink◾flex-basis◾flex◾align-self orderorder定义项目的排列顺序。数值越小，排列越靠前，默认为0.123.item&#123; order:&lt;integer&gt;&#125; flex-growflex-grow定义了项目的放大比例，默认为0，即如果存在剩余空间，也不放大。123.item&#123; flex-grow:&lt;number&gt;&#125; 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话），如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他想多一倍。 flex-shrinkflex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。123.item&#123; flex-shrink:&lt;number&gt;;&#125; flex-basisflex-basis属性定义了分配多余空间之前，项目占据的主轴（main size）。浏览器根据这个属性，计算主轴是否有多余空间，它的默认值为auto，即项目本来大小。123.item&#123; flex-basis:&lt;length&gt;|auto;&#125; 它可以设为跟width或height属性一样的值，则项目将占据固定的空间 flexflex属性是flex-grow,flex-shrink和flex-basis的简写，默认值为0 1 auto。后两个属性可选。flex属性是flex-grow，flex-shrink和flex-basis的简写，默认值为0 1 auto。后两个属性可选。12.item&#123; flex:none|[&lt;&apos;flex-grow&apos;&gt;&lt;&apos;flex-shrink&apos;&gt;?||&lt;&apos;flex-basis&apos;&gt;] 该属性有两个快捷键：auto（1 1 auto）和none(0 0 auto) align-selfalign-self属性允许单个项目与其他项目以一样的对其方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。```.items{ align-self:auto|flex-start|flex-end|center|baseline|stretch}除auto外，其他与align-items属性完全一致。","categories":[],"tags":[],"keywords":[]},{"title":"跨站脚本攻击","slug":"跨站脚本攻击","date":"2017-07-11T08:44:29.000Z","updated":"2017-08-30T02:36:13.432Z","comments":true,"path":"2017/07/11/跨站脚本攻击/","link":"","permalink":"https://aliceflaviawang.github.io/2017/07/11/跨站脚本攻击/","excerpt":"","text":"跨站脚本攻击（XSS）跨站脚本攻击（cross-site script，为了和CSS区分，缩写XSS）。发生的原因是网站将用户输入的内容输出到页面上，在这个过程中可能有恶意代码被浏览器执行。 XSS的种类1.反射型XSS它是通过诱使用户打开一个恶意链接，服务端将链接中参数的恶意代码渲染到页面中，再传递给用户由浏览器执行，从而达到攻击的目的。 2.持久型XSS持久型xss将恶意代码提交给服务器，并且存储在服务器端，当用户访问相关内容时再渲染到页面中，以达到攻击的目的，它的危害更大。 XSS防御1.输入检查对输入数据做检查，比如用户名只允许是字母和数字，一定要在后台做检查，否则数据可能绕过前端检查直接发给服务器。一般前后端都做检查，前端能过滤掉大部分无效数据。 2.输出检查对渲染到html中内容执行htmlEncode。 3.Http-Only跨站脚本攻击，如果黑客向客户端发送的恶意代码要求浏览器向黑客发回一个cookie，即使这个cookie中包含敏感信息，浏览器也会执行。http-only可以非常有效的防止XSS攻击，它是cookie新增加的属性，当用户浏览有效域中的站点时，这个cookie仍会被自动发送；但是不能在IE6 SP1中使用脚本访问该cookie，即使当初建立该cookie的那个web站点也不例外。这就意味着即使存在XSS缺陷，并且用户被骗点击利用了该漏洞的链接，IE也不会将cookie发送给任何第三方。 其他攻击方式SQL注入SQL注入与XSS类似，用户提交的数据被当成命令来执行而造成的。 SQL注入防御防止SQL注入最好的方法是使用预编译语句。不同的语言的预编译方法不同，但基本都可以处理。如果无法使用预编译方法，只能像防止XSS那样对参数进行检查和编码。 点击劫持点击劫持是从视觉上欺骗用户。攻击者使用一个透明的iframe覆盖到网页上，诱使用户在该网页上操作，而实际点击却是点在透明的iframe页面。点击劫持延伸出很多攻击方式，有图片覆盖攻击、拖拽劫持等。 点击劫持的防御针对iframe的攻击，可使用一个http头：X-Frame-Options，它有三种可选值： DENY：禁止任何页面的frame加载 SAMEORIGIN:只有同源页面的frame可加载 ALLOW-FROM:可定义允许frame加载的地址针对图片覆盖攻击，则注意使用预防XSS的方法，防止HTML和JS注入。","categories":[],"tags":[],"keywords":[]},{"title":"CSRF攻击与防御","slug":"CSRF攻击与防御","date":"2017-07-11T06:39:07.000Z","updated":"2017-07-11T07:45:07.193Z","comments":true,"path":"2017/07/11/CSRF攻击与防御/","link":"","permalink":"https://aliceflaviawang.github.io/2017/07/11/CSRF攻击与防御/","excerpt":"","text":"CSRFCSRF:跨站点请求伪造(cross-site request forgery)。攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说是完全合法的，但是却完成了攻击者所期望的一个操作。 CSRF攻击的原理及过程 用户打开浏览器，访问网站A，输入用户名和密码请求登陆网站A 在用户信息验证通过之后，网站A产生cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A； 用户未退出网站A之前，在同一个浏览器中，打开一个Tab页访问网站B 网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A 浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带cookie信息，向网站A发出请求。网站A并不知道请求其实是由B发起的，所以会根据用户的cookie信息以用户的权限处理该请求，导致来自B的恶意被代码执行。CSRF漏洞检测检测CSRF是一项比较繁琐的工作，最简单的方法是抓取一个正常请求的数据包，去掉Referer字段后再重新提交，如果该提交有效，那么基本可以确定CSRF漏洞存在。CSRF攻击防御1.验证码验证码不单单用来防止注册机的暴力破解，还可以有效防止CSRF的攻击。不过随着html5的发展，利用canvas标签，前端也能识别验证码的字符，让CSRF生效。2.referer checkreferer记录了该http请求的来源地址，http referer是request header的一部分，当浏览器向web服务器发出请求的时候，一般会带上referer，告诉服务器从哪个站点链接过来。服务器通过判断请求头中的referer，也能避免CSRF攻击。3. tokenCSRF攻击之所以成功是因为黑客可以在不知道验证信息的情况下直接利用用户的cookie来通过安全验证。可以在http请求中以参数的形式加入一个随机产生的token。（比如get方式放拼接到url，post方式以参数方式）4.在http头中自定义属性并验证也是使用token并进行验证，但是不是以参数的形式置于http请求中，而是把它放在http头中自定义的属性里。","categories":[],"tags":[],"keywords":[]},{"title":"$.ready()与window.onload的区别","slug":"ready-与window-onload的区别","date":"2017-07-10T14:33:43.000Z","updated":"2017-07-10T14:41:27.396Z","comments":true,"path":"2017/07/10/ready-与window-onload的区别/","link":"","permalink":"https://aliceflaviawang.github.io/2017/07/10/ready-与window-onload的区别/","excerpt":"","text":"区别有三点： 1、执行时机$.ready()是网页的所有DOM结构绘制完毕后就执行，可能DOM元素关联的东西还没加载完window.onload必须等网页里所有的内容都加载完毕后（包括图片）才执行 2、编写个数$.ready()可以编写多个，每个都执行window.onload不能编写多个（编写多个时，只执行最后一个） 3、简化写法$.ready实际上是$(document).ready的简写，而window.onload没有简写 后记：DOM文档的加载过程 解析HTML结构 加载外部脚本和样式文件 解析并执行脚本代码 DOM树构建完成 //DOMContentLoaded 加载图片等外部文件 页面加载完 //load所以$.ready()是在第4步后执行，window.onload是在第6步后执行","categories":[],"tags":[],"keywords":[]},{"title":"javascript是单线程","slug":"javascript是单线程","date":"2017-07-10T11:51:27.000Z","updated":"2017-07-10T13:32:15.718Z","comments":true,"path":"2017/07/10/javascript是单线程/","link":"","permalink":"https://aliceflaviawang.github.io/2017/07/10/javascript是单线程/","excerpt":"","text":"首先看下面的代码：1234567function foo()&#123; console.log(&apos;first&apos;); setTimeout(function()&#123;console.log(&apos;second&apos;)&#125;,5);&#125;for(var i=0;i&lt;100;i++)&#123; foo();&#125; 执行结果会首先输出first，然后全部输出second；尽管中间结果会超过5ms，为什么？ javascript是单线程的因为JS运行在浏览器中，是单线程的，每个window一个JS线程，既然是单线程，在某个特定时刻只有特定的代码能够背执行，并阻塞其他代码。而浏览器是事件驱动（Event driven）的，浏览器中很多行为是异步（Asynchronized）的，会创建事件并放在执行队列中。javascript引擎是单线程处理它的任务队列，你可以理解成就是普通函数和回调函数构成的队列。当异步事件发生时，如鼠标点击事件、定时器触发事件、XMLHttpRequest完成回调触发等，将它们放入执行队列，等待当前代码执行完成。 异步事件驱动浏览器是事件驱动的，浏览器中很多行为是异步的。当一个异步事件发生时，它就进入事件队列。浏览器有个内部大消息循环，EventLoop(事件循环)，会轮询大的事件队列并处理事件。 浏览器不是单线程的虽然JS运行在浏览器中，是单线程的，每个window一个JS线程，但浏览器不是单线程的，例如Webkit或是Gecko引擎，都可能有如下线程： javascript引擎线程 界面渲染线程 浏览器触发线程 Http请求线程很多人搞不清，如果js是单线程的，那么谁去轮询大的Event Loop事件队列？答案是浏览器会有单独的线程去专门处理这个队列Ajax异步请求是否是真的异步Ajax请求确实是异步的，这请求是由浏览器新开一个线程请求，事件回调的时候放入Event loop单线程事件队列等候处理。setTimeout(func,0)的作用setTimeout(func,0)非常有用，单丝不是模拟多线程，前面已经说过一个window一个js线程，setTimeout(func,0)主要是告诉js引擎，在0ms后把func放在主事件队列中，等待当前的代码执行完毕后再执行。注：重点是改变了代码的流程，把func的执行放到了等待当前的代码执行完毕后再执行。非阻塞js的实现js在浏览器中需要被下载、解释并执行这三步。尽管浏览器可以实现多线程并行下载，但是必须依次执行。要实现非阻塞js有两个方法： html5中的defer和async关键字 123456&lt;script type=&quot;test/javascript&quot; defer src=&quot;foo.js&quot;&gt;&lt;/script&gt;//没有defer或async，浏览器会立即加载并执行指定的脚本，“立即”的意思是指不等待后续载入的文档元素，读到就立即执行&lt;script type=&quot;test/javascript&quot; async src=&quot;foo.js&quot;&gt;&lt;/script&gt;//有async，加载和渲染后续文档元素的过程将和foo.js的加载与执行并行进行（异步）&lt;script type=&quot;test/javascript&quot; defer src=&quot;foo.js&quot;&gt;&lt;/script&gt;//有defer，加载后续文档元素的过程将和foo.js的加载并行进行(异步)，但是foo.js的执行要在所有元素解析完成之后，DOMContentLoaded事件触发之前完成 动态加载js（比如：使用setTimeout方法） 后记：setTimeout和setIntervalsetTimeout和setInterval都是指过一段时间，再进行某项操作。setTimeout是让一段代码在指定时间运行（次数是一次），而setInterval是让一段代码每过指定时间就运行一次setInterval的坑：如果间隔时间可能小于定时调用的代码的执行时间，而js是单线程，将定时调用的代码插入到队列中，但是代码中如果已经有了一份没有执行的同意的代码，时间间隔或许会被跳过。","categories":[],"tags":[],"keywords":[]},{"title":"Web语义化","slug":"Web语义化","date":"2017-07-10T08:53:48.000Z","updated":"2017-07-10T09:29:13.939Z","comments":true,"path":"2017/07/10/Web语义化/","link":"","permalink":"https://aliceflaviawang.github.io/2017/07/10/Web语义化/","excerpt":"","text":"web语义化的含义web语义化是指在进行html结构、表现、行为设计时，尽量使用语义化标签，使程序简洁明了，易于进行web操作和网站SEO，方便团队协作的一种标准，以期实现一种“无障碍”的web开发。SEO:搜索引擎优化，指对网站进行站内优化和站外优化，从而提高网站关键词排名以及公司产品的曝光度。 web语义化的作用 有利于机器识别，方便SEO 代码简洁明了，利于阅读和维护，方便以后扩展 有利于团队协作，减少出错率，使工作有个统一标准web语义化分类1、HTML标签语义化HTML为网页文档提供上下文结构和含义。对于HTML体系而言，Web语义化是指使用恰当的标签，是页面有良好的结构，让页面元素有含义，便于被浏览器、搜索引擎解析。一个经典的页面结构：2、ARIA无障碍web规范应用于HTML的ARIA有两部分组成：role和aria-*其中role标识了一个元素的作用，aria-描述了与之有关的事物特征及状态比如：作用是导航3、CSS命名语义化css语义就是class和id命名的语义，用易于理解的名称对html标签附加class和id命名。如果说html语义化是给机器看的，那么css命名的语义化就是给人看的。良好的css命名减少沟通调试成本。4、URL语义化url语义化，可以使得搜索引擎或者爬虫更好的理解当前url所在目录所需要表达的内容；而对于用户来说，通过url也可以判断上一级目录或者下一级目录想要表达的内容，可以提高用户体验。","categories":[],"tags":[],"keywords":[]},{"title":"Bootsstrap实现原理","slug":"Bootsstrap实现原理","date":"2017-07-10T06:30:43.000Z","updated":"2017-07-10T08:12:44.200Z","comments":true,"path":"2017/07/10/Bootsstrap实现原理/","link":"","permalink":"https://aliceflaviawang.github.io/2017/07/10/Bootsstrap实现原理/","excerpt":"","text":"1、整体架构下图为bootstrap整体架构图，共分为六大部分 1.1、12栅格系统12栅格系统就是把网页的总宽度平分为12份，我们可以自由组合。栅格系统使用的总宽度可以不固定，Bootstrap是按百分比进行平分。12栅格系统是整个Bootstrap的核心功能，也是响应式设计核心理念的一个实现形式。 1.2、jQueryBootstrap所以的javascript插件都依赖于jQuery 1.10+，如果要使用这些插件，那就必须引入jquery库。如果只使用css组件，那就可以不引用它了。 1.3、响应式设计响应式是一个理念而非功能，Bootstrap的内容都是以响应式设计为设计理念来实现的。响应式设计的目的：让页面有能力自动响应用户的设备环境。响应式网页设计就是一个网站兼容多个终端，而不是为每个终端做一个特定的版本。实践方式：由多方面决定，包括弹性网格和布局、图片、css媒体查询的使用等 2、栅格系统2.1 实现原理通过定义容器，平分12份（默认），再调整内外边距，最后结合媒体查询，就制作出了强大的响应式的栅格系统。 2.2 工作原理 一行数据（row）必须包含在.container中，以便为其赋予合适的对其方式和内边距 使用行（row）在水平方向创建一组（column） 具体内容应放置于（column）内，而且只有列（column）可以作为行（row）的直接子元素 使用像.row和.col-xs-4这样的方式来快速创建栅格布局 通过设置padding从而创建列（column）之间的间隔，然后通过第一列和最后一列设置负值的margin从而抵消掉padding的影响 栅格系统中的列是通过指定1到12的值来表示其跨越的范围container的作用 提供宽度限制。container随着页面宽度变化而变化，由于column的宽度是基于百分比的，所以它们的宽度不用去管。 提供左右padding，以至于文本内容不会触及浏览器边缘。Row Row是column的存放容器，Row中最多能放12个左浮动的column Row有个特殊的地方就是左右-15px的margin，这样刚好抵消了父容器container中的15px的paddingColumncolumn有左右15px的padding，所以位于两边的column有15px的padding，可以是内容不会碰到container的边界嵌套由于container和column都有15px的padding，所以嵌套时column就相当于container了，这样可以实现任意嵌套","categories":[],"tags":[],"keywords":[]},{"title":"前端面试准备","slug":"前端面试准备","date":"2017-07-03T09:03:08.000Z","updated":"2017-08-18T03:02:33.407Z","comments":true,"path":"2017/07/03/前端面试准备/","link":"","permalink":"https://aliceflaviawang.github.io/2017/07/03/前端面试准备/","excerpt":"","text":"1、cookie的优点及弊端如果步骤5携带的是过期或者错误的cookie，那么将认证失败，返回至要求身份认证页面。 优点：极高的扩展性和可用性1、通过良好的编程，控制保存在cookie中的session对象的大小2、通过加密和安全传输技术（SSL），减少cookie被破解的可能性3、只在cookie中存放不敏感数据，即使被盗也不会有重大损失4、控制cookie的生命期，使之不会永远有效。 缺点：1、cookie数量和长度的限制。每个domain最多只能有20条cookie，每个cookie长度不能超过4KB，否则会被截掉。2、安全性问题。如果cookie被拦截了，就可以获取所以的session信息。即使加密也于事无补，因为拦截者不需要知道cookie的意义，只需要原样转发cookie就行了。3、有些状态不可能保存在客户端。如：为了防止重复提交表单，在服务器端保存计数器，如果计数器放在客户端就起不了任何作用。 sessionsession是一种服务器端机制，服务器类似于散列表的结构来保存信息。当程序需要为客户端请求创建一个session时，服务器首先检查这个客户端的请求是否包含了session标志（session id），如果已包含则说明服务端曾经为用户创建过session，服务器就按照session id将session检索处理（检索不到会新建），如果不包含则会新建session并生产与之关联的session id（既不重复也不容易被找到规律仿造），找个session id将在本次响应中返回给客户端保存（保存这个session id的方式可以用cookie，另外还有两种方式：基于url path parameter默认支持的，基于SSL，默认不支持）。 补充sessionsessionid是一个会话的key，浏览器第一次访问服务器会在服务端生成一个sessionid和它对应。以tomcat为例，session在访问tomcat服务器HttpServerRequest的getSession(true)的时候创建，tomcat的ManagerBase类提供创建sessionid的方法：随机数+时间+jvmid;存储：存储在服务器的内存中，客户端只保存sessionid到cookie中。创建：sessionid第一次产生是在直到某server端程序调用HttpServletRequest.getSession(true)这样的语句时才被创建删除：超时；程序调用HttpSession.invalidate();程序关闭 cookie与session的区别 cookie有大小和个数的限制，单个cookie大小不超过4kb，很多浏览器限制一个站点最多保存20个cookie cookie保存在客户端，session保存在服务器端 cookie不是很安全，别人可以分析存放在本地的cookie并进行欺骗；因此建议将登陆等重要信息保存在服务器端，其他信息放在cookie中 session会在一定时间内保存在服务器上，当访问增多，会比较占用服务器的性能，考虑到减轻服务器的负担应当使用cookie2、浏览器的本地存储（web storage）js提供了sessionStorage和globalStorage。在HTML5中提供了localStorage取代了globalStorage。sessionStorage用于本地存储一个会话（session）中的数据，这些数据只在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁，sessionStorage不是一种持久化的本地存储。而localStorage用于持久化的本地存储，除非主动删除数据，否则数据永远不会过期。3、web storage和cookie的区别web storage与cookie类似，但是它是为更大容量存储设计的。cookie的大小受限，并且每次请求一个新的页面的时候cookie都会被发送过去，这样无形浪费了带宽，另外cookie还指定了作用域，不可以跨域调用。除此之外，web storage拥有setItem, getItem, removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie,getCookie。但是cookie也是不可或缺的：cookie的作用是与服务器交互，作为HTTP规范的一部分而存在，而web storage仅仅作为本地存储数据而生。 CSS相关问题1、display:none和visibility：hidden的区别display:none 隐藏对应的元素，不给它分配空间，周围元素会合拢visibility:hidden 隐藏对应的元素，但是在文档布局空间仍保留原来的空间 2、css中link和@import的区别1）link属于HTML标签，@import是css提供的2）页面加载时，link同时被加载，而@import页面加载完后被加载的3）link无兼容问题4）link的样式权重高于@import 3、position的absolute和fixed共同点：1、改变行内元素的呈现方式，display被设置为block2、让元素脱离普通流，不占空间3、默认会覆盖到非定位元素上不同点：absolute是相对于它最近的非static定位的祖先元素来定位的fixed是根据屏幕视窗来定位的，屏幕滚动时位置不变 4、清除浮动的三种方式首先说下浮动与绝对定位的区别。float是一种不彻底的脱离文档流的方式，绝对定位是彻底的。float脱离文档流的时候，其他盒子会无视这个元素，但其他盒子内的文本依然会为这个元素让出位置，环绕在周围；而绝对定位，其他盒子内的文本都会无视它（不会让出位置）。比如：A为绝对定位，如果A使用的绝对定位，元素B会占据B之前的位置，与元素A重合在一起，并被元素A覆盖。若A为float：left，B内的文本跑到了A的右边，即实现了文字环绕浮动元素的功，元素B的背景和元素A的背景重合了一部分，这就是浮动元素脱离了正常的文档流但还是会影响布局。清楚浮动的三种方式：12345&lt;div class=&quot;outer&quot;&gt; &lt;div class=&quot;div1&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;div2&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;div3&quot;&gt;3&lt;/div&gt;&lt;/div&gt; css样式：123456789101112131415.outer&#123;border:1 px solid #ccc;background:#fc9;color:#fff;margin:50px auto;padding:50px;&#125;.div1&#123;width:80px;height:80px;background:red;float:left;&#125;.div2&#123;width:80px;height:80px;background:blue;float:left;&#125;.div3&#123;width:80px;height:80px;background:green;float:left;&#125; 方法一：增加新元素，应用clear：both123456&lt;div class=&quot;outer&quot;&gt; &lt;div class=&quot;div1&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;div2&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;div3&quot;&gt;3&lt;/div&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;&lt;/div&gt; CSS:1.clear&#123;clear:both;&#125; 在.outer的最后加入一个空的（只要是块就行，因为只有块才可以撑满），因为它在.outer的最下面，并且不是float的，它的存在定义了.outer的高度。必须有clear：both，不然只是标准流，会紧贴在第一行的底部，不能涵盖其他div。注：clear的取值如下：none：默认值，允许两边都可以浮动left：不允许左边浮动对象right：不允许右边有浮动对象both：不允许有浮动对象清除浮动只能影响清除的元素本身，不能影响其他元素，比如，div1的右边有浮动元素div2,在div1的css样式中加入clear：right不起任何作用，只能在div2的css样式中加clear：left。要想让上述三个div垂直排列，可以增加css样式：123456.div2&#123;clear:left;&#125;.div3&#123;clear:left;&#125; 方法二：overflowfloat元素的父元素设置overflow:hidden|auto|scroll(不能使用visible)，overflow不是清除float而是新建BFC，BFC类似于编程语言里的作用域，作用域变了，float就影响不到了，只有clear可以取消float的影响。123.outer&#123;overflow:auto;&#125; 方法三：伪元素：after利用:after在元素内部插入一个元素块，从而达到清除浮动的效果，其实现原理类似于clear：both。区别在于：clear是在html插入一个div.clear标签，而outer利用其伪类:after在元素内部增加了一个类似于div.clear的效果。12345678.outer:after&#123; content:&quot;.&quot;; display:block; clear:both; visibility:hidden; height:0; width:0;&#125; 5、CSS的盒子模型：W3C盒子模型和IE盒子模型盒模型：content（内容）、padding（填充）、border（边框）、margin（边界）IE的width包含padding和border，而W3C仅包含content。 在这个地方顺便提下css的box-sizing属性，box-sizing主要是允许以特定的方式定义匹配某个区域的特定元素。有三种取值：1.content-box：规定宽度高度，不包括padding、border、margin 2. border-box:规定宽度高度，包括padding和boder 3. inherit：规定从父元素继承box-sizing属性的值。 6、CSS选择符有哪些？哪些属性可以继承？优先级算法如何计算？CSS3新增的伪类？一1、id选择器 #id2、类选择器 .classname3、标签选择器 p，span4、相邻选择器 div+p5、子选择器 ul&gt;li6、后代选择器 li a7、通配符选择器 *8、属性选择器 a[rel=”external”]9、伪类选择器 a:hover, li:nth-child 二可继承的样式（大部分针对字体）：font-size,font-family,color,text-indent不可继承的样式：border，padding，margin，width，height 三CSS优先级由四个级别和四个级别出现的次数决定，四个级别分别为：行内选择符、ID选择符、类选择符、元素选择符。CSS specificity是一个四位数用来衡量优先级。如：div #id {font-size:12px;}1个div元素，specificity为0,0,0,1一个id选择符，specificity为0,1,0,0最终：specificity为0,1,0,1注意： ！important的优先级是最高的，但出现冲突时则需比较四位数 优先级相同时采取就近原则 继承得来的属性，优先级最低 specificity从左到右比较，大的优先级越高四CSS伪元素： :after匹配该元素的一个虚拟的最后子元素，配合content使用，默认为行内元素 :before匹配该元素的一个虚拟的最先子元素，与:after类似 :first-line匹配元素的第一行 :first-letter匹配元素的第一个字符 :selection匹配用户鼠标选中的部分（只应用background、color、cursor、outline属性）CSS伪类： :link未被访问的链接 :visited被访问过的链接 :hover用户鼠标移至其上方 :active被激活的元素，通常指鼠标按下到松开的那段时间 :focus元素成为焦点 :first-child元素为其父元素的第一个子元素 :last-child元素为其父元素的最后一个子元素 :nth-child(an+b)匹配为其父元素的第an+b个子元素的元素 :nth-last-child(an+b)同上但是顺序相反 :first-of-type匹配所有子元素类型第一个出现的元素 :last-of-type匹配元素中所有子元素类型最后一个出线的元素 :enabled :disabled 控制表单控件的禁用状态 ：checked 单选框或是复选框被选中注意：first-child和first-of-type的区别，first-child匹配的是其父元素的第一个子元素，而first-of-type匹配到的是该类型的第一个。举个例子：123456&lt;div&gt; &lt;p&gt;第一个子元素&lt;/p&gt; &lt;h1&gt;第二个子元素&lt;/h1&gt; &lt;span&gt;第三个子元素&lt;/span&gt; &lt;span&gt;第四个子元素&lt;/span&gt;&lt;/div&gt; p:first-child 匹配到p元素，因为p是div的第一个子元素h1:first-child 匹配不到任何元素，因为h1不是第一个子元素同理span:first-child也匹配不到p:first-of-type 匹配到p元素，因为p元素是div所有为p的子元素的第一个h1:first-of-type 匹配到h1元素，因为h1元素是div所有为h1的子元素的第一个span:first-of-type 匹配到第三个子元素span，这里div有两个为span的元素，匹配到的是第一个 7、列出display的值，说明他们的作用。position的值，relative和absolute分别是对于谁进行定位。 none 此元素不会被显示 block 此元素会显示为块级元素，前后会带有换行符 inline 此元素会被现实为内联元素，前后没有换行符 inline-block 行内块元素 list-item 此元素作为列表显示 问的比较多的就是inline,block,inline-block，详细比较一下它们： display：block block元素会独占一行，多个block元素会各自新起一行。默认情况下，block元素宽度自动填满其父元素宽度 block元素可以设置width、height属性。块级元素即使设置了宽度，仍然独占一行 block元素可以设置margin和padding属性display:inline inline元素不会独占一行，多个相邻的行内元素会排列在同一行里，直到一行排列不下，才会新换一行，其宽度随元素的内容而变化 inline元素设置width、height无效 inline元素的margin和padding属性，水平方向的padding-left,padding-right,margin-left,margin-right都产生边距效果，但竖直方向的padding-top,padding-bottom,margin-top,margin-bottom都不起作用。display：inline-block简单来说，就是将对象呈现为inline对象，但对象的内容作为block对象呈现。之后的内联对象会被排列在同一行内。比如给一个link（a元素）inline-block属性值，使其既具有block高度宽度特性又具有inline同行特性。 2. static 默认值，元素处于正常的文档流之中，top,right,bottom,left,z-index（设置元素的堆叠顺序）属性无效 relative 元素相对原本正常位置的定位，不改变布局，这样会在此元素原本所在的位置留下空白，对display为表格型的元素无效 absolute 不为元素预留空间，元素相对于与它最近的非static定位的祖先元素来定位。元素可以设置外边距（margin），并且不会与其他边距合并（即形成一个BFC） fixed 不为元素预留空间，相对屏幕视窗定位，屏幕滚动时位置不变 sticky （新属性，目前仅firefox实现）平时为relative，在特定条件下变为fixed，类似于实现浮动条-inherit 从父元素继承position属性的值8、对BFC规范的理解BFC，块级格式上下文，一个创建了新的BFC的盒子是独立布局的，盒子里面的子元素的样式不会影响到外面的元素。在同一个BFC中的两个毗邻的块级盒在垂直方向的margin会发生折叠。9、CSS spiriteCSS spirite把网页中的背景图片整合到一张图片文件中，再利用CSS的background-image, background-rep10、text-overflow(这个属性貌似问的比较多)text-overflow规定文本溢出包含元素时发生的事情。包含以下属性： clip:修剪文本 ellipsis：显示省略号来代表被修剪的文本 string：使用给定的字符串来代表被修剪的文本注意ellipsis要与overflow：hidden，white-space:nowrap一起使用(white-space规定了文本不换行) HTML1、DOCTYPE&lt;!DOCTYPE&gt;位于html文档的第一行，它并不是一个html标签。它的作用是告诉浏览器以哪种模式来解析文档。HTML 5只有一种DOCTYPE声明，&lt;!DOCTYPE html&gt;HTML 4.01有三种：strict、transitional、frameset。 2、HTML5新特性 语义化标签（header、nav、footer、aside、article、section） 拖放事件（drag类事件） 跨文档消息传递（postMessage） 媒体元素（audio、video标签） 地理位置定位（navigator、geolocation）API 历史状态管理（更新history对象，pushstate等）HTML5离线存储技术用户离线时，可以正常访问站点时，联网可以更新缓存，使用方法就是在html标签中加入manifest属性，如下：1234&lt;!DOCTYPE html&gt;&lt;html manifest=&quot;cache.manifest&quot;&gt;...&lt;/html&gt; cache.manifest文件格式如下：12345678910111213CACHE MANIFESTCACHE:js/app.jscss/style.cssNETWORK:resource/logo.pngFALLBACK:/ /offline.html 离线缓存的manifest一般由三个部分组成： CACHE:表示需要离线存储的资源列表 NETWORK:表示在它下面列出来的资源只有在有线的情况下才能访问，他们不会被离线存储 FALLBACK:(实例里’/ /‘不是注释）表示如果访问第一个资源失败，那么就使用第二个资源来替换它，比如上面这个文件表示的就是如果访问根目录下任何一个资源失败了，那么就去访问offline.html。3、iframe的优缺点优点： 重载页面时不需要重载整个页面，只需要重载页面中的一个框架页（减少了数据的传输，加快了网页下载速度 技术容易掌握，使用方便，可主要应用于不需搜索引擎来搜索的页面 方便制作导航栏缺点 最大的缺点四搜索引擎无法解读这种页面 框架结构让人迷惑 浏览器后退按钮失效（之呢个针对当前光标所在页面的前进和后退）4、如何实现浏览器多个标签页之间的通信调用localStorage、cookie等本地存储方式5、WebSocket如何兼容低浏览器WebSocket123456789101112131415161718192021//创建WebSocket实例var socket=new WebSocket(&quot;ws://licalhost:8080&quot;);//打开WebSocketsocket.onopen=function(event)&#123; //发送一个初始化消息 socket.send(&apos;I am a client and i am listening&apos;);&#125;//监听消息socket.onmessage=function(event)&#123; console.log(&apos;Client received a message&apos;); &#125;//监听关闭socket.onclose=function(event)&#123; console.log(&apos;WebSocket closed&apos;);&#125;//关闭socket//socket.close(); WebSocket是HTML5出的协议，是一个持久化的协议，相对于http这种非持久化的协议来说。WebSocket是基于http协议的，在握手阶段是一样的，不同的是http每个request接收一个response，这个response是被动的，不能主动发起。在讲WebSocket之前，先说long poll和ajax轮询。ajax轮询：让浏览器每隔几秒就发送一次请求，询问服务器是否有新消息。long pull:跟ajax轮询差不多，不过采取的是阻塞模型（不收到消息就不发response给客户端，知道有消息才返回，返回完后再次建立连接，周而复始）。这两种方式都是不断建立http连接，然后等待服务器端处理，体现了http协议的被动性。而且两种方式都非常消耗资源，ajax需要服务器有很快的处理速度和资源，long poll需要很高的并发。 WebSocket的作用WebSocket解决了http协议的被动性，服务器可以主动推送消息给客服端，只需要经过一次请求，就可以源源不断的消息传送；另外http是无状态的，每次都要传输identity info（鉴别信息）来告诉服务器你是谁，而WebSocket只需要一次握手，整个通讯过程都是建立在一次连接/状态中，避免了http的非状态性，服务器端会一直知道你的信息知道关闭请求。 如何在不支持WebSocket的客户端上使用实际上是不能，但是可以通过上面说的long poll和ajax轮询来实现类似的效果 6、null和undefined的区别nullnull表示的是一个“无”的对象，转为数值时为0典型用法： 作为函数的参数，表示该函数的参数不是对象 作为原型链的终点undefinedundefined表示的是一个“无”的原始值，转为数值是NaN典型用法： 变量被声明了，但是没有赋值时，就等于underfined 调用函数时，应该提供的参数没有提供，该参数等于undefined 对象没有赋值的属性，该属性的值为undefined 函数没有返回值时，默认返回undefined7、new操作符具体干了什么1234var Fun=function()&#123; &#125;var func=new Func();&#125; new共经历了四个阶段： 创建一个空对象1var obj=new Object(); 2、设置原型链1obj._proto_=Func.prototype;(继承构造函数的属性和方法) 3、让Func中的this指向obj，并执行Func函数体1var result=Func.call(obj); 8、跨域问题同源策略在讲跨域问题之前先说同源策略。一个url由协议、域名、端口和路径组成，如果两个url协议、域名、端口相同，则表示它们同源。浏览器的同源策略是指一个域上加载的脚本不允许访问另一个域的文档属性。 跨域方法1、跨域资源共享（CORS)创建CORS请求对象因为CORS是属于XMLHttpRequest2的一部分，所以主要要做的就是区分IE8/9和不支持XMLHttpRequest的浏览器1234567891011121314151617181920212223function createCoresRequest(method,url)&#123; var xhr=new XMLHttpRequest(); if(&apos;withCredentials&apos; in xhr)&#123; //支持CORS //检查XMLHttpRequest对象是否有&quot;withCredentials&quot;属性，withCredentials仅存在xmlHttpRequest对象里 xhr.open(method,url,true); &#125; else if(window.XDomainRequest)&#123; //XDomainRequest仅存在IE中，是IE用于支持CORS请求的方式 xhr=new C=XDomainRequest(); xhr.open(method,true); &#125; else&#123; //不支持CORS xhr=null; &#125; return xhr; &#125; var xhr=createCORSRequest(&quot;GET&quot;,url); if(!xhr)&#123; throw new Error(&apos;CORS not supported&apos;); &#125; xhr.send();//发送请求 CORS是W3C提出的跨域请求方案，需要服务器端的支持。服务器端对CORS的支持主要通过设置HTTP头Access-Control-Allow-Origin实现，如果浏览器检测到相应的设置，就能允许AJAX跨域请求。 2、通过jsonp跨域JSONP也叫填充式json，是应用json的新方法，只不过是包含在函数中调用json，例如：1callback(&#123;&quot;name&quot;,&quot;jack&quot;&#125;) JSONP由两部分组成：回调函数和数据。回调函数是当响应到来时在页面中调用的函数，数据是传入回调函数的json数据。在js中直接通过xmlHttpRequest请求不同域上的数据时，是不行的，但是，在页面上引入不同域的js脚本文件却是可以的，jsonp正是利用这个特性来实现的。123456&lt;script type=&quot;test/javascript&quot;&gt; function dosomething(jsondata)&#123; //处理json数据 &#125;&lt;/script&gt;&lt;script src=&quot;http://example.data/data.php?callback=dosomething&quot;&gt;&lt;/script&gt; js文件载入成功后会执行url中指定的函数，并把需要的json数据作为参数传入该函数。如果页面使用的是jquery，那么通过它封装的方法就能很方便的来进行JSONP操作。12345&lt;script type=&quot;text/javascript&quot;&gt; $.getJSON(&quot;http://example.data/data.php?callback=?,function(jsondata)&quot;)&#123; //处理获得json数据 &#125;）&lt;/script&gt; jQuery会自动生成一个全局函数来替换callback=？中的？，之后获取的数据又会自动销毁，实际上就是起一个临时代理函数的作用。$.getJSON方法会自动判断是否跨域，如果不跨域，就用普通的ajax方法，跨域的话，就会异步加载js文件的形式来调用jsonp的回调函数。 JSOPN的优缺点 优点：不像XMLHttpRequest对象实现得Ajax请求那样受到同源策略的限制，它的兼容性更好，不需要XMLHttpRequest或ActiveX的支持，并且在请求完毕后可以通过调用callback方式回传结果。 缺点：它支持GET请求而不支持POST等其他类型的HTTP请求，它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行javascript调用的问题。CORS和JSONP的对比 JSONP只支持GET类型的http请求，CORS支持所有类型的http请求 CORS，开发者可以使用普通的XMLHttpRequest发起请求和获取数据，有更好的错误处理 JSONP主要被老的浏览器支持，它们往往不支持CORS，对大多数现代浏览器都已经支持CORS了3、通过修改document.domain来跨域（iframe）浏览器的同源策略的两个限制：一、不能通过ajax方法去请求不同源的文档；二、浏览器中不同框架是不能进行js交互操作的。比如：有一个页面，它的地址是”http://www.example.com/a.html&quot;，这个页面里有个iframe，它的iframe的src是&quot;http://example.com/a.html&quot;，很显然这个页面与它的iframe框架是不同域的，所以无法通过js代码来获取iframe的东西。此时document.domain就排上用场了，但是document.domain的设置有限制，只能将其设置成自身或者父域，且主域必须相同。 “http://www.example.com/a.html&quot;页面设置document.domain 1234567&lt;iframe id=&quot;iframe&quot; src=&quot;http://example.com/a.html&quot; onload=&quot;test()&quot;&gt;&lt;/iframe&gt;&lt;script type=&quot;text/javascript&quot;&gt; document.domain=&quot;example.com&quot;;//设置成主域 funtion test()&#123; alert(document.getElementById(&quot;#ifrme&quot;).contentWindow);//可取得子窗口的window对象 &#125;&lt;/script&gt; “http://example.com/a.html&quot;设置document.domain 1234&lt;script type=&quot;text/javascript&quot;&gt; document.domain=&quot;example.com&quot;;//设置成主域&lt;/script&gt; 注：document.domain只适用于不同子域的框架中。 4、window.name在一个窗口的生命周期内，不同url共享同一个window.name，每个页面对window.name都有读写权限，且window.name持久存在一个窗口在载入过的所有页面中。 5、HTML5的window.postMessage方法HTML5的新特性，不能实现与服务器交换数据，只能在不同的iframe中使用。html5提供了两个重要的接口：postMessage(send)和onmessage。一个页面通过postMessage发送消息，另一个页面监听消息。例如：父页面向子页面发送消息，父页面代码：123456789101112131415161718192021222324&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;崔涣 iframe postmessage 父页面&lt;/title&gt; &lt;script type=&quot;text/JavaScript&quot;&gt; function sendIt() &#123; // 通过 postMessage 向子窗口发送数据 document.getElementById(&quot;otherPage&quot;).contentWindow .postMessage( document.getElementById(&quot;message&quot;).value, &quot;http://cuihuan.net:8003&quot; ); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 通过 iframe 嵌入子页面 --&gt;&lt;iframe src=&quot;http://cuihuan.net:8003/test.html&quot; id=&quot;otherPage&quot;&gt;&lt;/iframe&gt;&lt;br/&gt;&lt;br/&gt;&lt;input type=&quot;text&quot; id=&quot;message&quot;/&gt;&lt;input type=&quot;button&quot; value=&quot;Send to child.com&quot; onclick=&quot;sendIt()&quot;/&gt;&lt;/body&gt;&lt;/html&gt; window.postMessage(message,targetOrigin).postMessage必须包含两个参数，第一个参数是发送的信息，第二个参数是目标域名。子页面代码：123456789101112131415161718&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;崔涣测试子页面信息&lt;/title&gt; &lt;script type=&quot;text/JavaScript&quot;&gt; //event 参数中有 data 属性，就是父窗口发送过来的数据 window.addEventListener(&quot;message&quot;, function( event ) &#123; // 把父窗口发送过来的数据显示在子窗口中 document.getElementById(&quot;content&quot;).innerHTML+=event.data+&quot;&lt;br/&gt;&quot;; &#125;, false ); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; this is the 8003 port for cuixiaozhuai &lt;div id=&quot;content&quot;&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 处于安全方面的考虑，可以对域或数据规则进行安全校验：12345678910111213141516171819202122232425window.addEventListener(&apos;message&apos;, function (event) &#123; //校验函数是否合法 var checkMessage = function () &#123; // 只获取需要的域，并非所有都可以跨域 if (event.origin != &quot;need domain&quot;) &#123; return false; &#125; var message = event.data; // 传输数据类型校验 if (typeof(message) !== &apos;object&apos;) &#123; return false; &#125; // message 的rule中包含xxx则为xxx需要字段。 return message.rule === &quot;xxx&quot;; &#125;; if (checkMessage()) &#123; // 通过校验进行相关操作 addDetailFunc(event); &#125; &#125;); 9、document.write和innerHTML的区别document.write是直接写入页面的文档流，如果写之前没有调用document.open，浏览器会自动调用open，每次写完之后重新调用该函数，会导致整个页面的重绘。innerHTML能精确到某个具体的元素来更改，只对页面的部分重绘。 10、内存泄露内存泄漏：是指任何对象不再拥有或需要它之后仍然存在。javascript有自动垃圾回收机制，一旦数据不再使用，可以将其设为null来释放引用。造成内存泄漏的集中操作： 循环引用一个DOM对象被一个javascript对象引用，与此同时又引用同一个或其他的javascript对象，这个DOM对象可能会引发内存泄露。这个DOM对象的引用将不会在脚本停止的时候被垃圾回收器回收。要想破坏引用，引用DOM元素的随想或DOM对象的引用需要被赋值为null。 闭包在闭包中引入闭包外部的变量时，当闭包结束时此对象无法被垃圾回收。 123456var a=function()&#123; var largeStr=new Array(1000000).join(&quot;x&quot;); return function()&#123; return largeStr; &#125;&#125;(); DOM泄露父节点被删除时，子节点引用没有被移除则无法回收。 123456789101112131415var select=document.querySelector;var treeRef=select(&quot;#tree&quot;);var leaf=select(&quot;#leaf&quot;);//#leaf是#tree的子节点var body=select(&quot;body&quot;);body.removeChild(treeleaf);//#tree不能被回收，因为treeLeaf还在//解决方案treeRef=null;//tree不能被回收，一位内叶子leaf还在leaf=null;//现在#tree被释放了 4、Timer定时器泄露定时器也是常见的产生泄露的地方12345678910111213for(var i=0;i&lt;90000;i++)&#123; var b=&#123; callAgain:function()&#123; var ref=this; var val=setTimeout(function()&#123; ref.callAgain(); &#125;,90000); &#125; &#125;b.callAgain();//虽然很想收回但是timer还在b=null;&#125; 11、作用域链作用域链、闭包、原型链是javascript中比较重要的知识点。 javascript中的作用域每一种语言都有作用域的概念，所谓作用域就是变量和函数的可用范围，确定了变量和函数的可见性和生命周期。javascript中有两种作用域，全局作用域和局部作用域。 全局作用域以下情况一般拥有全局作用域 全局声明的函数和变量 没有定义直接赋值的变量 所以window属性局部作用域在函数内部声明的函数和变量只能在函数内部访问到，即拥有局部作用域。作用域链javascript中，一切都是对象，包括函数。而函数有一个内部属性[[scope]]，里面包含了函数的可访问的作用域对象的集合，这个集合被称为作用域链。作用域链的创建作用域链在函数执行时创建。作用域的前端，始终是当前环境的变量对象。如果这个环境是函数，则将其活动对象作为变量对象，里面包含了该函数的所有局部变量、参数及this。把作用域链当成一个对象数组，先把该函数的变量对象push进数组，然后把函数的外部环境的作用域push进数组，下一个就是外部环境的外部环境的变量对象，一直往外直到全局环境，即作用域链的最后一个对象肯定是全局环境的作用域。作用域链的作用作用域链的目的是保证当前环境对可访问的变量和函数的有序访问。具体实现是：函数内部标识符解析时会沿着作用域链一级一级地搜索。搜索的过程始终从作用域链前端开始，直到最后一个对象即全局变量对象为止，如果找不到的话，就是undefined。这样可以保证内部变量的优先级始终大于外部变量。变量提升的问题1234567var name=&quot;123&quot;;function foo()&#123; console.log(name); //undefined var name=&quot;456&quot;; console.log(name); //456&#125;foo(); 以上例子，按常规连接，应该先输出全局变量“123”，再输出局部变量“456”，然而第一个却输出了undefined，为什么呢？因为函数在执行时首先胡创建作用域链，这是在整个函数执行之前就完成的，所以第一次输出时，该函数的变量对象已经包含了name这个变量，从而导致解析时在作用域链第一个对象就停止，，而不会访问到全局变量，同时那个时候局部变量没有赋值，所以会输出undefined。这种现象叫做变量提升。注：ES6中通过let标识符可以防止这种现象的出现 作用域链的延长部分语句可以在作用域链的前端临时增加一个变量对象，该变量对象会在代码执行后移除。主要由两种情况 with语句 try-catch语句with语句平时优化需要可以把所需对象存储在局部变量中，不推荐使用with语句，可能造成bug和性能损失。12345678function foo()&#123; var he=&quot;?name=1&quot;; with(location)&#123; var url=href+he; &#125; return url;&#125;foo(); 这里with语句把location对象添加到作用域链前端，因此在访问href时，其实是访问了location.href。在with语句执行完毕后，作用域链就返回之前的状态。 catch块12345try&#123; something();&#125;catch(e)&#123; console.log(e);&#125; 当try代码块中的语句发生错误时，执行块跳转到catch语句块，并且把一个异常对象添加到作用域的头部。在catch语句执行完毕后，作用域链就返回之前的状态。注：可以把错误处理委托给一个函数。这样的话就只执行一条语句，并且没有访问局部变量，对性能影响就比较小。12345try&#123; something();&#125;catch(e)&#123; handleError(e);&#125; 12、闭包闭包的特性 函数嵌套函数 内部的函数可以引用函数外部的参数和变量 参数和变量不能被垃圾回收机制回收闭包的定义及其优缺点闭包：是指有权访问另一个函数作用域中的变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量。闭包的缺点：常驻内存，会增加大量的内存使用，使用不当会造成内存泄漏。闭包的应用：一是前面提到的读取函数内部的变量，二是让这些变量的值始终保持在内存中。看个例子：1234567891011121314function f1()&#123; var n=999; add=function()&#123; n+=1; &#125; function f2()&#123; alert(n); &#125; return f2;&#125;var result=f1();result();//999add();result(); result实际上就是闭包f2函数，它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。为什么会这样呢？因为f1是f2的复函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制回收。另外要注意add，首先add前面没有使用var关键字，因此add是一个全局变量，而不是局部变量。其次add的值是一个匿名函数，而这个匿名函数本身也是一个闭包，所以add相当于一个setter，可以在函数外部对函数内部的局部变量进行操作。 闭包使用注意点 由于闭包会使得函数中的变量都保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页性能问题，IE中可能导致内存泄漏。解决办法是，在退出函数之前，将不适用的局部变量全部删除。 闭包会在父函数外部，改变父函数内部变量的值。如果把父函数当作对象使用，把闭包当作它的公用方法，把内部变量当作它的私有属性，这是一定要小心，不要随便改变父函数内部变量的值。13、javascript中的this一般而言，javascript中this指向函数执行时的当前对象。换句话说，这个关键字与函数的执行环境有关，与声明环境无关。所以this的指向要看如何去调用这个函数而不是声明。不同的调用方式1、作为对象的方法调用把函数赋值给对象的一个属性，然后通过该对象调用该方法，此时函数的执行环境就是这个对象，所以this指向该对象。12345678var name=&quot;haha&quot;;var obj=&#123; name:&quot;hehe&quot;, show:function()&#123; console.log(this.name); &#125;&#125;obj.show(); //hehe 换种更清晰的方式，我们把声明和调用放在两个对象里面1234567891011var obj=&#123; name:&quot;hehe&quot;, show:function()&#123; console.log(this.name) &#125;&#125;var t_obj=&#123; name:&quot;lala&quot;, show:obj_show&#125;t_obj.show(); //lala 可以看到show虽然在obj中声明过，但是通过t_obj调用了这个方法，所以此时this指向t_obj。 2、作为函数调用我们将上面的代码改一下，将obj.show赋值给全局变量show再调用，此时this绑定到全局对象。123456789var name=&quot;lala&quot;;var obj=&#123; name:&quot;hehe&quot;, show:function()&#123; console.log(this.name); &#125;&#125;var show=obj.show;show(); //lala 3、独立函数调用在函数内部调用一个函数，比如在一个对象的方法里面调用一个函数时，this会指向全局对象(讲道理的话应该指向对象），实际上是不带任何修饰的函数引用进行调用时，默认this指向全局变量。这是javascript设计比较坑的地方，平时经常使用命名一个新变量ctx(context，即上下文环境)替代this。1234567891011var name=&quot;lala&quot;;var obj=&#123; name:&quot;hehe&quot;, show:function()&#123; var test=function()&#123; console.log(this.name); &#125; test(); &#125;&#125;obj.show(); //lala 修正版12345678910111213var name=&quot;lala&quot;;var obj=&#123; name:&quot;hehe&quot;, show:function()&#123; var txt=this; console.log(this);//obj var test=function()&#123; console.log(this.name); &#125; test(); &#125;&#125;obj.show(); // hehe 再看一个例子123456789var name=&quot;lala&quot;;function b()&#123; var name=&quot;hehe&quot; function a()&#123; console.log(this.name); &#125; a();&#125;b(); //lala 修改1234567891011var name=&quot;lala&quot;;function b()&#123; var cxt=this; console.log(this);//window var name=&quot;hehe&quot; function a()&#123; console.log(ctx.name); &#125; a();&#125;b(); //lala 可以看到对比上一个例子，obj.show中的this指向obj，而第二个例子由于b是独立函数，b中的this指向全局对象，有一个误区认为this指向执行的函数，实际上不是的。 4、作为构造函数使用我们常使用new构造函数名()来创建一个对象，此时函数中的this指向新创建的对象。如果不使用new，则和普通函数一样绑定到全局对象。12345function Foo()&#123; console.log(this);&#125;var test=new Foo(); //testFoo(); //window 5、在setTimeout、setInterval和匿名函数中在setTimeout,setInterval和匿名执行时的对象为全局对象，所以this也指向全局对象。12345678910var name=&quot;lala&quot;;var obj=&#123; name:&quot;hehe&quot;, show:function()&#123; setTimeout(function()&#123; console.log(this.name); &#125;,500); &#125; &#125;obj.show(); 6、函数调用call和apply方法时两者的本质就是改变函数当前的上下文环境即this，两者的区别是call接收一个个参数，而apply接受一个参数数组。注：使用call和apply函数的时候要主要，如果传递的this值不是一个对象，javascript将会尝试使用内部ToObject操作将其转换为对象。因此，如果传递的值，如果传递的值是一个原始值比如7或者”foo”，那么就会使用相关构造函数将它转换为对象，所以原始值7通过new Number(7)被转换为对象，而字符串”foo”使用new String(“foo”)转化为对象。 7、函数调用bind方法时函数调用bind方法时会创建一个有相同函数体和作用域的函数，新函数的this指向bind的第一个参数。该方法不会调用函数，而是返回新函数。 14、prototype和原型链每个函数都有一个prototype属性，这个属性是指向一个对象的引用，这个对象称为原型对象，原型对象包含函数实例共享的方法和属性，也就是说将函数用作构造函数调用的时候，新创建的对象会从原型对象上继承属性和方法。不像传统的面向对象语言，javascript的继承机制基于原型，而不是class类。 1、javascript的设计意图 私有变量、函数javascript的作用域链，在函数内定义的变量和函数如果不对外提供接口，外部将无法访问到，也就是变为私有变量和私有函数。 12345678function Obj()&#123; var a=0; //私有变量 var fn=function()&#123; //私有函数 &#125;&#125;var o=new Obj();console.log(o.a) //undefinedconsole.log(o.fn) //undefined 静态变量、函数当定义一个函数后，通过“.”为其添加属性和函数，通过对象本身仍然可以访问得到，但是其实例访问不到，这样的变量和函数分别被称为静态变量和静态函数。 12345678910function Obj()&#123;&#125; Obj.a=0; //静态变量 Obj.fn=function()&#123; //静态函数 &#125;console.log(Obj.a) //0console.log(Obj.fn) //function()&#123; //静态函数 &#125;var o=new Obj();console.log(o.a) //undefinedconsole.log(o.fn) //undefined 实例变量、函数在面向对象编程中除了一些库函数我们还希望在对象定义的时候同时定义一些属性和方法，实例化后可以访问，javascript也可以做到这样。 1234567891011function Obj()&#123; this.a=[]; //实例变量 this.fn=function()&#123; //实例函数 &#125; &#125;console.log(typeof Obj.a) //undefinedconsole.log(typeof Obj.fn) //undefinedvar o=new Obj();console.log(typeof o.a) //objectconsole.log(typeof o.fn) //function 这样可以达到目的，然而12345678910111213function Obj()&#123; this.a=[];//实例变量 this.fn=function()&#123; //实例方法 &#125;&#125;var o1=new Obj();o1.a.push(1);o1.fn=&#123;&#125;; console.log(o1.a); //[1]console.log(typeof o1.fn); //objectvar o2=new Obj();console.log(o2.a); //[]console.log(typeof o2.fn) //function 虽然可以实例访问了，但是在o1中修改了a和fn，在o2中没有改变，由于数组和函数都是对象，是引用类型，这说明o1和o2中的属性和方法虽然同名但不是一个引用，而是对Obj对象定义的属性和方法的一个复制。这对属性来说没什么问题，但是对方法来说，因为方法都是在做完全一样的功能，但是却有两份复制，如果一个函数对象有上千个实例方法，每个实例都要保持一份上千个方法的复制，这显然不科学，因此prototype应运而生。原型对象的主要目的是让所有对象实例共享它所包含的属性和方法。 2、prototype原型在javascript中，所有都是对象。但对象是有区别的，分为普通对象和函数对象。凡是通过new Funtion()的方式创建的对象都是函数对象，其他都是普通对象。每个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。prototype就是调用构造函数而创建的那个对象实例的原型对象。普通对象没有prototype，但是有proto属性。原型对象其实就是普通对象（Funtion.prototype除外，它是函数对象，但它很特殊，它没有prototype属性（前面说函数对象都有prototype属性））。举个例子：123456function f1()&#123;&#125;;console.log(f1.prototype) //f1&#123;&#125;console.log(typeof f1.prototype) //objectconsole.log(typeof Function.prototype) // function，这个特殊console.log(typeof Object.prototype) // objectconsole.log(typeof Function.prototype.prototype) //undefined 从console.log(f1.prototype)//f1{}看出，f1.prototype就是f1的实例对象。就是f1创建的时候，创建了一个实例对象并赋值给它的prototype，过程如下：12var temp=new f1();f1.prototype=temp; 所以Function.prototype为什么时函数对象就迎刃而解，上文提到凡是new Function产生的对象都是函数对象，所以temp1是函数对象：12var temp1=new Function();Function.prototype=temp1; 那原型对象是用来做什么呢？主要是用来继承，举个例子：12345678var person=function(name)&#123; this.name=name;&#125;person.prototype.getName=function()&#123; return this.name;//this指向源性对象&#125;var xpg=new Person(&quot;alice&quot;)xpg.getName() //alice 从这里看出，person.prototype设置了一个函数对象的属性，那由person实例出来的对象就继承了这个属性。具体继承机制看原型链。无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性（同时它也是一个对象），默认情况下prototype属性会默认获得一个constructor（构造函数）属性，这个属性是一个指向prototype属性所在函数的指针。12function Person()&#123; &#125; 可以看到Person对象会自动获得prototype属性，而prototype也是一个对象，会自动获得constructor属性，该属性正是指向Person对象。当调用构造函数创建一个实例的时候，实例内部将包含一个内部指针（proto）指向构造函数的prototype，这个连接存在于实例和构造函数的prototype之间，而不是实例与构造函数之间。12345678function Person(name)&#123; this.name=name;&#125;Person.prototype.printName=function()&#123; alert(this.name)&#125;var person1=new Person(&quot;Byron&quot;)var person2=new Person(&quot;Frank&quot;) Person的实例person1中包含了name属性，同时自动生成一个proto属性，该属性指向Person的prototype，可以访问到prototype内定义的printName方法： 3、原型链由于proto是任何对象都有的属性，而js里万物皆对象，所以会形成一条proto连起来的链。代码读取某个对象的属性的时候，都会执行一遍搜索，目标是具有给定名字的属性，搜索首先从对象实例开始，如果实例中找到该属性则返回，如果没有则查找prototype，如果还没有找到则继续递归prototype的prototype对象，直到找到为止，如果递归到object仍然没有怎返回错误。同理如果在实例中定义prototype同名的属性或函数，则会覆盖prototype的属性或函数。这就是javascript的原型链。12345var A = function()&#123;&#125;;var a = new A();console.log(a.__proto__); //A &#123;&#125;（即构造器function A 的原型对象）console.log(a.__proto__.__proto__); //Object &#123;&#125;（即构造器function Object 的原型对象）console.log(a.__proto__.__proto__.__proto__); //null 4、hasOwnProperty与in操作符in操作符是只要能访问到该属性就返回true，hasOwnProperty只有属性存在于实例中时才返回true。123456Object.prototype.bar=1var foo=&#123;moo:2&#125;for(var i in foo)&#123;if(foo.hasOwnProperty(i)) console.log(i) //输出两个属性： moo和bar&#125; 我们没有办法改变for in语句的行为，所以想过滤结果就只能使用hasOwnProperty方法，代码如下：1234for(var i in foo)&#123; if(foo.hasOwnProperty(i)) console.log(i) // moo&#125; 总结prototype指向该方法的原型对象，只有函数对象有prototypeproto是指向该对象的构造函数的原型对象，所有对象都有proto，proto是普通对象的隐式属性，在new的时候会指向该对象的构造函数的原型对象1234function F()&#123;&#125;var f=new F();f.__proto__==F.prototype //true 构造函数.prototype=原型对象原型对象.constructor=构造函数实例.proto=构造函数.prototypeisPrototypeof(实例对象)判断实例对象的原型是不是当前对象。","categories":[],"tags":[],"keywords":[]},{"title":"原生JavaScript实现Ajax","slug":"原生JavaScript实现Ajax","date":"2017-06-25T12:21:18.000Z","updated":"2017-08-17T02:18:36.053Z","comments":true,"path":"2017/06/25/原生JavaScript实现Ajax/","link":"","permalink":"https://aliceflaviawang.github.io/2017/06/25/原生JavaScript实现Ajax/","excerpt":"","text":"Ajax实现步骤： 创建XMLHttpRequest对象XMLHttpRequest用于在后台与服务器交换数据，可以在不重新加载整个网页的情况下，对网页的部分进行更新。12345var XHR=if(window.XMLHttpRequest)&#123; XHR=new XMLHttpRequest();&#125;else if(window.ActiveXObject)&#123;//IE6 XHR=new ActiveXobject(&apos;Microsoft.XMLHTTP&apos;);&#125; 注：ActiveXObject对象在IE11中已移除。 想服务器发送请求首先调用open方法，有五个参数（常用的前三个）： method:必须提供，用来指定发送请求的HTTP方法（GET, POST等） uri：请求的url，会被自动解析成绝对地址 async:请求是否是异步的，默认是true username, password:如果需要服务器验证用户，则设置username和password这两个参数。然后调用send方法，按照open方法设定的参数将请求进去发送123456789101112131415if(type==&apos;GET&apos;)&#123; //拼接GET方法的URL if(typeof(data)!=&apos;undefined&apos;)&#123; url+=&apos;?&apos;; for(i in data)&#123; url+=i+&apos;=&apos;+data[i]+&apos;&amp;&apos;; &#125; url=url.substring(0,url.length-1); //去掉最后一个&apos;&amp;&apos; &#125; XHR.open(type,url,true); XHR.send(null);&#125;else if(type==&apos;POST&apos;)&#123; XHR.open(type,url,true); XHR.send(data);&#125; 注：理论上GET方法也有body，但一般约定GET的参数都放在URL上，所以type为GET时，send的参数一般是null. get和post的区别它们的结构和使用方式相同，区别： get请求会将参数跟在url后进行传递，而post则是将参数作为http消息的实体内容发给web服务器 （对用户是不可见的） get对传输数据有大小限制（通常不能大于2kb），而post传递的数据量要比get大得多（理论上没有限制。但get效率更高，一般用来查询 get方式请求的数据会被浏览缓存，post则不会，get具有安全问题、 get方式和post方式传递的数据在服务器端的获取也不相同服务器响应在讲响应之前，先介绍一下readyState属性，readyState标识了当前对象正处于什么状态。另外介绍一下status属性，status属性描述了HTTP状态代码，一下常用的状态码：123456789XHR.onreadystatechange=function()&#123;//readyState的值发生改变时就会触发onreadystatechange if(readystate==4)&#123; if(XHR.status&gt;=200&amp;&amp;XHR.status&lt;300||XHR.status==304)&#123; //请求成功 &#125;else&#123; //请求失败 &#125; &#125;&#125; 注： status仅当readyState的状态是3或者4的时候才可用 send()方法必须在readyState的属性值是1，即调用open()方法以后才能调用 http 302 303 307302作为HTTP 1.0的标准，现在使用只是为了兼容性的处理。HTTP 1.1有303 307作为详细的补充，其实是对302的细化302：指示资源在另一个位置，该位置通过;Location指定303：请求的资源可以在另一个URI处找到，客户端必须使用GET方法来获取新位置的资源307：后续请求资源的方法是使用与当前交互相同的方法而不是全部使用GET Ajax的交互模型 用户发出请求 创建XMLHttpRequest对象 告诉XMLHttpRequest对象哪个函数会处理XMLHttpRequest对象状态的改变，为此要把对象的onReadyStateChange属性设置为响应该事件的JavaScript函数的引用 创建请求，用open方法指定get还是post，是否同步，url地址 发送请求，send方法 接收结果并分析 实现刷新 同步与异步的区别同步：脚本会停留等待服务器发送回复然后再继续异步：脚本允许页面继续其进程并处理可能的回复 Ajax的同步和异步ajax的open方法中，第三个参数(async)设同步或者异步，默认是true(异步)。异步的话，客户机不等待服务器的响应，需要onreadystatechange事件处理，且值为4处理下面的内容；同步的话客户机需要等待服务器返回消息后才去执行其他操作，js等待请求返回，获取status，不需要onreadystatechange事件处理函数。 同步和异步的请求代码示例如下：1234567891011121314var XHR=if(window.XMLHttpRequest)&#123; XHR=new XMLHttpRequest();&#125;else if(window.ActiveXObject)&#123;//IE6 XHR=new ActiveXobject(&apos;Microsoft.XMLHTTP&apos;);&#125;XHR.open(&apos;GET&apos;,URL,false);XHR.send(null);var result=XHR.status;//OKif(result==200)&#123; document.getElementById(&quot;left&quot;).innerHTML=XHR.responseText;&#125; XHR=null; 123456789101112131415var XHR=if(window.XMLHttpRequest)&#123; XHR=new XMLHttpRequest();&#125;else if(window.ActiveXObject)&#123;//IE6 XHR=new ActiveXobject(&apos;Microsoft.XMLHTTP&apos;);&#125;XHR.open(&apos;GET&apos;,URL,false);XHR.onreadystatechange=handleResponse;XHR.send(null);function handleResponse()&#123; if(XHR.readyState==4&amp;&amp;XHR.status==2000)&#123; document.getElementById(&quot;left&quot;).innerHTML=XHR.responseText; XHR=null; &#125;&#125;","categories":[],"tags":[],"keywords":[]},{"title":"jQuery $.proxy()方法","slug":"jQuery-proxy-方法","date":"2017-06-24T14:01:36.000Z","updated":"2017-06-24T14:30:06.775Z","comments":true,"path":"2017/06/24/jQuery-proxy-方法/","link":"","permalink":"https://aliceflaviawang.github.io/2017/06/24/jQuery-proxy-方法/","excerpt":"","text":"定义$.proxy方法接收一个已有的函数，并返回一个带特定上下文的新的函数。该方法通常用于向上下文只想不同对象的元素添加事件。 语法11$(selector).proxy(function,context) //function：要被调用的已有函数，context:函数所在对象的名称 举个例子：12345678910&lt;div&gt;div元素&lt;/div&gt;&lt;script&gt; test=function()&#123; this.text=&quot;这是一个对象属性&quot;; $(&quot;div&quot;).click(this.myClick); &#125; test.prototype.myClick=function()&#123; alert(this.text); &#125;&lt;/script&gt; 点击“div元素”，弹出undefined。这是因为执行$(“div”).click(this.myClick)后的this与test()中的this不是同一个。而使用$.proxy()可以将$(“div”).click(this.myClick)执行的this绑定到test的上下文环境中：12345678910&lt;div&gt;div元素&lt;/div&gt;&lt;script&gt; test=function()&#123; this.text=&quot;这是一个对象属性&quot;; $(&quot;div&quot;).click($.proxy(this.myClick),this); &#125; test.prototype.myClick=function()&#123; alert(this.text); &#125;&lt;/script&gt; 点击“div元素”，弹出的是“这是一个对象属性”。 语法21$(selector).proxy(context,name) //name:已有的函数，其上下文将被改变（应该是context对象的属性） 举个例子：123456789101112&lt;button&gt;执行test函数&lt;/button&gt;&lt;p&gt;&lt;/p&gt;&lt;script&gt; var objPerson=&#123; name:&quot;John&quot;, age:32, test:function()&#123; $(&quot;p&quot;).after(&quot;Name:&quot;+this.name+&quot;&lt;br&gt;Age:&quot;+this.age); &#125; &#125;$(&quot;button&quot;).click(objPerson.test.call(this));&lt;/script&gt; 点击button按钮，出现Name:undefined Age:undefined，因为test的上下文环境和objPerson的上下文环境不一样，test里面没有定义name和age对象。可以通过$.proxy()绑定test的上下文环境。123456789101112&lt;button&gt;执行test函数&lt;/button&gt;&lt;p&gt;&lt;/p&gt;&lt;script&gt; var objPerson=&#123; name:&quot;John&quot;, age:32, test:function()&#123; $(&quot;p&quot;).after(&quot;Name:&quot;+this.name+&quot;&lt;br&gt;Age:&quot;+this.age); &#125; &#125;$(&quot;button&quot;).click($.proxy(objPerson,&quot;test&quot;));&lt;/script&gt; 点击button按钮，出现Name:John Age:32。当然之前分析call函数时，也提到过call()也可以绑定上下文环境，实现与上面同样的效果：123456789101112&lt;button&gt;执行test函数&lt;/button&gt;&lt;p&gt;&lt;/p&gt;&lt;script&gt; var objPerson=&#123; name:&quot;John&quot;, age:32, test:function()&#123; $(&quot;p&quot;).after(&quot;Name:&quot;+this.name+&quot;&lt;br&gt;Age:&quot;+this.age); &#125; &#125;$(&quot;button&quot;).click(objPerson.test.call(objPerson));//将test()环境绑定到objPerson环境中&lt;/script&gt;","categories":[],"tags":[],"keywords":[]},{"title":"bind(), delegate(), on()方法区别","slug":"bind-delegate-on-方法区别","date":"2017-06-23T08:51:44.000Z","updated":"2017-06-23T09:12:23.825Z","comments":true,"path":"2017/06/23/bind-delegate-on-方法区别/","link":"","permalink":"https://aliceflaviawang.github.io/2017/06/23/bind-delegate-on-方法区别/","excerpt":"","text":"bind()：$(selector).bind(event,data,function)123$(&quot;div p&quot;).bind(&quot;click&quot;,function()&#123; &#125;) 使用bind()方法为所有div里的p元素都绑定了click事件，存在的问题：1）这里使用了隐式迭代，如果匹配到的元素特别多，影响了性能；2）对于尚未存在的元素，无法绑定。动态添加的p元素，点击会没有响应。顺便提一下，bind()的简写方式：123$(&quot;div p&quot;).click(function()&#123;&#125;) delegate():$(selector).delegate(childSelector,event,data,function)123$(&quot;div&quot;）.delegate(&quot;p&quot;,&quot;click&quot;,function()&#123; &#125;) 事件委托方式，不直接为p元素绑定事件，而是为其父元素（或祖先元素）绑定事件，当在div内任意元素点击时，事件会一层层从event.target向上冒泡，直到达到为其绑定事件的元素，如此例中的div元素。冒泡的过程中，如果事件的currentTarget与选择器匹配时就会执行代码。delegate()方法解决了bind具有的两个问题，但是如果事件目标在DOM树很深的位置，这样一层层来查找与选择器匹配的元素，又影响了性能。 on():$(selector).on(event,childselector,data,function)12$(&quot;div&quot;).on(&quot;click&quot;,&quot;p&quot;,function()&#123;&#125;) 看jQuery源代码发现，无论是bind()还是delegate()，都是通过on()方法实现的，只是参数不同。12345678910111213bind: function( types, data, fn ) &#123; return this.on( types, null, data, fn ); &#125;, unbind: function( types, fn ) &#123; return this.off( types, null, fn ); &#125;, delegate: function( selector, types, data, fn ) &#123; return this.on( types, selector, data, fn ); &#125; undelegate: function( selector, types, fn ) &#123; // ( namespace ) or ( selector, types [, fn] ) return arguments.length === 1 ? this.off( selector, &quot;**&quot; ) : this.off( types, selector || &quot;**&quot;, fn ); &#125; 总结1、选择器匹配元素较多时，不要使用bind()迭代绑定2、id选择器时，可以用bind()3、需要动态绑定时，用delegate()或on()4、用delegate()或on()，DOM树不要太深5、尽量使用on()","categories":[],"tags":[],"keywords":[]},{"title":"jQuery性能优化","slug":"jQuery性能优化","date":"2017-06-23T02:14:53.000Z","updated":"2017-06-23T08:48:32.480Z","comments":true,"path":"2017/06/23/jQuery性能优化/","link":"","permalink":"https://aliceflaviawang.github.io/2017/06/23/jQuery性能优化/","excerpt":"","text":"1、使用最新版本的jQuery类库jQuery每个新版本都会较上个版本进行bug修复和优化，同时进行一些创新。 2、使用合适的选择器jQuery提供了丰富的选择器来定位DOM元素，下面介绍几种常用的选择器及它们之间的性能差异： $(“#id”)使用id来定位DOM元素是最佳提高性能的方式，因为jQuery底层将直接调用本地方法document.getElementById()。如果不能直接找到，还可以考虑调用find()方法：1$(&quot;#content&quot;).find(&quot;div&quot;); 使用以上方法可以有效缩小定位DOM元素的范围，为了提高性能，可以从最近的ID元素开始往下搜索。 $(“p”),$(“div”),$(“input”)标签选择器是性能优化的第二选择，因为jQuery将直接调用本地方法document.getElementByTagName()来定位DOM元素。 $(“.class”)对于较新的浏览器，支持本地方法document.getElementByClassName(),老的浏览器如IE8及更早版本只能靠使用DOM搜索方式来实现，这无疑对性能产生较大的影响。所以有选择性的使用它。 $(“[attribute=value]”)利用属性定位DOM元素，本地JavaScript方法并没有直接实现，大多是使用DOM搜索方式来达到效果，很多现代浏览器支持querySelectAll()方法，但是浏览器之间还是有区别。 $(“:hidden”)和上面利用属性定位DOM方式类似，这种伪选择器也没有直接在本地JavaScript实现，并且jQuery需要搜索每一个元素来定位这个选择器，这对性能影响较大。如果一定要用这种方式，建议先用id定位父元素再使用该选择器，这样有助于优化性能。1$(&quot;#content&quot;).find(&quot;:hidden&quot;); 以上是使用选择器的基本规则，性能自上而下依次下降。 3、缓存对象开发人员经常喜欢这样写：12$(&quot;#traffic input.on&quot;).bind(&quot;click&quot;,function&#123;&#125;);$(&quot;#traffic&quot;).css(&quot;border&quot;,&quot;1px solid red&quot;)) 这样写导致的结果是jQuery会在每个选择器创建的过程中，查找DOM，创建多个jQuery对象。比较好的方式：123var $traffic=$(&quot;#traffic&quot;);$traffic.bind(&quot;click&quot;,function()&#123;&#125;).css(&quot;border&quot;,&quot;1px solid red&quot;) //使用链式结构让代码更简洁 如果希望在其他函数中使用jQuery对象，可以把它缓存放全局环境中。1234567891011//在全局范围内定义一个对象（例如window对象）window.$my=&#123; head:$(&quot;head&quot;), traffic:$(&quot;#traffic&quot;), &#125;function do()&#123; var script=document.createElement(&quot;script&quot;); $my.head.append(script); //现在可以引用存储的结果并操作它们 $my.coll=$(&quot;#ul li&quot;);//在函数内部操作时，可以继续将查询存入全局对象中 $my.coll.css(&quot;border-color&quot;,&quot;red&quot;); //将全局函数作为一个普通的jquery对象使用 &#125; 4、循环时的DOM操作使用for,while,$.each处理节点时，要注意：12345var top=[];//假设是100个字符串var list=$(&quot;#list&quot;);for(var i=0;i&lt;top.length;i++)&#123; list.append(&quot;&lt;li&gt;&quot;+top[i]+&quot;&lt;/li&gt;&quot;); &#125; 以上每添加一个新的标签元素都作为一个节点添加容器ID中，循环了100次，消耗较大。应该将整个元素字符串在插入DOM中全部创建好：1234567var top=[];//假设是100个字符串var list=$(&quot;#list&quot;);var mylist=&quot;&quot;;//暂存列表元素for(var i=0;i&lt;top.length;i++)&#123; mylist+=&quot;&lt;li&gt;&quot;+top[i]+&quot;&lt;/li&gt;&quot;; &#125;list.append(mylist); 非常类似与DOM操作中用createElementFragment一次性添加全部DOM节点，再一次性更新DOM：1234567var fragment=document.createElementFragment();for(var i=0;i&lt;items.length;i++)&#123; var item=document.createElement(&quot;li&quot;); item.append(document.createTextNode(&quot;option&quot;+i); fragment.appendChild(item); &#125;list.appendChild(fragment); 5、数组方式使用jQuery对象使用for或者while循环而不是$.each()能使代码更快。 6、事件代理每个javascript事件都会冒泡到父级节点。当需要给多个元素同个函数时，事件代理会很有用。123$(&quot;#table td&quot;).click(function()&#123; $(this).css(&apos;background&apos;,&apos;red&apos;) &#125;) 假设有100个td元素，使用上述方法，将会绑定100个事件，对性能影响很大。代替这种多元素事件监听的方法是，只需要向他们的父节点绑定一次事件，然后通过event.target获取到点击的当前元素：123$(&quot;#table&quot;).click(function(event)&#123; $(event.target).css(&apos;background&apos;,&apos;red&apos;); //event.target捕捉触发的目标元素 &#125;) 改进的方式中，只为一个元素绑定了1个事件。jQuery 1.7中提供了on方式，on(type,[selector],[data],fn)中增加了selector，如果能够匹配到该selector则执行此方法：123$(&quot;#table&quot;).on(&quot;click&quot;,&quot;td&quot;,function()&#123; $(this).css(&apos;background&apos;,&apos;red&apos;);&#125;) 7、将代码转化成jQuery插件将代码转化成插件能让代码具有更好的重用性。 8、使用join()来拼接字符串使用join来拼接字符串比使用”+“来拼接长字符串性能更优。首先创建一个数组，然后循环，最后通过join()将数组转化成字符串：12345var array=[];for(int i=0;i&lt;100;i++)&#123; array[i]=&apos;&lt;li&gt;&apos;+i+&apos;&lt;/li&gt;&apos;; &#125;$(&apos;#list&apos;).html(array.join(&apos;&apos;)); 9、合理利用HTML5的Data属性HTML5的data属性可以帮助我们插入数据，特别是前后端的数据交换。jQuery的data（）方法，有效的利用HTML5的属性，来自动得到数据。12345&lt;div id=&quot;dl&quot; data-role=&quot;page&quot; data-last=&quot;43&quot; data-options=&apos;&#123;&quot;name&quot;:&quot;John&quot;&#125;&apos;&gt;&lt;/div&gt;//读取数据$(&quot;#dl&quot;).data(&quot;role&quot;); //&quot;page&quot;$(&quot;#dl&quot;).data(&quot;last&quot;); //43$(&quot;#dl&quot;).data(&quot;options&quot;).name; //&quot;John&apos; 10、尽量使用原生的JavaScript方法123456var $cr=$(&quot;#cr&quot;);$cr.click(function()&#123; if($cr.is(&quot;:checked&quot;))&#123; //jQuery方式判断 &#125;&#125;) 它使用了jQuery提供的is方法来判断多选框是否被选中，但是这里可以直接使用原生的JavaScript方法：123456var $cr=$(&quot;#cr&quot;); //jQuery对象var cr=$cr.get(0); //DOM对象$cr.click(function()&#123; if(cr.checked)&#123; //原生的js方式判断 &#125;&#125;) 第二种方式比第一种方式效率高，因为它不需要拐弯抹角去调用许多函数。 11、压缩JavaScript一方面使用Gzip，另一方面去除JS文件里的注释、空白。","categories":[],"tags":[],"keywords":[]},{"title":"页面内跳转方法总结","slug":"页面内跳转方法总结","date":"2017-06-22T08:31:43.000Z","updated":"2017-06-22T09:04:27.613Z","comments":true,"path":"2017/06/22/页面内跳转方法总结/","link":"","permalink":"https://aliceflaviawang.github.io/2017/06/22/页面内跳转方法总结/","excerpt":"","text":"方法一：用标签，在href里写入定位的DIV的id.如：1234&lt;a href=&quot;#div1&quot;&gt;scroll to div1&gt;&lt;/a&gt; //定位到div1&lt;div id=&quot;div1&quot;&gt;div1&lt;/div&gt;&lt;div id=&quot;div2&quot;&gt;div2&lt;/div&gt;&lt;div id=&quot;div3&quot;&gt;div3&lt;/div&gt; 缺点：点击锚点后，浏览器的URL会发生变化，刷新会出现问题。 方法二：使用js中的window.location.hash=”divId”跳转，但地址也会发生变化，跟第一种方法差不多。123456&lt;a href=&quot;javascript:void(0)&quot; onclick=&quot;locate()&quot;&gt;&lt;/a&gt;&lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; funtion locate()&#123; window.location.hash=&quot;#div1&quot;;&#125; 方法三：用animate属性，当点击锚点后，页面滚动到相应的div。12345678&lt;a href=&quot;javascript:void(0)&quot; onclick=&quot;locate()&quot;&gt;&lt;/a&gt;&lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function lacate()&#123; $(&quot;html&quot;,&quot;body&quot;).animate(&#123; scrollTop:$(&quot;#div1&quot;).offset().top &#125;,&#123;duration:500,easing:&quot;swing&quot;&#125;) &#125; 优点：url地址不会改变，同时点击锚点会自动响应scroll事件，不需要重新绑定。缺点：如果页面复杂的话，偏移值可能会发生变化需要算法辅助。 方法四：用js的scrollIntoView方法，直接用：123456&lt;a href=&quot;javascript:void(0)&quot; onclick=&quot;locate()&quot;&gt;&lt;/a&gt;&lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;function lacate()&#123; docuemnt.getElementById(&quot;div1&quot;).scrollIntoView();&#125; 优点：url不会变，同时能够响应scroll事件，不需要算法什么的。注意：scrollIntoView是js方法，不能使用$(“#div1”).scrollIntoView().","categories":[],"tags":[],"keywords":[]},{"title":"JSON.parse()和Json.stringify()","slug":"JSON-parse-和Json-stringify","date":"2017-06-22T02:01:30.000Z","updated":"2017-07-16T14:10:59.038Z","comments":true,"path":"2017/06/22/JSON-parse-和Json-stringify/","link":"","permalink":"https://aliceflaviawang.github.io/2017/06/22/JSON-parse-和Json-stringify/","excerpt":"","text":"JSON.parse()parse是用一个字符串中解析出json对象，如：var str=’{“name”:”alice”,”age”:”23”}’结果：JSON.parse(str)Objectage:”23”name:”alice”proto:Object 注意：单引号写在{}外面，每个属性名必须用双引号，否则会报错 JSON.stringify()stringify是从对象解析出字符串，如：var a={a:1,b:2}JSON.stringify(a)‘{“a”:1,”b”:2}’ JSON.stringify和JSON.parse在IE8及以上支持","categories":[],"tags":[],"keywords":[]},{"title":"serialize()系列方法","slug":"serialize-系列方法","date":"2017-06-17T11:22:16.000Z","updated":"2017-06-17T13:25:38.570Z","comments":true,"path":"2017/06/17/serialize-系列方法/","link":"","permalink":"https://aliceflaviawang.github.io/2017/06/17/serialize-系列方法/","excerpt":"","text":"serialize()jQuery有方法$.fn.serialize()，可以将表单序列化成字符串。提交表单的时候，将表单的每个元素表达成如：username:$(“#username”).val(),content:$(“#content”).val()…无疑随着表单元素越来越复杂，这种方式在增大工作量的同时也使表单元素缺乏弹性。采用serialize（）方法可以将需要提交的字段内容序列化为字符串，username:$(“#username”).val(),content:$(“#content”).val()…可以用一个语句代替:$(“#form”).serialize(),其中#form是表单的id。 serialize()的其他两种方法–serializeArray()和serializeObject()serializeArray()是将表单序列化为JSON格式的数据，输出的是对象数组。而serializeObject()是基于serializeArray（）编写的。下面例子能非常清晰的看出其中的区别：123$(&quot;#form&quot;).serialize(); //username=&amp;content=$(&quot;#form&quot;).serializeArray(); //[&#123;name:&quot;username&quot;,value:&quot;&quot;&#125;,&#123;name:&quot;content&quot;,value:&quot;&quot;&#125;]$(&quot;#form&quot;).serializeObject(); //&#123;username:&quot;&quot;,content:&quot;&quot;&#125; 注意1、serializeObject()直接使用的话，会提示serializeObject()is not a funtion.因为serializeObject()本身并不是一个jQuery自带的功能，而是基于serializeArray（）的添加功能，需要对其进行定义如下：12345678910111213141516$.fn.serializeObject()&#123; var o=&#123;&#125;; //保存对象 var a=this.serializeArray(); //先将元素序列化为对象数组 $.each(a,function()&#123; if(o[this.name])&#123;//表单中可能有多个相同的label，在插入第一个label后，还有继续插入，这个时候o[label]已经存在了，所以要把o[label]做嵌套处理 if（！o[this.name].push)&#123; //如果o[label]不是嵌套在数组里面，实际上就是看o[this.name]是不是一个数组，数组有push方法，对象没有 o[thos.name]=[o[this.name]];将o[label]初始为嵌套数组 &#125; o[this.name].push(this.value||&apos;&apos;); //将值插入o[label]数组里 &#125; else&#123; o[this.name]=this.value||&apos;&apos;;//第一次在o中插入o[label] &#125; &#125;) return o;&#125; 举个例子,对于下面的表单：123456&lt;form id=&quot;form&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt; &lt;input type=&quot;text&quot; name=&quot;content&quot; /&gt; &lt;input type=&quot;button&quot; id=&quot;send&quot; onclick=&quot;sen();&quot;&gt;&lt;/form&gt; 执行三个函数，分别结果为：12345var a=$(&quot;#form&quot;).serialize(); //username=alice&amp;username=bob&amp;content=123 var b=$(&quot;#form&quot;).serializeArray(); //[&#123;name:&quot;username&quot;,value=&quot;alice&quot;&#125;,&#123;name:&quot;username&quot;,value=&quot;bob&quot;&#125;,&#123;name:&quot;content&quot;,value=&quot;123&quot;&#125;]var c=$(&quot;#form&quot;).serializeObject(); //&#123;username:[&quot;alice&quot;,&quot;bob&quot;],content:&quot;123&quot;&#125; 2、表单元素要序列化必须要使用name属性，form里的name不能用js、jquery的关键字，否则获取不到值。3、不光表单能用到serialize()方法，其他选择器元素也可以。比如：1$(&quot;:checkbox,:radio&quot;).serialize()","categories":[],"tags":[],"keywords":[]},{"title":"EasyUI更改弹出框位置","slug":"EasyUI更改弹出框位置","date":"2017-06-15T02:15:18.000Z","updated":"2017-06-15T02:21:15.668Z","comments":true,"path":"2017/06/15/EasyUI更改弹出框位置/","link":"","permalink":"https://aliceflaviawang.github.io/2017/06/15/EasyUI更改弹出框位置/","excerpt":"","text":"EasyUI的dialog弹出一般用的是$(‘#dlg’).dialog(‘open’)，要想调整其位置，可以采用$(‘#dlg’).window(‘open’)，再用window的resize方法重新布局就可以了。如：1$(&apos;#dlg&apos;).dialog(&apos;open&apos;).dialog(&apos;center&apos;).dialog(&apos;setTitle&apos;, &apos;添加题目&apos;); 可以改成：1$(&apos;#dlg&apos;).window(&apos;open&apos;).window(&apos;setTitle&apos;,&apos;添加题目&apos;).window(&apos;resize&apos;,&#123;width:&apos;500px&apos;,height:&apos;800px&apos;,top:&apos;30px&apos;&#125;","categories":[],"tags":[],"keywords":[]},{"title":"a标签中href=''的几种用法","slug":"a标签中href-的几种用法","date":"2017-06-13T06:54:22.000Z","updated":"2017-06-13T12:29:08.780Z","comments":true,"path":"2017/06/13/a标签中href-的几种用法/","link":"","permalink":"https://aliceflaviawang.github.io/2017/06/13/a标签中href-的几种用法/","excerpt":"","text":"a标签的主要作用是实现超链接和锚点，下面总结下a标签href的几种用法。 一、href的几种调用方法1、a href=”javascript:js_method();”这是常用的方法，但是这种方法在传递this等参数的时候很容易出问题，而且javascript：协议作为a的href属性的时候不仅会导致不必要的触发window.onbeforeunload事件，在IE里面更会使gif动画图片停止播放。W3C标准不推荐在href里面执行javascript语句。 2、a href=”javascript:void(0);” onclick=”js_method()”这种方法是很多网站最常用的方法，也是最周全的方法，onclick方法负责执行js函数，而void是一个操作符，void(0)返回undefined，地址不发生跳转。而且这种方法不会像第一种方法一样直接js方法暴露在浏览器的状态栏。 3、a href=”javascript:;” onclick=”js_method()”这种方法跟2类似，区别只是执行了一条空的js代码 4、a href=”#” onclick=”js_method()”这种方法也是网上很常见的代码，#是标签内置的一个方法，”#”包含了一个位置信息，默认的锚点是#top,就是点击后返回页面的顶端。（如果希望不返回页面顶端，可以在#后面加任意无效的位置信息，如###） 5、a href=”#” onclick=”js_method();return false;”这种方法点击执行了js函数后return false,页面不发生跳转，执行后还是在页面的当前位置。","categories":[],"tags":[],"keywords":[]},{"title":"return false实现同时对事件对象停止冒泡和默认行为","slug":"return-false实现同时对事件对象停止冒泡和默认行为","date":"2017-06-12T08:06:54.000Z","updated":"2017-06-12T09:17:10.934Z","comments":true,"path":"2017/06/12/return-false实现同时对事件对象停止冒泡和默认行为/","link":"","permalink":"https://aliceflaviawang.github.io/2017/06/12/return-false实现同时对事件对象停止冒泡和默认行为/","excerpt":"","text":"冒泡网页上有两个元素，其中一个元素嵌套在另一个元素里面，并且都被绑定了click事件，那么点击内层元素，会冒泡到外层元素上。1234567891011121314151617181920212223242526&lt;body&gt;&lt;div id=&quot;content&quot;&gt; 外层div元素 &lt;span&gt;内层div元素&lt;/span&gt; 外层div元素&lt;/div&gt;&lt;div id=&apos;msg&apos;&gt;&lt;/div&gt;&lt;script&gt;$(function()&#123; $(&apos;span&apos;).bind(&apos;click&apos;,function()&#123; var txt=$(&apos;#msg&apos;).html()+&apos;&lt;p&gt;内层div元素被单击。&lt;/p&gt;&apos;; $(&apos;#msg&apos;).html(txt); &#125;) $(&apos;#content&apos;).bind(&apos;click&apos;,function()&#123; var txt=$(&apos;#msg&apos;).html()+&apos;&lt;p&gt;外层div元素被单击。&lt;/p&gt;&apos;; $(&apos;#msg&apos;).html(txt) &#125;) $(&apos;body&apos;).bind(&apos;click&apos;,function()&#123; var txt=$(&apos;#msg&apos;).html()+&apos;&lt;p&gt;body元素被单击。&lt;/p&gt;&apos;; $(&apos;#msg&apos;).html(txt) &#125;)&#125;)&lt;/script&gt;&lt;/body&gt; 效果如图：点击span元素点击外层div元素点击内层元素，会冒泡到外层的点击事件。 阻止冒泡stopPropagation()方法可以停止事件冒泡。12345$(&apos;span&apos;).bind(&apos;click&apos;,function(event)&#123; var txt=$(&apos;#msg&apos;).html()+&apos;&lt;p&gt;内层div元素被单击。&lt;/p&gt;&apos;; $(&apos;#msg&apos;).html(txt); event.stopPropagation(); &#125;) 点击span元素 阻止默认行为网页中的元素有自己的默认行为，例如，单击“提交”按钮后表单会提交，有时需要阻止元素的默认行为。1234567891011121314151617&lt;form action=&quot;test.html&quot;&gt;用户名：&lt;input type=&quot;text&quot; id=&quot;username&quot;&gt;&lt;br/&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot; id=&quot;sub&quot;&gt;&lt;/form&gt;&lt;div id=&quot;msg&quot;&gt;&lt;/div&gt;&lt;script&gt;$(function()&#123; $(&apos;#sub&apos;).bind(&apos;click&apos;,function()&#123; var username=$(&apos;#username&apos;).val(); if(username==&apos;&apos;)&#123; $(&apos;#msg&apos;).html(&apos;&lt;p&gt;文本框的值不能为空。&lt;/p&gt;&apos;); &#125; &#125;)&#125;)&lt;/script&gt; 如果不阻止默认行为，用户名为空的时候，也能提交表单。阻止默认行为使用preventDefault()方法。1234567$(&apos;#sub&apos;).bind(&apos;click&apos;,function(event)&#123; var username=$(&apos;#username&apos;).val(); if(username==&apos;&apos;)&#123; $(&apos;#msg&apos;).html(&apos;&lt;p&gt;文本框的值不能为空。&lt;/p&gt;&apos;); event.preventDefault(); &#125; &#125;) 同时对事件对象停止冒泡和默认行为——return false将event.stopPropagation()和event.preventDefault()替换为return false就可以实现同样的效果。 return false到底做了什么1、event.preventDefault()2、event.stopPropagation()3、停止回调函数执行并立即返回return false看似实现了阻止冒泡或者阻止默认事件，实际上还做了另外的操作，阻止浏览器默认行为的只有preventDefault()，除非你想停止事件冒泡，否则使用return false会为你的代码埋下很大的隐患。 ###扩展-stopImmediatePropagation()stopImmediatePropagagtion()函数用于阻止剩余的事件处理函数的执行(为同一对象绑定了多个事件处理函数)，并防止当前事件在DOM树上冒泡。12345678910111213141516171819202122232425&lt;p&gt;段落文本内容 &lt;input type=&quot;button&quot; value=&quot;点击&quot; /&gt;&lt;/p&gt;&lt;script&gt;// 为所有p元素绑定click事件$(&quot;p&quot;).click( function(event)&#123; alert(&quot;p-click&quot;);&#125; );// 为所有button元素的click事件绑定第一个事件处理函数$(&quot;:button&quot;).click( function(event)&#123; alert(&quot;button-click-1&quot;); // 阻止事件冒泡到DOM树上，并阻止剩余的事件处理函数的执行 // 只执行button-click-1，如果注释掉该行，将执行button-click-1、button-click-2和p-click // 如果换成event.stopPropagation() 将执行button-click-1和button-click-2 event.stopImmediatePropagation();&#125; );// 为所有button元素的click事件绑定第二个事件处理函数$(&quot;:button&quot;).click( function(event)&#123; alert(&quot;button-click-2&quot;);&#125; );&lt;/script&gt; 与stopPropagation()相比，stopImmediatePropagation()还能阻止剩余事件处理函数的执行。","categories":[],"tags":[],"keywords":[]},{"title":"ajax dataType","slug":"ajax-dataType","date":"2017-06-08T02:42:09.000Z","updated":"2017-06-09T06:30:48.124Z","comments":true,"path":"2017/06/08/ajax-dataType/","link":"","permalink":"https://aliceflaviawang.github.io/2017/06/08/ajax-dataType/","excerpt":"","text":"遇到一个很奇怪的问题12345678910$.ajax(&#123; type:&quot;POST&quot;, async:false, contentType: &quot;application/json; charset=utf-8&quot;, // dataType: &apos;json&apos;, url:baseUrl+&quot;/office/getEmploymentPeriod.do&quot;, success:function(data)&#123; console.log(data) //&#123;&quot;body&quot;:&quot;2017年3月-2017年7月&quot;,&quot;message&quot;:&quot;成功&quot;,&quot;status&quot;:0&#125; console.log(data.body) // undefined &#125; 如果没有dataType:’json’,返回的data是json对象，访问data.body是undefined。加上dataType:’json’，返回的是普通对象，访问data.body可以获取到。疑问是，dataType:’json’是指定返回数据的格式是’json’，为什么会返回数据的格式是普通对象，不指定反而返回的是’json’对象，另外返回数据无论是普通对象还是json对象，按理都应该能通过对象.属性访问到。12345678910$.ajax(&#123; type:&quot;POST&quot;, async:false, contentType: &quot;application/json; charset=utf-8&quot;, dataType: &apos;json&apos;, url:baseUrl+&quot;/office/getEmploymentPeriod.do&quot;, success:function(data)&#123; console.log(data) //&#123;body: &quot;2017年3月-2017年7月&quot;, message: &quot;成功&quot;, status: 0&#125; console.log(data.body) // 2017年3月-2017年7月 &#125;","categories":[],"tags":[],"keywords":[]},{"title":"apply,call,bind用法","slug":"apply-call-bind用法","date":"2017-06-06T03:10:43.000Z","updated":"2017-06-06T06:45:04.789Z","comments":true,"path":"2017/06/06/apply-call-bind用法/","link":"","permalink":"https://aliceflaviawang.github.io/2017/06/06/apply-call-bind用法/","excerpt":"","text":"1、apply()方法——apply([thisObj[,argArray]])apply()接收两个参数：一个是运行函数的作用域，另一个是参数数组。其中第二个参数可以是Array的实例，也可以是arguments对象。 2、call()方法——call([thisObj[,arg1[, arg2[, [,.argN]]]]])与apply作用相同，区别在于接收参数方式不同。第一个参数this的值没有变化，其余参数是以列举的方式直接传递给函数。 apply, call共同之处都可以用来代替另一个对象调用一个方法，将一个函数的对象上下文从初始上下文改变为由thisObj指定的新对象。 不同之处apply最多只能有两个参数——新this对象和一个数组argArray，如果argArray不是一个有效的数组或者不是arguments对象，那么将导致一个TypeError，如果没有提供argArray和thisObj任何一个参数，那么Global对象将被用作thisObj，并且无法被传递任何参数call传递的是参数列表，。如果没有提供thisObj参数，那么Global对象被用作thisObj。apply和call功能一样，只是传入参数列表形式不同，如果某个参数数量是不固定的，当参数明确时用call，不明确时用apply，然后把参数push进数组传递，函数内部也可以通过arguments数组来遍历所有参数。 3、bind()方法——fun.bind(thisObj[,arg1[, arg2[, [,.argN]]]]])与apply和call不同的是，bind会返回一个改变this指向的新函数，新函数与之前的使用的不是同一块内存地址，所以需要重复使用这个函数的时候，必须将其保存到一个变量，方便下次调用。而apply和call都是调用即执行。另外，bind函数中的首个参数，会自动成为返回新函数中参数的默认值，那么正式调用的时候，只需给出除首个参数外，剩余参数即可。 123456function f(x,y)&#123; console.log(x+y);&#125;f.call(null,1,1) //return 2var new_f=f.bind(null,1,1);new_f(2); //return 2 上面实例中thisArg参数均用null代替了，在未给出指定thisArg对象情况下，null与undefined下this指向的是全局对象，即js代码执行环境。 apply, call, bind比较123456789101112var obj=&#123;bar:&apos;hello&apos;&#125;var foo=&#123; get:function()&#123; return this.bar; &#125;&#125;var bind=foo.get.bind(obj), call=foo.get.call(obj), apply=foo.get.apply(obj);console.log(bind(),call,apply); //hello hello helloconsole.log(bind,call,apply); //function()&#123;return this.bar;&#125; &quot;hello&quot; &quot;hello&quot;console.log(typeof bind,typeof call,typeof apply); function string stringconsole.log(typeof bind(),typeof call,typeof apply); //string string string 三者的区别是：当你希望改变上下文环境之后并非立即执行，而是回调执行的时候，使用bind()方法，而apply/call则会立即执行函数。1234apply, call, bind三者都是用来改变函数的this对象的指向apply, call, bind三者第一个参数都是this要指向的对象，也就是想指定的上下文apply, call, bind三者都可以利用后续参数传参bind是返回对应的函数，便于稍后调用；apply, call则立即调用","categories":[],"tags":[],"keywords":[]},{"title":"JS定义变量的三种方式","slug":"JS定义变量的三种方式","date":"2017-06-05T03:05:49.000Z","updated":"2017-06-05T03:18:28.496Z","comments":true,"path":"2017/06/05/JS定义变量的三种方式/","link":"","permalink":"https://aliceflaviawang.github.io/2017/06/05/JS定义变量的三种方式/","excerpt":"","text":"1、最常见的var定义变量，可以修改，如果不初始化会输出undefined,但不会报错。12345678var a=1;console.log(&apos;函数外定义a:&apos;+a); //输出a=1function change()&#123; a=4; console.log(&apos;函数内定义a:&apos;+a); //可以输出a=4;&#125;change();console.log(&apos;函数调用后var定义a为函数内部修改值:&apos;+a); //输出a=4 2、const定义的变量不可以修改，而且必须初始化。12345const b=2;// const b; //错误，必须初始化console.log(b); //有输出值// b=5;console.log(b); //报错，不能给常量赋值 3、let是块级作用域，函数内部使用let定义后，对函数外部无影响。12345678let c=3;console.log(&apos;函数外定义c:&apos;+c); //输出c=3;function change()&#123; let c=6; console.log(&apos;函数内定义c:&apos;+c); //输出c=6;&#125;change();console.log(&apos;函数调用后let定义c不受函数内部定义的影响：&apos;+c); //输出c=3;","categories":[],"tags":[],"keywords":[]},{"title":"从输入URL到浏览器显示页面发生了什么","slug":"从输入URL到浏览器显示页面发生了什么","date":"2017-05-27T02:06:07.000Z","updated":"2017-05-27T07:15:26.825Z","comments":true,"path":"2017/05/27/从输入URL到浏览器显示页面发生了什么/","link":"","permalink":"https://aliceflaviawang.github.io/2017/05/27/从输入URL到浏览器显示页面发生了什么/","excerpt":"","text":"从输入URL到浏览器显示页面，这个过程分为两个部分：网络通信和页面渲染。 一、网络通信互联网内各网络设备间的通信都遵循TCP/IP协议，利用TCP/IP协议族进行网络通信时，会通过分层顺序与对方进行通信。分层由高到低分别为：应用层、传输层、网络层、数据链路层。发送端从应用层往下走，接收端从数据链路层往上走。如下图所示： 1.在浏览器中输入URL用户输入URL，例如http://www.baidu.com。其中http为协议，www.baidu.com为网络地址，及指出需要的资源在那台计算机上。一般网络地址可以为域名或IP地址，此处为域名。使用域名是为了方便记忆，但是为了让计算机理解这个地址还需要把它解析为IP地址。 2.应用层DNS解析域名客户端先检查本地是否有对应的IP地址，若找到则返回响应的IP地址。若没找到则请求上级DNS服务器，直至找到根节点。 3.应用层客户端发送HTTP请求HTTP请求包括请求报头和请求主体两个部分，其中请求报头包含了至关重要的信息，包括请求的方法（GET/POST)、目标URL、遵循的协议（HTTP/HTTPS/FTP…),返回的信息是否需要缓存，以及客户端是否发送cookie等。 4.传输层TCP传输报文位于传输层的TCP协议为传输报文提供可靠的字节流服务。它为了方便传输，将大块的数据分割成以报文段位单位的数据包进行管理，并为它们编号，方便服务器接收时能准确地还原报文信息。TCP协议通过“三次握手”等方法保证传输的安全可靠。“三次握手”的过程是，发送端先发送一个带有SYN标志的数据包给接收端，在一定的延迟时间内等待接收的回复。接收端收到数据包后，传回一个带有SYN/ACK标志的数据包以示传达确认信息。接收方收到后再发送一个带有ACL标志的数据包给接收端以示握手成功。在这个过程中，如果发送端在规定延迟时间内没有收到回复则默认接收方没有收到请求，而再次发送，直到收到回复为止。 5.网络层IP协议查询MAC地址IP协议的作用是把TCP分割好的各种数据包传送给接收方。而要保证确实能传到接收方还需要接收方的MAC地址，也就是物理地址。IP地址和MAC地址是一一对应的关系，一个网络设备的IP地址可以更换，但是MAC地址一般是固定不变的。ARP协议可以将IP地址解析成对应的MAC地址。当通信的双方不在同一个局域网时，需要多次中转才能到达最终的目标，在中转的过程中需要通过下一个中转站的MAC地址来搜索下一个中转目标。 6.数据到达数据链路层在找到对方的MAC地址后，就将数据发送到数据链路层传输。这时客户端发送请求的阶段结束。 7.服务器接收数据接收端的服务器在链路层接收到数据包，再层层向上直到应用层。这过程中包括在运输层通过TCP协议将分段的数据包重新组成原来得HTTP请求报文。 8.服务器响应请求服务接收到客户端发送的HTTP请求后，查找客户端请求的资源，并返回响应报文，响应报文中包括一个重要的信息————状态码。状态码由三位数字组成，其中比较常见的是200 OK表示请求成功。301表示永久重定向，即请求的资源已经永久转移到新的位置。在返回301状态码的同时，响应报文也会附带重定向的URL，客户端接收后将HTTP请求的URL做相应的改变再重新发送。404 not found表示客户端请求的资源找不到。 9.服务器返回相应文件请求成功后，服务器会返回相应的HTML文件。接下来就到了页面渲染阶段了。 二、页面渲染现代浏览器渲染页面的过程是这样的：解析HTML以构建DOM树——&gt;构建渲染树——&gt;布局渲染树——&gt;绘制渲染树。DOM树是由HTML文件中的标签排列组成，渲染树是在DOM树种加入CSS或HTML中的style样式而形成。渲染树只包含显示在页面中的DOM元素，像元素或display属性值为none的元素都不在渲染树中。在浏览器还没接收到完整的HTML文件时，它就开始渲染页面了，在遇到外部链入的脚本标签或样式标签或图片时，会再次发送HTTP请求重复上述的步骤。在收到CSS文件后会对已经渲染的页面重新渲染，加入它们应有的样式，图片文件加载完立刻显示在相应位置。在这一过程中可能会触发页面的重绘或重排。","categories":[],"tags":[],"keywords":[]},{"title":"DOM性能提升","slug":"DOM性能提升","date":"2017-05-26T07:42:01.000Z","updated":"2017-08-20T14:03:58.694Z","comments":true,"path":"2017/05/26/DOM性能提升/","link":"","permalink":"https://aliceflaviawang.github.io/2017/05/26/DOM性能提升/","excerpt":"","text":"DOM(文档对象模型)是针对HTNL和XML文档的一个API（应用程序编程接口），DOM可以将任何一个HTML或XML文档描绘成一个由多层节点构成的节点树，允许开发人员添加、移除和修改页面的某一部分。 DOM的核心问题DOM会导致一系列的重绘(repaint)、重新排版(reflow)操作。为了确保执行结果的准确性，所有的修改是按顺序同步进行的，大部分浏览器都不会在执行过程中更新DOM。相应的，这些浏览器将对DOM的操作放在一个队列，并在JavaScript脚本执行完毕以后按顺序一次执行完毕。也就是说，在JavaScript执行的过程，直到发生重新排版，用户一直被阻塞。一般的浏览器中（不含IE），repaint的速度远快于reflow，所以避免reflow更重要。reflow:例如某个子元素样式发生改变，直接影响到了其父元素以及往上追溯很多祖先元素（包括兄弟元素），这时候浏览器要重新渲染这个子元素相关联的所有元素的过程。reflow几乎无法避免。repaint:如果只是改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性，将只会引起浏览器的repaint。 解决方案关键：减少DOM操作引起的reflow。 1、使用DoucumentFragment一次性更新DOM12345678//使用容器保存临时变更，最后一次性更新DOMvar fragment=document.createDocumentFragment();for(var i=0;i&lt;items,length;i++)&#123; var item=document.createElement(&quot;li&quot;); item.appendChild(document.createTextNode(&quot;Option&quot;+i); fragment.appendChild(item); &#125;list.appendChild(fragment); 2、操作DOM前，先把DOM节点删除或隐藏，因为隐藏的节点不会发生重排1234567list.style.display=&quot;none&quot;;for(var i=0;i&lt;items,length;i++)&#123; var item=document.createElement(&quot;li&quot;); item.appendChild(document.createTextNode(&quot;Option&quot;+i); list.appendChild(item); &#125;list.style.display=&quot;&quot;; 3、只改变class1234//这样做很引起多次重排element.style.backgroundColor=&quot;blue&quot;;element.style.color=&quot;red&quot;;element.style.fontSize=&quot;12em&quot;; 1234567//更好的做法是，把样式放在一个class下.newStyle&#123; background-color:blue; color:red; font-size:12em;&#125;element.className=&quot;newStyle&quot;; 4、使用缓存，缓存临时节点12//不好的做法document.getElementById(&quot;myDiv&quot;).style.left=document.getElementById(&quot;myDiv&quot;).offsetLeft+document.getElementById(&quot;myDiv&quot;).offsetWidth+&quot;px&quot;; 123//更好的做法var myDiv=document.getElementById(&quot;myDiv&quot;);myDiv.style.left=myDiv.offsetLeft+myDiv.offsetWidth+&quot;px&quot;; 5.使用requestAnimationFrame、requestIdleCallback其中requestAnimationFrame允许我们正确的安排动画（告诉浏览器希望执行动画，并请求浏览器调用指定的函数在下一次重绘之前更新动画），而requestIdlecallback会在某一帧结束后的空闲时间或者用户处于不活跃状态是，处理我们的工作。就是说，通过使用requestIdleCallback这个API可以尽可能高效的利用任何空闲时间。 reqeustIdleCallback需要回调函数作为参数，回调函数被调用，会返回deadline对象，这个对象包含timeRemaining方法，返回数字表示你的工作还能执行多长时间。当timeRemaining返回0，如果还有其他的requestIdleCallback就会执行，这样的话有些回调函数可能永远不会执行，此时与requestAnimationFrame不同的requestIdelCallback可以指定第二个参数，还有timeout属性的对象，强制在这个timeout值后执行回调函数。 最佳的实践就是，只在requestAnimationFrame的回调中进行dom改动，就是，在requestIdleCallback时使用文档片段，在下一个requestAnimationFrame回调中把所有改动的dom追加上去。","categories":[],"tags":[],"keywords":[]},{"title":"跨浏览器事件对象———EventUtil","slug":"跨浏览器事件对象———EventUtil","date":"2017-05-24T02:12:22.000Z","updated":"2017-07-25T12:46:22.763Z","comments":true,"path":"2017/05/24/跨浏览器事件对象———EventUtil/","link":"","permalink":"https://aliceflaviawang.github.io/2017/05/24/跨浏览器事件对象———EventUtil/","excerpt":"","text":"前言EventUtil:在JavaScript中，DOM0级、DOM2级与旧版本IE（8-）为对象添加事件的方法不同，为了以跨浏览器的方式处理时间，需要编写一段“通用代码”，即跨浏览器的事件处理程序，这个方法属于一个名为EventUtil的对象，编写并使用该对象后，可保证处理事件的代码能在大多数浏览器下一致地运行。 EventUtil对象123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106var EventUtil=&#123; addHandler:function(element,type,handler)&#123;//添加事件 if(element.addEventListener)&#123; element.addEventListener(type,handler,false); //使用DOM2级方法添加事件，三个参数分别是：要处理的事件名、作为事件处理的函数和一个布尔值（布尔值表示在捕获阶段(true)还是冒泡阶段(false)调用事件处理程序） &#125; else if(element.attachEvent)&#123; element.attachEvent(&quot;on&quot;+type,handler); //使用IE方法添加事件，两个参数分别为：事件处理程序名称和事件处理程序的函数 &#125; else&#123; element[&quot;on&quot;+type]=handler; //使用DOM0级方法添加事件 &#125; &#125;， removeHandler:function(element,type,handler)&#123; //取消事件 if(element.removeEventListener)&#123; element.removeEventListener(type,handler,false); &#125; else if(element.detachEvent)&#123; element.detachEvent(&quot;on&quot;+type,handler); &#125; else&#123; element[&quot;on&quot;+type]=null; &#125; &#125;, getEvent:function(event)&#123; //使用这个方法跨浏览器取得event对象 return event?event:window.event; //在IE中，使用DOM0级添加事件处理程序时，event对象作为window对象的一个属性存在，而且在IE中，event对象的一些属性/方法跟其他支持DOM的浏览器不同，正是由于这些差异，EventUtil中的getEvent方法应运而生 &#125;, getTarget:function(event)&#123; //返回事件的实际目标 return event.target||event.srcEelment; //在IE中，获取事件的目标对象的方法为event.srcElement，而其他兼容DOM的浏览器中，获取事件目标对象的方法却为event.target &#125;, preventDefault:function(event)&#123; //阻止事件的默认行为 if(event.preventDefault)&#123; //在其他兼容DOM的浏览器中，阻止特定事件的默认行为只需要使用event对象自带的preventDefault()方法 event.preventDefault(); &#125;else&#123; //而IE中，则需要赋予event.returnValue的值为false才能阻止特定事件的默认行为 event.returnValue=false; &#125; &#125; stopPropagation:function(event)&#123; if(event.stopPropagation)&#123; event.stopPropagation(); //DOMO级或DOM2级取消事件进一步冒泡或者捕获 &#125;else&#123; event.cancelBubble=true; //IE中取消时间冒泡 &#125; &#125;, getRelatedTarget:function(event)&#123; //获取mouseover和mouseout相关元素//mouseover与mouseout有“主目标”和“相关元素”的概念，因为在发生mouseover或mouseout事件时，还会涉及到其他元素，这两个事件都会涉及把鼠标指针从一个元素移到另一个元素。具体来说，对mouseover事件，事件的主目标是获得光标的元素，而相关元素是那个失去光标的元素，对mouseout事件而言，事件的主目标是失去光标的元素，而相关元素是那个获得光标的元素。 if(event.relatedTarget)&#123; return event.relatedTarget; &#125; else if(event.toElement)&#123; //mouseout触发时，IE的toElement保存的相关元素属性 return event.toElement; &#125; else if(event.formElement)&#123; //mouseover触发时，IE的formElement保存相关元素属性 return event.formElement; &#125; else&#123; return null; &#125; &#125;, getButton:function(event)&#123; //获取mousedown或mouseup按下或释放的按钮是鼠标的哪一个 if(document.implementation.hasFeature(&quot;MouseEvents&quot;,&quot;2.0&quot;))&#123; return event.button; &#125;else&#123; switch(event.button)&#123;//将IE模型下的button属性映射为DOM模型下的button属性 case 0: case 1; case 3; case 5; case 7; return 0; //按下的是鼠标主按钮（一般是左键） case 2: case 6: return 2; //按下的是中间的鼠标按钮 case 4: return 1; //鼠标次按钮（一般是右键） &#125; &#125; &#125;, getWheelDelta:function(event)&#123; //获取表示鼠标滚轮滚动方向的数值//解决的是与Firefox的差异 if(event.wheelDelta)&#123; return event.wheelDelta; &#125; else&#123; return -event.detail*40; &#125; &#125;, getCharCode:function(event)&#123; //跨浏览器取得相同的字符编码，需在keypress事件中使用//在所有浏览器中，按下能够插入或删除的字符的按键都会触发keypress事件，但IE8-及Opera取得字符编码的方式与其他浏览器有差异 if(typeof event.charCode==&quot;number&quot;)&#123; return event.charCode; &#125;else&#123; return event.keyCode; &#125; &#125;&#125; 举例用法1234567//添加了EventUtil之后，获取了event对象、取消了事件进一步捕获或者冒泡、指定了事件的处理程序而无须担心浏览器兼容问题var btn=document.getElementById(&quot;#btn&quot;);var handler=function(event)&#123; event=EventUtil.getEvent(event); EventUtil.stopPropagation(event); &#125;Event.addHandler(btn,&quot;click&quot;,handler); 补充addEventListener的第三个参数useCapture事件有三个阶段：捕获阶段：外–&gt;里目标阶段：冒泡阶段：里–&gt;外useCapture是一个布尔值，默认是false。如果是true的话表示在事件捕获阶段调用事件处理程序；如果是false表示在事件冒泡阶段处理程序。","categories":[],"tags":[],"keywords":[]},{"title":"为什么js没有函数签名","slug":"为什么js没有函数签名","date":"2017-05-01T02:30:42.000Z","updated":"2017-05-02T01:18:01.451Z","comments":true,"path":"2017/05/01/为什么js没有函数签名/","link":"","permalink":"https://aliceflaviawang.github.io/2017/05/01/为什么js没有函数签名/","excerpt":"","text":"什么是函数签名MDN上关于函数签名的说明：A function signature(or type signature, or method signature) defines input and putput of functions or methods.A signature can include: parameters and their types a return value and type exceptions that might be thrown or passed back information about the availability of the method in an object-oriented program(such as the keywords public, static, or prototype).翻译过来就是函数签名定义了函数或方法的输入输出，签名包括参数个数和类型、返回值和类型、抛出或者往后传的异常、面向对象程序方法可行性的信息。为什么js没有函数签名在其他语言中，命名参数必须要求事先创建函数签名，将来调用也必须与该签名一致；而js的参数是由包含0个或多个值的数组来表示的，命名参数只是提供便利，但不是必须的，解析器也不会验证命名参数，所以js没有签名。举个例子：1234function sayHi()&#123; alert(&quot;Hi &quot;+arguments[0]+&quot;, &quot;+arguments[1]);&#125;sayHi(&quot;Alice&quot;,&quot;how are you?&quot;); 对这个例子，命名参数为空，但是照样可以按照两个参数的格式去调用该方法，是因为对ECMAScript，无论传递给函数的参数是什么，函数接收到的始终都是数组，通过arguments对象访问的参数数组。所谓的参数类型、参数个数、参数位置、出入参数，js都不关心，它所有的值都被放倒arguments中了，需要返回值的话直接return，不用声明。","categories":[],"tags":[],"keywords":[]},{"title":"slice(), substring(), substr()总结","slug":"slice-substring-substr-总结","date":"2017-04-25T13:47:05.000Z","updated":"2017-04-25T13:56:07.132Z","comments":true,"path":"2017/04/25/slice-substring-substr-总结/","link":"","permalink":"https://aliceflaviawang.github.io/2017/04/25/slice-substring-substr-总结/","excerpt":"","text":"slice(), substring(), substr()都是用来获取子字符串，，且不会修改字符串本身的值。区别：1、参数不同slice: slice(start, end) //start表示子字符串开始的位置，end是子字符串最后一个字符后面的位置substring: substring(start, end) //同slicesubstr: substr(start, num) //num表示返回字符的个数2、参数是负值的情况不同slice: 将负值与字符串长度相加substring： 将所有的负值转换成0，且会将较小的数作为开始位置，较大的数作为结束位置substr: 将负的第一个参数加上字符串长度，负数第二个参数转换为0```var s=”hello world”;s.slice(3,-4); //“lo w”s.substring(3,-4); //“hel”s.substr(3,-4); //“”（空字符串）","categories":[],"tags":[],"keywords":[]},{"title":"append和prepend","slug":"append和prepend","date":"2017-04-24T14:09:07.000Z","updated":"2017-04-24T14:17:54.922Z","comments":true,"path":"2017/04/24/append和prepend/","link":"","permalink":"https://aliceflaviawang.github.io/2017/04/24/append和prepend/","excerpt":"","text":"append()和prepend()方法都是jQuery文档操作方法，append()在被选元素的结尾插入指定内容，而prepend()则是在被选元素的前面插入制定内容。比如：1234&lt;div id=&quot;console&quot;&gt; &lt;h2&gt;Console Log&lt;/h2&gt; &lt;ul&gt;&lt;/ul&gt;&lt;/div&gt; 添加元素到ul中123456var $consoleLog = $(&quot;#console ul&quot;); var show = function(msg) &#123; var $msg = $(&quot;&lt;li&gt;&lt;/li&gt;&quot;); $msg.text(msg); $consoleLog.prepend($msg); &#125;; 此处采用prepend是从下往上的添加元素，最新添加的元素显示在最上面.注：$(&quot;&lt;li&gt;&lt;/li&gt;&quot;)是创建一个li元素并返回jQuery对象，不是选中它，因为这样创建的元素还不在html结构中，只是在内存中存在。","categories":[],"tags":[],"keywords":[]},{"title":"transform-origin,rotate实现绕中心旋转","slug":"transform-origin-rotate实现绕中心旋转","date":"2017-04-24T13:40:49.000Z","updated":"2017-04-24T14:00:43.435Z","comments":true,"path":"2017/04/24/transform-origin-rotate实现绕中心旋转/","link":"","permalink":"https://aliceflaviawang.github.io/2017/04/24/transform-origin-rotate实现绕中心旋转/","excerpt":"","text":"一般实现环形旋转可以通过animation动画的方式举个例子：1&lt;img src=&quot;images/min-iconfont-rocket-active.png&quot;&gt; 通过animation，对应的css代码为：1234567891011121314@keyframes spin&#123; to&#123; transform: rotate(1turn); &#125;&#125;img&#123; position: absolute; top:50px; left:50px; width:50px; height:50px; animation:spin 10s infinite linear; transform-origin:150px 150px;&#125; 也可以通过transform-origin+rotate的js实现，transform-origin对应旋转中心的位置，rotate可以设置旋转的角度。设置一个图片进行旋转，对于的css代码12345678img&#123; position: absolute; top:50px; left:50px; width:50px; height:50px; transform-origin: 150px 150px; //设置旋转的中心位置 &#125; 对应的js123456789var deg=0;var timer=setInterval(function()&#123; deg+=10; rotate(deg);&#125;,20)function rotate(deg)&#123; var my=&quot;rotate(&quot;+deg+&quot;deg)&quot; $(&quot;img&quot;).css(&quot;transform&quot;,my)&#125; 对于transform-orgin其默认的位置是元素的中心位置，可以通过设置重新确定中心。注：想了解更多transform实现环形路径平移动画，可以参看 http://www.open-open.com/lib/view/open1478661385568.html.","categories":[],"tags":[],"keywords":[]},{"title":"apply()和call()用法","slug":"apply-和call-用法","date":"2017-04-24T03:10:47.000Z","updated":"2017-04-24T06:38:18.223Z","comments":true,"path":"2017/04/24/apply-和call-用法/","link":"","permalink":"https://aliceflaviawang.github.io/2017/04/24/apply-和call-用法/","excerpt":"","text":"每个函数都有两个非继承的方法：apply（）和call()。这两个方法都是在特定作用域中调用函数，实际上等于设置函数体内this对象的值。 方法定义1、apply()方法——apply([thisObj[,argArray]])apply()接收两个参数：一个是运行函数的作用域，另一个是参数数组。其中第二个参数可以是Array的实例，也可以是arguments对象。 2、call()方法——call([thisObj[,arg1[, arg2[, [,.argN]]]]])与apply作用相同，区别在于接收参数方式不同。第一个参数this的值没有变化，其余参数是以列举的方式直接传递给函数。 作用1、扩充函数赖以运行的作用域12345678910window.color=&quot;red&quot;;var o=&#123;color:&quot;blue&quot;&#125;;function sayColor()&#123;alert(this.color)&#125;sayColor(); //redsayColor.call(this); //redsayColor.call(window); //redsayColor.call(o); //blue sayColor.call(o)与o.sayColor()效果一样，但是使用call()(或apply())是的对象不需要与方法有任何耦合关系。 2、实现继承1234567891011function Animal(name)&#123;this.name=name;this.showName=function()&#123;alert(this.name);&#125;&#125;function Cat(name)&#123;Animal.call(this,name);&#125;var cat=new Cat(&apos;Black Cat&apos;);cat.showName(); //Black Cat 3、实现多重继承12345678910111213141516171819202122var s1=function(name)&#123;this.name=name;&#125;var s2=function(sex)&#123;this.sex=sex;&#125;var s3=function(age)&#123;this.age=age;&#125;var Student=function(name,sex,age,score)&#123;s1.call(this,name);s2.call(this,sex);s3.call(this,age);this.score=score;&#125;Student.prototype.construction=Student;var s=new Student(&apos;jack&apos;,&apos;male&apos;,&apos;32&apos;,&apos;100&apos;);console.log(s.name); //jackconsole.log(s.sex); //maleconsole.log(s.age); //32console.log(s.score); //100","categories":[],"tags":[],"keywords":[]},{"title":"理解arguments","slug":"理解arguments","date":"2017-04-24T02:02:40.000Z","updated":"2017-04-24T02:38:43.555Z","comments":true,"path":"2017/04/24/理解arguments/","link":"","permalink":"https://aliceflaviawang.github.io/2017/04/24/理解arguments/","excerpt":"","text":"ECMAScript中的参数是用一个数组表示的。无论传递给函数的参数是什么（有或者没有），函数接收到的始终都是这个数组。在函数体内通过arguments对象来访问这个参数数组，从而获取传递给函数的每个参数。例如：1234function sayHi(name,message)&#123;return;alert(&quot;Hello &quot;+name+&quot;,&quot;+message);&#125; 可以用arguments重写不显示的使用命名参数：1234function sayHi()&#123;return;alert(&quot;Hello &quot;+arguments[0]+&quot;,&quot;+arguments[1]);&#125; arguments特性1、arguments对象的长度是由传入的参数的长度决定的，不是由定义函数时的命名参数的个数决定的123456function howManyArgs(&#123;alert(arguments.length);&#125;howManyArgs(&quot;string&quot;,45); //2howManyArgs(); //0howManyArgs(12) //1 2、arguments的值永远与对应命名参数的值保持同步1234function doAdd(num1,num2)&#123;arguments[1]=10;alert(arguments[0]+num2);&#125; 每次执行doAdd函数都会重写第二个参数（将其修改为10），因为arguments[1]的对象的值会自动反映到对应的命名参数，所以修改了arguments[1]也就修改了num2，他们的值会同步（但内存空间是独立的）。如果只传入了一个参数，arguments[1]的值不会反映到命名参数中（因为特性1）。 3、arguments对象有个callee属性callee属性是一个指针，指向拥有这个arguments对象的函数。1234567fucntion factorial(num)&#123;if(num&lt;=1)&#123;return 1;&#125;else&#123;return num*factorial(num-1);&#125;&#125; 上面的函数的执行与函数名紧紧耦合在一起，为了消除这种紧密耦合现象，可以用arguments.callee。1234567function factorial(num)&#123;if(num&lt;=1)&#123;return 1;&#125;else&#123;return num*arguments.callee(num-1);&#125;&#125; 这样，无论引用函数是时使用的什么名字，都可以保证正常递归调用。看一个例子：12345678910111213function factorial(num)&#123;if(num&lt;=1)&#123;return 1;&#125;else&#123;return num*arguments.callee(num-1);&#125;&#125;var trueFactoral=factorial;factorial=function()&#123;return 0;&#125;alert(trueFactoral(5)); //120alert(factorial(5)); //0 而使用函数名，则：12345678910111213function factorial(num)&#123;if(num&lt;=1)&#123;return 1;&#125;else&#123;return num*factorial(num-1);&#125;&#125;var trueFactoral=factorial;factorial=function()&#123;return 0;&#125;alert(trueFactoral(5)); //0alert(factorial(5)); //0 后记——函数对象的caller属性当一个函数调用另一个函数时，被调用的函数会自动生成一个caller属性，指向调用它的函数对象。若该函数未被调用或没有被其他函数调用，caller为null。而arguments.callee是函数被调用时，arguments.callee对象指向自身，是对自己的引用。注：arguments在函数调用时才有效，因为arguments.callee在函数未调用时是不存在的（即null.callee)。","categories":[],"tags":[],"keywords":[]},{"title":"translate(-50%,-50%)的作用","slug":"translate-50-50-的作用","date":"2017-04-22T14:01:12.000Z","updated":"2017-04-22T14:01:34.392Z","comments":true,"path":"2017/04/22/translate-50-50-的作用/","link":"","permalink":"https://aliceflaviawang.github.io/2017/04/22/translate-50-50-的作用/","excerpt":"","text":"当使用top:50%;left:50%的时候，是以左上角为原点，故元素不处于中心位置。translate(-50%,-50%)的作用是往上（x轴），左（y轴）移动自身长宽的50%，使得元素处于中心位置。例如：1234&lt;div id=&quot;outer&quot;&gt; &lt;div id=&quot;inner&quot;&gt; &lt;/div&gt;&lt;/div&gt; 如果不加transform属性1234567891011121314#outer&#123; position: relative; width: 500px; height: 500px; border: 1px solid black;&#125;#inner&#123; position: absolute; top: 50%; left: 50%; width: 100px; height: 100px; background-color: red;&#125; inner框的左上角处于中心位置，如果希望其中心居于中心位置，将应该向上和向左移动一半的边长长度。加上transform属性，就可以实现这个效果：123456789101112#inner &#123; position: absolute; top: 50%; left: 50%; width: 100px; height: 100px; background-color: red; -ms-transform: translate(-50%,-50%); -moz-transform: translate(-50%,-50%); -o-transform: translate(-50%,-50%); transform: translate(-50%,-50%); &#125;","categories":[],"tags":[],"keywords":[]},{"title":"阿里暑期前端面试总结","slug":"阿里暑期前端面试总结","date":"2017-04-19T10:40:53.000Z","updated":"2017-04-19T10:40:53.645Z","comments":true,"path":"2017/04/19/阿里暑期前端面试总结/","link":"","permalink":"https://aliceflaviawang.github.io/2017/04/19/阿里暑期前端面试总结/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"腾讯暑期实习面试前端面试总结","slug":"腾讯暑期实习面试前端面试总结","date":"2017-04-19T07:36:12.000Z","updated":"2017-04-19T08:25:23.577Z","comments":true,"path":"2017/04/19/腾讯暑期实习面试前端面试总结/","link":"","permalink":"https://aliceflaviawang.github.io/2017/04/19/腾讯暑期实习面试前端面试总结/","excerpt":"","text":"4月13号参加的腾讯面试，不得不说面试机制还是比较完善，通知的10点面试，9点20到达酒店之后，差不多10点就通知了面试地点去候场。因为房间门是开的，所以听到了前一个人的部分面试问题：1、http状态码有哪些，代表的什么意思2、用过缓存没有，local storage和session storage有什么区别3、你说你学过node js，讲一下于是我在门外默默的准备了一下，进去之后面试官看了我的简历上写本科是信息安全，于是问我公钥加密和私钥加密有什么区别。。。我大概记得，但是说反了，然后开始问我一串安全相关的问题，安全掌握的不怎么好，面试官大概没有很多兴趣，就简单问了下css和一个逻辑题就完了：1、Web安全2、url是怎么加密的3、css的优先级4、逻辑题：给一个不规则的5L和6L的桶，装一个3升的水然后很显然就没有然后了，通过此次面试，觉得自己还是要多注意Web安全方面的知识，另外简历上处处都有可能问到，主要看面试官比较擅长哪方面，所以只要写上去都要有所准备。","categories":[],"tags":[],"keywords":[]},{"title":"easyui两个datagrid的问题","slug":"easyui两个datagrid的问题","date":"2017-04-11T11:11:39.000Z","updated":"2017-04-11T11:21:49.478Z","comments":true,"path":"2017/04/11/easyui两个datagrid的问题/","link":"","permalink":"https://aliceflaviawang.github.io/2017/04/11/easyui两个datagrid的问题/","excerpt":"","text":"问题easyui框架下，当一个页面出现两个datagrid，或者说出现两个table的时候，datagrid的某些属性会失效，比如说pagination分页会失效. 解决办法使用两个div将两个datagrid分开，但是使用两个div后，页面不能填充整个屏幕，所以解决两个datagrid分页失效的问题转化为了如何让div填充整个屏幕的问题。解决方法如下：123456789&lt;style&gt;html, body&#123;margin:0;padding:0;&#125;div&#123;width:100%;&#125;&lt;/style&gt;","categories":[],"tags":[],"keywords":[]},{"title":"easyui表格查询","slug":"easyui表格查询","date":"2017-04-10T13:09:22.000Z","updated":"2017-04-10T13:24:40.892Z","comments":true,"path":"2017/04/10/easyui表格查询/","link":"","permalink":"https://aliceflaviawang.github.io/2017/04/10/easyui表格查询/","excerpt":"","text":"easyui表格查询非常简单，比如说对于一个datagrid如下1234567891011121314151617181920212223242526272829303132333435363738&lt;div id=&quot;toolbar1&quot;&gt; &lt;div style=&quot;padding:3px&quot;&gt; &lt;span&gt;部门 ID:&lt;/span&gt; &lt;input id=&quot;deptId&quot; style=&quot;line-height:26px;border:1px solid #ccc&quot;&gt; --&gt; &lt;span&gt;部门名称:&lt;/span&gt; &lt;input id=&apos;dd&apos; &gt; &lt;span&gt;岗位类型:&lt;/span&gt; &lt;input id=&apos;dd3&apos; &gt; &lt;span&gt;设岗科室名称:&lt;/span&gt; &lt;input id=&apos;dd2&apos; style=&quot;line-height:22px;border:1px solid #ccc;border-radius:5px;&quot;&gt; &lt;span&gt;指导老师:&lt;/span&gt; &lt;input id=&apos;dd1&apos; style=&quot;line-height:22px;border:1px solid #ccc;border-radius:5px;&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;easyui-linkbutton&quot; plain=&quot;true&quot; iconCls=&quot;icon-search&quot; onclick=&quot;doFind()&quot;&gt;查询&lt;/a&gt; &lt;/div&gt; &lt;div&gt;&lt;table id=&quot;tt1&quot; title=&quot;岗位申请&quot; class=&quot;easyui-datagrid&quot; style=&quot;width:100%;height:auto;&quot; singleSelect=&quot;true&quot; data-options=&quot;fit:true&quot; rownumbers=&quot;true&quot; idField=&apos;deptId&apos; method=&apos;post&apos; toolbar=&apos;#toolbar1&apos;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th rowspan=&quot;2&quot; field=&quot;deptId&quot; width=&quot;5%&quot; align=&quot;center&quot;&gt;学院/部门ID&lt;/th&gt; &lt;th rowspan=&quot;2&quot; field=&quot;deptName&quot; width=&quot;6%&quot; align=&quot;center&quot;&gt;学院/部门名称&lt;/th&gt; &lt;th rowspan=&quot;2&quot; field=&quot;jobTime&quot; width=&quot;6%&quot; align=&quot;center&quot;&gt;岗位时间&lt;/th&gt; &lt;th rowspan=&quot;2&quot; field=&quot;teacherName&quot; width=&quot;6%&quot; align=&quot;center&quot;&gt;指导老师&lt;/th&gt; &lt;th rowspan=&quot;2&quot; field=&quot;telephone&quot; width=&quot;7%&quot; align=&quot;center&quot;&gt;指导老师电话&lt;/th&gt; &lt;th rowspan=&quot;2&quot; field=&quot;guideTrain&quot; width=&quot;10%&quot; align=&quot;center&quot;&gt;指导与培训体系&lt;/th&gt; &lt;th colspan=&quot;6&quot; align=&quot;center&quot; &gt;岗位要求&lt;/th&gt; &lt;th rowspan=&quot;2&quot; field=&quot;statusCodeName&quot; align=&quot;center&quot; width=&quot;5%&quot;&gt;审核状态&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th field=&quot;officeName&quot; align=&quot;center&quot; width=&quot;9%&quot;&gt;设岗科室名称&lt;/th&gt; &lt;th field=&quot;typeName&quot; align=&quot;center&quot; width=&quot;8%&quot;&gt;岗位类型&lt;/th&gt; &lt;th field=&quot;jobNum&quot; align=&quot;center&quot; width=&quot;8%&quot;&gt;设岗科室岗位数&lt;/th&gt; &lt;th field=&quot;jobWork&quot; align=&quot;center&quot; width=&quot;8%&quot;&gt;科室工作量&lt;/th&gt; &lt;th field=&quot;responsibility&quot; align=&quot;center&quot; width=&quot;10%&quot;&gt;科室工作职责&lt;/th&gt; &lt;th field=&quot;ability&quot; align=&quot;center&quot; width=&quot;12%&quot;&gt;科室岗位培养的综合素质&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;/table&gt; 查询部分的js代码12345678910111213function doFind()&#123;//获取查询条件 var val = $(&apos;#dd&apos;).combobox(&apos;getValue&apos;); var teacherName = $(&apos;#dd1&apos;).val(); var officeName = $(&apos;#dd2&apos;).val(); var type = $(&apos;#dd3&apos;).combobox(&apos;getValue&apos;);//根据查询条件在表格tt中load出来$(&quot;#tt1&quot;).datagrid(&apos;load&apos;,&#123;deptId:val,teacherName:teacherName,officeName:officeName,type:type&#125;) 但是发现这样有问题，如果某项没填，比如teacherName为空，那么将会在表格中查询teacherName为空的项，从而查不到结果。因此采取先判断查询项是否为空，才能得出正确结果。123456789101112131415161718192021222324252627function doFind()&#123; var val = $(&apos;#dd&apos;).combobox(&apos;getValues&apos;);//允许多选的情况，首先要在id为dd的combobox设置multipl为true if (val[0] == &apos;&apos;) &#123; val = val.slice(1) &#125; var teacherName = $(&apos;#dd1&apos;).val(); var officeName = $(&apos;#dd2&apos;).val(); var type = $(&apos;#dd3&apos;).combobox(&apos;getValue&apos;) var deptIds = val.join(&apos;,&apos;);//将每项用,分开 var query = &#123;&#125; //判断查询条件是否为空，将查询条件保存到对象中 if(teacherName)&#123; query.teacherName=teacherName; &#125; if(officeName)&#123; query.officeName=officeName; &#125; if(type)&#123; query.type=type; &#125; if(deptIds)&#123; query.deptId=deptIds; &#125; $(&apos;#tt1&apos;).datagrid(&apos;load&apos;, query); &#125;","categories":[],"tags":[],"keywords":[]},{"title":"easyui的dialog中插入下拉框","slug":"easyui的dialog中插入下拉框","date":"2017-04-10T12:53:55.000Z","updated":"2017-04-10T13:06:30.491Z","comments":true,"path":"2017/04/10/easyui的dialog中插入下拉框/","link":"","permalink":"https://aliceflaviawang.github.io/2017/04/10/easyui的dialog中插入下拉框/","excerpt":"","text":"easyui是一个集成了各种用户界面的插件的框架，特别使用各种表格的开发，能大大节省时间。在项目中遇到的问题时，下dialog中无法使用combobox生成下拉框，于是只能通过打开dialog时插入一个下拉框。1234567891011121314151617181920212223$(&apos;#fm_deptId&apos;).append(&apos;&lt;option&gt;bitem6&lt;/option&gt;&apos;); var depts = []; var query = &#123; rows: 200, page: 1 &#125; var newHtml = &apos;&apos;; $.ajax(&#123; type: &apos;POST&apos;, async: false, url: url_queryDept,//向接口请求下拉框数据 contentType: &quot;application/json; charset=utf-8&quot;, data: JSON.stringify(query), dataType: &apos;json&apos;, success: function(data) &#123; $.each(data.result, function(i, val) &#123; var temp = val.deptId + val.deptName;数据由一个id和name组成 var option = &apos;&lt;option value=&apos; + val.deptId + &apos;&gt;&apos; + temp + &apos;&lt;/option&gt;&apos;; newHtml = newHtml + option; &#125;) $(&apos;#fm_deptId&apos;)[0].innerHTML = newHtml; &#125;&#125;) 注：如果想要选中下拉框的某一个选项作为下拉框的默认值1$(&apos;#fm_deptId option[value=&apos;+ current_deptId+&apos;] &apos;).attr(&quot;selected&quot;,true);","categories":[],"tags":[],"keywords":[]},{"title":"win10永久激活方方法","slug":"win10永久激活方方法","date":"2017-04-10T12:44:58.000Z","updated":"2017-04-10T12:48:18.180Z","comments":true,"path":"2017/04/10/win10永久激活方方法/","link":"","permalink":"https://aliceflaviawang.github.io/2017/04/10/win10永久激活方方法/","excerpt":"","text":"今天提示win10许可证要过期了，于是尝试了各种工具，Microsoft Toolkit、HEU_KMS_Activator、KMS10_Crack2都不行，最后在网上找到了这个方法，一分钟不到就搞定了，分享一下网址https://jingyan.baidu.com/article/73c3ce282431dbe50343d9a9.html。","categories":[],"tags":[],"keywords":[]},{"title":"JS与jQuery显示和隐藏div","slug":"JS与jQuery显示和隐藏div","date":"2017-04-10T12:25:07.000Z","updated":"2017-04-10T12:39:10.062Z","comments":true,"path":"2017/04/10/JS与jQuery显示和隐藏div/","link":"","permalink":"https://aliceflaviawang.github.io/2017/04/10/JS与jQuery显示和隐藏div/","excerpt":"","text":"关于div隐藏很显示的问题，经常遇到，JS和jQuery有不同的处理方式。1&lt;div id=&quot;div&quot;&gt;&lt;/div&gt; JS方式123document.getElementById(&quot;div&quot;).style.display=&quot;block&quot;;document.getElementById(&quot;div&quot;).style.display=&quot;none&quot;;//不占用空间document.getElementById(&quot;div&quot;).style.display=&quot;hidden&quot;;//仍然占用空间 jQuery方式123456//通过css方法设置属性$(&quot;#div&quot;).css(&quot;diaplay&quot;,&quot;block&quot;);//给元素换class，提前将换的class样式定义好display属性$(&quot;#div&quot;).attr(&quot;class&quot;,&quot;blockclass&quot;);//通过attr方法$(&quot;#div&quot;).attr(&quot;display&quot;,&quot;block&quot;); 注：jQuery的css方法和attr方法的区别,css顾名思义就是标签自带的css属性，atrr只能取自己定义的属性，例如，如果div中没有diaplay这个属性的话，不能用过attr给其赋值，但是可以用css方法。","categories":[],"tags":[],"keywords":[]},{"title":"JS与jQuery清空输入框","slug":"JS与jQuery清空输入框","date":"2017-04-10T12:12:09.000Z","updated":"2017-04-10T12:16:41.821Z","comments":true,"path":"2017/04/10/JS与jQuery清空输入框/","link":"","permalink":"https://aliceflaviawang.github.io/2017/04/10/JS与jQuery清空输入框/","excerpt":"","text":"input输入框输入之后，再次输入的时候需要清空输入框。对于input输入框，JS与jQuery清空方式不同。1&lt;input id=&quot;input&quot; type=&quot;text&quot; name=&quot;input&quot;&gt; JS方式1document.getElementById(&quot;input&quot;).value=&quot;&quot;; jQuery方式1$(&quot;#input&quot;).val(&quot;&quot;);","categories":[],"tags":[],"keywords":[]},{"title":"java二维排序数组查找元素","slug":"java二维排序数组查找元素","date":"2017-04-09T13:09:30.000Z","updated":"2017-04-09T13:14:14.945Z","comments":true,"path":"2017/04/09/java二维排序数组查找元素/","link":"","permalink":"https://aliceflaviawang.github.io/2017/04/09/java二维排序数组查找元素/","excerpt":"","text":"题目描述在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 简单做法看到这个题目，如果不考虑数组元素的排序，只考虑能不能找到的话，非常简单。12345678910public boolean Find(int target, int [][] array) &#123; for(int i=0;i&lt;array.length;i++)&#123; for(int j=0;j&lt;array[0].length;j++)&#123; if(array[i][j]==target)&#123; return true; &#125; &#125; &#125; return false; &#125; 运行效果 题目的本质因为数组是排序的，所以考虑用二分查找，而查找不能盲目的查找，比如从第一个元素开始查找，如果比目标元素小，是往下找还是往右找呢，同里也不能从最后一个元素开始查找，可以从第一行最右边开始查找，如果比目标元素大就往左查找，反之往下查找，同理也可以从第一列最下边开始查找。举例从第一行最右边开始查找，代码如下：12345678910111213141516public boolean Find(int target, int [][] array) &#123; int row=0; int col=array[0].length-1; while(row&lt;array.length&amp;&amp;col&gt;=0)&#123; if(array[row][col]==target) &#123; return true; &#125; else if(array[row][col]&lt;target)&#123; row++; &#125; else&#123; col--; &#125; &#125; return false; &#125; 运行效果 完整代码1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.company;import java.util.Scanner;public class Solution &#123; public boolean Find(int target, int [][] array) &#123; int row=0; int col=array[0].length-1; while(row&lt;array.length&amp;&amp;col&gt;=0)&#123; if(array[row][col]==target) &#123; return true; &#125; else if(array[row][col]&lt;target)&#123; row++; &#125; else&#123; col--; &#125; &#125; return false; &#125; public static void main(String srgs[])&#123; Scanner s=new Scanner(System.in); System.out.println(&quot;请输入数组的行和列&quot;); int x=s.nextInt(); int y=s.nextInt(); int [][]arr=new int[x][y]; System.out.println(&quot;请输入数组元素&quot;); for(int i=0;i&lt;x;i++)&#123; for(int j=0;j&lt;y;j++)&#123; arr[i][j]=s.nextInt(); &#125; &#125; System.out.println(&quot;请输入你想查找的数：&quot;); int t=s.nextInt(); Solution a=new Solution(); if(a.Find(t,arr))&#123; System.out.println(&quot;数组&quot;+arr+&quot;中有数&quot;+t); &#125;else&#123; System.out.println(&quot;数组&quot;+arr+&quot;中没有数&quot;+t); &#125; &#125;&#125;","categories":[],"tags":[],"keywords":[]},{"title":"基于easyui项目学习的总结（一）","slug":"基于easyui项目学习的总结（一）","date":"2017-04-09T12:59:26.000Z","updated":"2017-04-09T13:02:35.131Z","comments":true,"path":"2017/04/09/基于easyui项目学习的总结（一）/","link":"","permalink":"https://aliceflaviawang.github.io/2017/04/09/基于easyui项目学习的总结（一）/","excerpt":"","text":"最近在做的项目，是基于easyui框架，项目进度非常紧张，并没有太多时间来总结，就用零碎时间一点点总结吧，主要是从网上及大神同学身上学到了很多。 easyui placeholder解决方案因为easyui经常用到table、textbox，因此会遇到需要用placeholder来提示输入内容的时候，但是easyui不支持h5的placeholder,因此，为了实现这个效果，在网上找到了解决方案。1、给input标签添加placeholder1&lt;input id=&quot;fm_jobTime&quot;&quot; name=&quot;jobTime&quot; class=&quot;easyui-textbox&quot; required=&quot;true&quot; label=&quot;岗位时间:&quot; style=&quot;width:100%&quot; placeholder=&quot;xxxx年x月-xxxx年x月&quot;&gt; 2、页面加载完毕的时候，将easyui生成的input标签的placeholder重置12345678910111213141516$(function()&#123;window.onload = inputPlaceholder();&#125;);/**easyui number placeholder*/function numberinputPlaceholder()&#123;$(&quot;.easyui-textbox&quot;).each(function(i)&#123;var span = $(this).siblings(&quot;span&quot;)[0];var targetInput = $(span).find(&quot;input:first&quot;);if(targetInput)&#123;$(targetInput).attr(&quot;placeholder&quot;, $(this).attr(&quot;placeholder&quot;));&#125;&#125;);&#125;","categories":[],"tags":[],"keywords":[]},{"title":"git bash命令上传下载代代码","slug":"git bash命令上传下载代代码","date":"2017-04-08T12:37:28.000Z","updated":"2017-04-08T12:38:13.134Z","comments":true,"path":"2017/04/08/git bash命令上传下载代代码/","link":"","permalink":"https://aliceflaviawang.github.io/2017/04/08/git bash命令上传下载代代码/","excerpt":"","text":"git bash是window下的命令行工具，在官网上下载git for windows安装即可。如何通过git bash将代码传到git上和下载到本地的呢remote 上传到git1、安装完成后，在命令行输入下面的代码进行配置12$ git config --global user.name &quot;your real name&quot;$ git config --global user.email &quot;your eamil address&quot; 注：”your real name“是你的真实姓名，”your eamil address”是你的注册github的邮箱2、在主用户目录下，输入下面的代码1$ ssh-keygen -t rsa -C &quot;your eamil address 然后在自己电脑的C盘下找到.ssh文件夹，用记事本打开里面的id_rsa.pub,复制里面的内容。登陆Github，在账户设置里找到SSH keys页面，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容。3、利用”cd”命令将路径切换到你要上传的代码所在的文件夹下面（或者打开你要上传的代码的文件夹，右键git bash here）,输入一下代码：123$git init //把目录变成git可以管理的仓库$git add . //add后面加&quot;.&quot;表示上传所以的代码，如果想上传指定的，只需要把&quot;.&quot;改成文件名即可$git commit -m &quot;你对文件的描述&quot; //提交你对文件的描述 4、在本地仓库目录下输入下面命令将本地仓库和远程仓库关联（如果已经上传过代码了，可以直接跳到第6步）1$git remote add orgin git@github.com:yonghuming/kuming.git origin可是换成你想要的任何名字，但是要记住这个源名字（与第6步的origin对应，我每次都是新起一个名字因为经常提示origin已经存在了）5、输入如下代码，将自己的文件上传1$git push -u origin master 其实github上每次创建一个新的仓库的时候，都有命令提示 从git上下载$git clone git@github.com:yonghuming/kuming.git 更新$git pull origin master 经常遇到的问题error:src refspec master does not match any原因：本地版本库为空，空目录不能提交","categories":[],"tags":[],"keywords":[]},{"title":"Github Pages+Hexo搭建教程","slug":"Github-Pages-Hexo搭建教程","date":"2017-04-04T13:44:17.000Z","updated":"2017-04-07T03:11:41.888Z","comments":true,"path":"2017/04/04/Github-Pages-Hexo搭建教程/","link":"","permalink":"https://aliceflaviawang.github.io/2017/04/04/Github-Pages-Hexo搭建教程/","excerpt":"","text":"前言越来越感觉世界真是太大了，每天学习很多东西，希望能够记录下来自己学习的点点滴滴，也能分享给更多的人，因此搭建了这个博客。关于为什么选择github pages而不是wordpress，因为github pages有300M免费空间，资料自己管理，保存可靠，而且现在的项目开发，团队协作都需要用到github，通过搭建博客也更好的学习了如何使用github。 github安装在官网https://git-for-windows.github.io/上下载git，安装比较简单。访问http://www.github.com/，注册username和邮箱，注册过程也比较简单。 使用GitHub Pages建立博客github建立仓库登陆系统后，在github首页，点击页面右下角New Repository填写项目信息：project name:aliceflaviawang.github.io注：GitHub Pages的Repository名字是特定的，比如我的Github账号是aliceflaviawang,那么我的GitHub Pages Repository名字就是aliceflaviawang.github.io。点击Create Reposity完成创建。进入创建的仓库，打开Settings选择一个主题选择完毕，回到仓库页面，发现多了两个文件，_config.yml是配置文件。此时打开aliceflaviawang.github.io，可以看到index.md显示的内容。 安装node.js参考教程http://www.runoob.com/nodejs/nodejs-install-setup.html，非常简单。 用Hexo克隆主题Hexo介绍Hexo是一个简单、快速、强大的博客发布工具，支持Markdown格式 安装Hexo打开git bash或者cmd,进入node文件夹，安装hexo注：-g是全局安装的意思 部署Hexo在我的电脑中建立一个名叫Hexo的文件夹，然后在此文件夹中右键打开Git Bash.Hexo会自动在目标文件夹建立网站所需要的所有文件。 复制主题建立Hexo之后就可以复制主题了，网上有很多好看的主题可以自己选择。此处选择的是wuchong的主题。 启用主题修改Hexo目录下的_config.yml,将theme属性设置为jacman。 更新主题 本地查看调试 hexo g是生成，hexo d是部署，可是先后使用或者直接使用组合命令hexo d -g，发现Hexo文件夹生成了public文件。 查看搭建效果浏览器输入http://localhost:4000,查看搭建效果。如果localhost:4000无法访问，是因为你的电脑端口被占用了，而hexo默认的端口是4000，可以通过修改端口来解决这个问题。 比如将端口改成4040现在就可以看到效果了 Hexo设置网站搭建完成之后，可以根据需要对Hexo生产的网站进行设置，设置是修改_config.yml，我复制一下别人的设置，可以参考一下。 Hexo Configuration123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: XTong notessubtitle: Live beautifully, dream passionately, love completelydescription: You Never Know Who You Areauthor: X T Wlanguage: zh-Hanstimezone: Asia/Shanghai# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: https://aliceflaviawang.github.io/root: /permalink: :year/:month/:day/:title/permalink_defaults:# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: false tab_replace:# Category &amp; Tagdefault_category: othercategory_map:tag_map:# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 8pagination_dir: page# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: jacman# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/aliceflaviawang/aliceflaviawang.github.io.git branch: masterfeed: type: atom path: atom.xml limit: 20 hub: baidusitemap: path: baidusitemap.xmlsearch: path: search.xml field: post format: html limit: 10000 注：与gitgub pages建立关联（非常关键） 发表新文章使用hexo发表文章1$ hexo n #写文章 写完之后，推送到服务器上，执行12$ hexo g #生成$ hexo d #部署 或者hexo d -g 或者使用markdown来写文章常用命令1$ hexo new post &quot;postname&quot; #新建文章 注：如果 $ hexo d命令提示ERROR Deployer not found: git，解决办法 $ npm install hexo-deployer-git –save,然后再重新生成部署。hexo d实际上就是将博客部署到gitgub上去。hexo new post执行后会在项目source_posts中生成postname.md文件，用编辑器打开即可编辑，也可以直接在source_posts中新建一个md文件。写完之后，部署到服务器上12$ hexo g$ hexo d 打开aliceflaviawang.github.io,可以看到第一篇博客了 域名其实搭建博客不一定需要域名，当然如果你嫌github.io不够高大上，当然可以买个域名来装x.很多地方可以买域名，不只是godaddy，像腾讯云、万网…很多，我在godaddy中文网站上上买了aliceflaviawang.com这个网站，因为中文网站指引比较明确，就不详说了。 将域名与Github Pages空间绑定GitHub pages设置方法一：在Repository的根目录下面，新建一个名为CNAME的文本文件，里面写入你想要绑定的域名，比如aliceflaviawang.com方法二：点击setting，在custom domain下面天上你想要绑定的域名，点击save，会自动生成一个CNAME文件，里面保存的就是你的域名了。 DNS设置用DNSpod，我在腾讯云上注册了下，注意必须实名认证了才让你解析域名，由于我的域名已经退了，就直接使用别人的图片 添加域名，如下图设置其中A的两条记录指向的ip地址是github pages提供的地址，这个记录是云解析解析出来的结果，云解析会提示去godaddy修改dns地址。我采用的方式是自己添加，首先ping http://aliceflaviawang.github.io的地址，获得A的地址添加，然后添加www域名地址。 godaddy修改DNS点击我的账户里–&gt;点击域名–&gt;将godaddy的NameServer更改成f1g1ns1.dnspod.net和f1g1ns2.dnspod.net （域名解析后提示）。 访问博客现在就不需要访问aliceflaviawang.github.io了，可以直接访问aliceflaviawang.com注：如果访问的时候发现页面是github首页，说明需要清除一下缓存了。 后记本博客主要参考的是http://blog.sina.com.cn/s/blog_617ccc0c0101h84p.html。","categories":[],"tags":[],"keywords":[]},{"title":"我的第一篇博客","slug":"我的第一篇博客","date":"2017-04-04T13:28:41.000Z","updated":"2017-04-04T13:42:27.262Z","comments":true,"path":"2017/04/04/我的第一篇博客/","link":"","permalink":"https://aliceflaviawang.github.io/2017/04/04/我的第一篇博客/","excerpt":"","text":"感想清明节放假的最后一天，终于搭建了这个博客，心情还是比较激动的，希望以后能够通过博客这种方式记录下每天的进步！","categories":[],"tags":[],"keywords":[]}]}