{"meta":{"title":"笑呵呵","subtitle":"Live beautifully, dream passionately, love completely","description":"You Never Know Who You Can Be","author":"Alice","url":"https://aliceflaviawang.github.io"},"pages":[{"title":"about","date":"2017-04-17T13:23:23.000Z","updated":"2017-04-17T13:23:23.051Z","comments":true,"path":"about/index.html","permalink":"https://aliceflaviawang.github.io/about/index.html","excerpt":"","text":""}],"posts":[{"title":"前端面试准备","slug":"前端面试准备","date":"2017-07-03T09:03:08.000Z","updated":"2017-07-09T08:48:55.028Z","comments":true,"path":"2017/07/03/前端面试准备/","link":"","permalink":"https://aliceflaviawang.github.io/2017/07/03/前端面试准备/","excerpt":"","text":"1、cookie的优点及弊端如果步骤5携带的是过期或者错误的cookie，那么将认证失败，返回至要求身份认证页面。 优点：极高的扩展性和可用性1、通过良好的编程，控制保存在cookie中的session对象的大小2、通过加密和安全传输技术（SSL），减少cookie被破解的可能性3、只在cookie中存放不敏感数据，即使被盗也不会有重大损失4、控制cookie的生命期，使之不会永远有效。 缺点：1、cookie数量和长度的限制。每个domain最多只能有20条cookie，每个cookie长度不能超过4KB，否则会被截掉。2、安全性问题。如果cookie被拦截了，就可以获取所以的session信息。即使加密也于事无补，因为拦截者不需要知道cookie的意义，只需要原样转发cookie就行了。3、有些状态不可能保存在客户端。如：为了防止重复提交表单，在服务器端保存计数器，如果计数器放在客户端就起不了任何作用。 sessionsession是一种服务器端机制，服务器类似于散列表的结构来保存信息。当程序需要为客户端请求创建一个session时，服务器首先检查这个客户端的请求是否包含了session标志（session id），如果已包含则说明服务端曾经为用户创建过session，服务器就按照session id将session检索处理（检索不到会新建），如果不包含则会新建session并生产与之关联的session id（既不重复也不容易被找到规律仿造），找个session id将在本次响应中返回给客户端保存（保存这个session id的方式可以用cookie，另外还有两种方式：基于url path parameter默认支持的，基于SSL，默认不支持）。 cookie与session的区别 cookie有大小和个数的限制，单个cookie大小不超过4kb，很多浏览器限制一个站点最多保存20个cookie cookie保存在客户端，session保存在服务器端 cookie不是很安全，别人可以分析存放在本地的cookie并进行欺骗；因此建议将登陆等重要信息保存在服务器端，其他信息放在cookie中 session会在一定时间内保存在服务器上，当访问增多，会比较占用服务器的性能，考虑到减轻服务器的负担应当使用cookie2、浏览器的本地存储（web storage）js提供了sessionStorage和globalStorage。在HTML5中提供了localStorage取代了globalStorage。sessionStorage用于本地存储一个会话（session）中的数据，这些数据只在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁，sessionStorage不是一种持久化的本地存储。而localStorage用于持久化的本地存储，除非主动删除数据，否则数据永远不会过期。3、web storage和cookie的区别web storage与cookie类似，但是它是为更大容量存储设计的。cookie的大小受限，并且每次请求一个新的页面的时候cookie都会被发送过去，这样无形浪费了带宽，另外cookie还指定了作用域，不可以跨域调用。除此之外，web storage拥有setItem, getItem, removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie,getCookie。但是cookie也是不可或缺的：cookie的作用是与服务器交互，作为HTTP规范的一部分而存在，而web storage仅仅作为本地存储数据而生。 CSS相关问题1、display:none和visibility：hidden的区别display:none 隐藏对应的元素，不给它分配空间，周围元素会合拢visibility:hidden 隐藏对应的元素，但是在文档布局空间仍保留原来的空间 2、css中link和@import的区别1）link属于HTML标签，@import是css提供的2）页面加载时，link同时被加载，而@import页面加载完后被加载的3）link无兼容问题4）link的样式权重高于@import 3、position的absolute和fixed共同点：1、改变行内元素的呈现方式，display被设置为block2、让元素脱离普通流，不占空间3、默认会覆盖到非定位元素上不同点：absolute是相对于它最近的非static定位的祖先元素来定位的fixed是根据屏幕视窗来定位的，屏幕滚动时位置不变 4、清除浮动的三种方式首先说下浮动与绝对定位的区别。float是一种不彻底的脱离文档流的方式，绝对定位是彻底的。float脱离文档流的时候，其他盒子会无视这个元素，但其他盒子内的文本依然会为这个元素让出位置，环绕在周围；而绝对定位，其他盒子内的文本都会无视它（不会让出位置）。比如：A为绝对定位，如果A使用的绝对定位，元素B会占据B之前的位置，与元素A重合在一起，并被元素A覆盖。若A为float：left，B内的文本跑到了A的右边，即实现了文字环绕浮动元素的功，元素B的背景和元素A的背景重合了一部分，这就是浮动元素脱离了正常的文档流但还是会影响布局。清楚浮动的三种方式：12345&lt;div class=&quot;outer&quot;&gt; &lt;div class=&quot;div1&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;div2&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;div3&quot;&gt;3&lt;/div&gt;&lt;/div&gt; css样式：123456789101112131415.outer&#123;border:1 px solid #ccc;background:#fc9;color:#fff;margin:50px auto;padding:50px;&#125;.div1&#123;width:80px;height:80px;background:red;float:left;&#125;.div2&#123;width:80px;height:80px;background:blue;float:left;&#125;.div3&#123;width:80px;height:80px;background:green;float:left;&#125; 方法一：增加新元素，应用clear：both123456&lt;div class=&quot;outer&quot;&gt; &lt;div class=&quot;div1&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;div2&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;div3&quot;&gt;3&lt;/div&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;&lt;/div&gt; CSS:1.clear&#123;clear:both;&#125; 在.outer的最后加入一个空的（只要是块就行，因为只有块才可以撑满），因为它在.outer的最下面，并且不是float的，它的存在定义了.outer的高度。必须有clear：both，不然只是标准流，会紧贴在第一行的底部，不能涵盖其他div。注：clear的取值如下：none：默认值，允许两边都可以浮动left：不允许左边浮动对象right：不允许右边有浮动对象both：不允许有浮动对象清除浮动只能影响清除的元素本身，不能影响其他元素，比如，div1的右边有浮动元素div2,在div1的css样式中加入clear：right不起任何作用，只能在div2的css样式中加clear：left。要想让上述三个div垂直排列，可以增加css样式：123456.div2&#123;clear:left;&#125;.div3&#123;clear:left;&#125; 方法二：overflowfloat元素的父元素设置overflow:hidden|auto|scroll(不能使用visible)，overflow不是清除float而是新建BFC，BFC类似于编程语言里的作用域，作用域变了，float就影响不到了，只有clear可以取消float的影响。123.outer&#123;overflow:auto;&#125; 方法三：伪元素：after利用:after在元素内部插入一个元素块，从而达到清除浮动的效果，其实现原理类似于clear：both。区别在于：clear是在html插入一个div.clear标签，而outer利用其伪类:after在元素内部增加了一个类似于div.clear的效果。12345678.outer:after&#123; content:&quot;.&quot;; display:block; clear:both; visibility:hidden; height:0; width:0;&#125; 5、CSS的盒子模型：W3C盒子模型和IE盒子模型盒模型：content（内容）、padding（填充）、border（边框）、margin（边界）IE的width包含padding和border，而W3C仅包含content。 6、CSS选择符有哪些？哪些属性可以继承？优先级算法如何计算？CSS3新增的伪类？一1、id选择器 #id2、类选择器 .classname3、标签选择器 p，span4、相邻选择器 div+p5、子选择器 ul&gt;li6、后代选择器 li a7、通配符选择器 *8、属性选择器 a[rel=”external”]9、伪类选择器 a:hover, li:nth-child 二可继承的样式（大部分针对字体）：font-size,font-family,color,text-indent不可继承的样式：border，padding，margin，width，height 三CSS优先级由四个级别和四个级别出现的次数决定，四个级别分别为：行内选择符、ID选择符、类选择符、元素选择符。CSS specificity是一个四位数用来衡量优先级。如：div #id {font-size:12px;}1个div元素，specificity为0,0,0,1一个id选择符，specificity为0,1,0,0最终：specificity为0,1,0,1注意： ！important的优先级是最高的，但出现冲突时则需比较四位数 优先级相同时采取就近原则 继承得来的属性，优先级最低 specificity从左到右比较，大的优先级越高四CSS伪元素： :after匹配该元素的一个虚拟的最后子元素，配合content使用，默认为行内元素 :before匹配该元素的一个虚拟的最先子元素，与:after类似 :first-line匹配元素的第一行 :first-letter匹配元素的第一个字符 :selection匹配用户鼠标选中的部分（只应用background、color、cursor、outline属性）CSS伪类： :link未被访问的链接 :visited被访问过的链接 :hover用户鼠标移至其上方 :active被激活的元素，通常指鼠标按下到松开的那段时间 :focus元素成为焦点 :first-child元素为其父元素的第一个子元素 :last-child元素为其父元素的最后一个子元素 :nth-child(an+b)匹配为其父元素的第an+b个子元素的元素 :nth-last-child(an+b)同上但是顺序相反 :first-of-type匹配所有子元素类型第一个出现的元素 :last-of-type匹配元素中所有子元素类型最后一个出线的元素 :enabled :disabled 控制表单控件的禁用状态 ：checked 单选框或是复选框被选中注意：first-child和first-of-type的区别，first-child匹配的是其父元素的第一个子元素，而first-of-type匹配到的是该类型的第一个。举个例子：123456&lt;div&gt; &lt;p&gt;第一个子元素&lt;/p&gt; &lt;h1&gt;第二个子元素&lt;/h1&gt; &lt;span&gt;第三个子元素&lt;/span&gt; &lt;span&gt;第四个子元素&lt;/span&gt;&lt;/div&gt; p:first-child 匹配到p元素，因为p是div的第一个子元素h1:first-child 匹配不到任何元素，因为h1不是第一个子元素同理span:first-child也匹配不到p:first-of-type 匹配到p元素，因为p元素是div所有为p的子元素的第一个h1:first-of-type 匹配到h1元素，因为h1元素是div所有为h1的子元素的第一个span:first-of-type 匹配到第三个子元素span，这里div有两个为span的元素，匹配到的是第一个 7、列出display的值，说明他们的作用。position的值，relative和absolute分别是对于谁进行定位。 none 此元素不会被显示 block 此元素会显示为块级元素，前后会带有换行符 inline 此元素会被现实为内联元素，前后没有换行符 inline-block 行内块元素 list-item 此元素作为列表显示2. static 默认值，元素处于正常的文档流之中，top,right,bottom,left,z-index（设置元素的堆叠顺序）属性无效 relative 元素相对原本正常位置的定位，不改变布局，这样会在此元素原本所在的位置留下空白，对display为表格型的元素无效 absolute 不为元素预留空间，元素相对于与它最近的非static定位的祖先元素来定位。元素可以设置外边距（margin），并且不会与其他边距合并（即形成一个BFC） fixed 不为元素预留空间，相对屏幕视窗定位，屏幕滚动时位置不变 sticky （新属性，目前仅firefox实现）平时为relative，在特定条件下变为fixed，类似于实现浮动条-inherit 从父元素继承position属性的值8、对BFC规范的理解BFC，块级格式上下文，一个创建了新的BFC的盒子是独立布局的，盒子里面的子元素的样式不会影响到外面的元素。在同一个BFC中的两个毗邻的块级盒在垂直方向的margin会发生折叠。9、CSS spiriteCSS spirite把网页中的背景图片整合到一张图片文件中，再利用CSS的background-image, background-repHTML1、DOCTYPE&lt;!DOCTYPE&gt;位于html文档的第一行，它并不是一个html标签。它的作用是告诉浏览器以哪种模式来解析文档。HTML 5只有一种DOCTYPE声明，&lt;!DOCTYPE html&gt;HTML 4.01有三种：strict、transitional、frameset。2、HTML5新特性 语义化标签（header、nav、footer、aside、article、section） 拖放事件（drag类事件） 跨文档消息传递（postMessage） 媒体元素（audio、video标签） 地理位置定位（navigator、geolocation）API 历史状态管理（更新history对象，pushstate等）HTML5离线存储技术用户离线时，可以正常访问站点时，联网可以更新缓存，使用方法就是在html标签中加入manifest属性，如下：1234&lt;!DOCTYPE html&gt;&lt;html manifest=&quot;cache.manifest&quot;&gt;...&lt;/html&gt; cache.manifest文件格式如下：12345678910111213CACHE MANIFESTCACHE:js/app.jscss/style.cssNETWORK:resource/logo.pngFALLBACK:/ /offline.html 离线缓存的manifest一般由三个部分组成： CACHE:表示需要离线存储的资源列表 NETWORK:表示在它下面列出来的资源只有在有线的情况下才能访问，他们不会被离线存储 FALLBACK:(实例里’/ /‘不是注释）表示如果访问第一个资源失败，那么就使用第二个资源来替换它，比如上面这个文件表示的就是如果访问根目录下任何一个资源失败了，那么就去访问offline.html。3、iframe的优缺点优点： 重载页面时不需要重载整个页面，只需要重载页面中的一个框架页（减少了数据的传输，加快了网页下载速度 技术容易掌握，使用方便，可主要应用于不需搜索引擎来搜索的页面 方便制作导航栏缺点 最大的缺点四搜索引擎无法解读这种页面 框架结构让人迷惑 浏览器后退按钮失效（之呢个针对当前光标所在页面的前进和后退）4、如何实现浏览器多个标签页之间的通信调用localStorage、cookie等本地存储方式5、WebSocket如何兼容低浏览器WebSocket123456789101112131415161718192021//创建WebSocket实例var socket=new WebSocket(&quot;ws://licalhost:8080&quot;);//打开WebSocketsocket.onopen=function(event)&#123; //发送一个初始化消息 socket.send(&apos;I am a client and i am listening&apos;);&#125;//监听消息socket.onmessage=function(event)&#123; console.log(&apos;Client received a message&apos;); &#125;//监听关闭socket.onclose=function(event)&#123; console.log(&apos;WebSocket closed&apos;);&#125;//关闭socket//socket.close(); WebSocket是HTML5出的协议，是一个持久化的协议，相对于http这种非持久化的协议来说。WebSocket是基于http协议的，在握手阶段是一样的，不同的是http每个request接收一个response，这个response是被动的，不能主动发起。在讲WebSocket之前，先说long poll和ajax轮询。ajax轮询：让浏览器每隔几秒就发送一次请求，询问服务器是否有新消息。long pull:跟ajax轮询差不多，不过采取的是阻塞模型（不收到消息就不发response给客户端，知道有消息才返回，返回完后再次建立连接，周而复始）。这两种方式都是不断建立http连接，然后等待服务器端处理，体现了http协议的被动性。而且两种方式都非常消耗资源，ajax需要服务器有很快的处理速度和资源，long poll需要很高的并发。 WebSocket的作用WebSocket解决了http协议的被动性，服务器可以主动推送消息给客服端，只需要经过一次请求，就可以源源不断的消息传送；另外http是无状态的，每次都要传输identity info（鉴别信息）来告诉服务器你是谁，而WebSocket只需要一次握手，整个通讯过程都是建立在一次连接/状态中，避免了http的非状态性，服务器端会一直知道你的信息知道关闭请求。 如何在不支持WebSocket的客户端上使用实际上是不能，但是可以通过上面说的long poll和ajax轮询来实现类似的效果 6、null和undefined的区别nullnull表示的是一个“无”的对象，转为数值时为0典型用法： 作为函数的参数，表示该函数的参数不是对象 作为原型链的终点undefinedundefined表示的是一个“无”的原始值，转为数值是NaN典型用法： 变量被声明了，但是没有赋值时，就等于underfined 调用函数时，应该提供的参数没有提供，该参数等于undefined 对象没有赋值的属性，该属性的值为undefined 函数没有返回值时，默认返回undefined7、new操作符具体干了什么1234var Fun=function()&#123; &#125;var func=new Func();&#125; new共经历了四个阶段： 创建一个空对象1var obj=new Object(); 2、设置原型链1obj._proto_=Func.prototype;(继承构造函数的属性和方法) 3、让Func中的this指向obj，并执行Func函数体1var result=Func.call(obj); 8、跨域问题同源策略在讲跨域问题之前先说同源策略。一个url由协议、域名、端口和路径组成，如果两个url协议、域名、端口相同，则表示它们同源。浏览器的同源策略是指一个域上加载的脚本不允许访问另一个域的文档属性。 跨域方法1、跨域资源共享（CORS)创建CORS请求对象因为CORS是属于XMLHttpRequest2的一部分，所以主要要做的就是区分IE8/9和不支持XMLHttpRequest的浏览器1234567891011121314151617181920212223function createCoresRequest(method,url)&#123; var xhr=new XMLHttpRequest(); if(&apos;withCredentials&apos; in xhr)&#123; //支持CORS //检查XMLHttpRequest对象是否有&quot;withCredentials&quot;属性，withCredentials仅存在xmlHttpRequest对象里 xhr.open(method,url,true); &#125; else if(window.XDomainRequest)&#123; //XDomainRequest仅存在IE中，是IE用于支持CORS请求的方式 xhr=new C=XDomainRequest(); xhr.open(method,true); &#125; else&#123; //不支持CORS xhr=null; &#125; return xhr; &#125; var xhr=createCORSRequest(&quot;GET&quot;,url); if(!xhr)&#123; throw new Error(&apos;CORS not supported&apos;); &#125; xhr.send();//发送请求 CORS是W3C提出的跨域请求方案，需要服务器端的支持。服务器端对CORS的支持主要通过设置HTTP头Access-Control-Allow-Origin实现，如果浏览器检测到相应的设置，就能允许AJAX跨域请求。 2、通过jsonp跨域JSONP也叫填充式json，是应用json的新方法，只不过是包含在函数中调用json，例如：1callback(&#123;&quot;name&quot;,&quot;jack&quot;&#125;) JSONP由两部分组成：回调函数和数据。回调函数是当响应到来时在页面中调用的函数，数据是传入回调函数的json数据。在js中直接通过xmlHttpRequest请求不同域上的数据时，是不行的，但是，在页面上引入不同域的js脚本文件却是可以的，jsonp正是利用这个特性来实现的。123456&lt;script type=&quot;test/javascript&quot;&gt; function dosomething(jsondata)&#123; //处理json数据 &#125;&lt;/script&gt;&lt;script src=&quot;http://example.data/data.php?callback=dosomething&quot;&gt;&lt;/script&gt; js文件载入成功后会执行url中指定的函数，并把需要的json数据作为参数传入该函数。如果页面使用的是jquery，那么通过它封装的方法就能很方便的来进行JSONP操作。12345&lt;script type=&quot;text/javascript&quot;&gt; $.getJSON(&quot;http://example.data/data.php?callback=?,function(jsondata)&quot;)&#123; //处理获得json数据 &#125;）&lt;/script&gt; jQuery会自动生成一个全局函数来替换callback=？中的？，之后获取的数据又会自动销毁，实际上就是起一个临时代理函数的作用。$.getJSON方法会自动判断是否跨域，如果不跨域，就用普通的ajax方法，跨域的话，就会异步加载js文件的形式来调用jsonp的回调函数。 JSOPN的优缺点 优点：不像XMLHttpRequest对象实现得Ajax请求那样受到同源策略的限制，它的兼容性更好，不需要XMLHttpRequest或ActiveX的支持，并且在请求完毕后可以通过调用callback方式回传结果。 缺点：它支持GET请求而不支持POST等其他类型的HTTP请求，它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行javascript调用的问题。CORS和JSONP的对比 JSONP只支持GET类型的http请求，CORS支持所有类型的http请求 CORS，开发者可以使用普通的XMLHttpRequest发起请求和获取数据，有更好的错误处理 JSONP主要被老的浏览器支持，它们往往不支持CORS，对大多数现代浏览器都已经支持CORS了3、通过修改document.domain来跨域（iframe）浏览器的同源策略的两个限制：一、不能通过ajax方法去请求不同源的文档；二、浏览器中不同框架是不能进行js交互操作的。比如：有一个页面，它的地址是”http://www.example.com/a.html&quot;，这个页面里有个iframe，它的iframe的src是&quot;http://example.com/a.html&quot;，很显然这个页面与它的iframe框架是不同域的，所以无法通过js代码来获取iframe的东西。此时document.domain就排上用场了，但是document.domain的设置有限制，只能将其设置成自身或者父域，且主域必须相同。 “http://www.example.com/a.html&quot;页面设置document.domain 1234567&lt;iframe id=&quot;iframe&quot; src=&quot;http://example.com/a.html&quot; onload=&quot;test()&quot;&gt;&lt;/iframe&gt;&lt;script type=&quot;text/javascript&quot;&gt; document.domain=&quot;example.com&quot;;//设置成主域 funtion test()&#123; alert(document.getElementById(&quot;#ifrme&quot;).contentWindow);//可取得子窗口的window对象 &#125;&lt;/script&gt; “http://example.com/a.html&quot;设置document.domain 1234&lt;script type=&quot;text/javascript&quot;&gt; document.domain=&quot;example.com&quot;;//设置成主域&lt;/script&gt; 注：document.domain只适用于不同子域的框架中。 4、window.name在一个窗口的生命周期内，不同url共享同一个window.name，每个页面对window.name都有读写权限，且window.name持久存在一个窗口在载入过的所有页面中。 5、HTML5的window.postMessage方法HTML5的新特性，不能实现与服务器交换数据，只能在不同的iframe中使用。window.postMessage(message,targetOrigin). 9、document.write和innerHTML的区别document.write是直接写入页面的文档流，如果写之前没有调用document.open，浏览器会自动调用open，每次写完之后重新调用该函数，会导致整个页面的重绘。innerHTML能精确到某个具体的元素来更改，只对页面的部分重绘。 10、内存泄露内存泄漏：是指任何对象不再拥有或需要它之后仍然存在。javascript有自动垃圾回收机制，一旦数据不再使用，可以将其设为null来释放引用。造成内存泄漏的集中操作： 循环引用一个DOM对象被一个javascript对象引用，与此同时又引用同一个或其他的javascript对象，这个DOM对象可能会引发内存泄露。这个DOM对象的引用将不会在脚本停止的时候被垃圾回收器回收。要想破坏引用，引用DOM元素的随想或DOM对象的引用需要被赋值为null。 闭包在闭包中引入闭包外部的变量时，当闭包结束时此对象无法被垃圾回收。 123456var a=function()&#123; var largeStr=new Array(1000000).join(&quot;x&quot;); return function()&#123; return largeStr; &#125;&#125;(); DOM泄露父节点被删除时，子节点引用没有被移除则无法回收。 123456789101112131415var select=document.querySelector;var treeRef=select(&quot;#tree&quot;);var leaf=select(&quot;#leaf&quot;);//#leaf是#tree的子节点var body=select(&quot;body&quot;);body.removeChild(treeleaf);//#tree不能被回收，因为treeLeaf还在//解决方案treeRef=null;//tree不能被回收，一位内叶子leaf还在leaf=null;//现在#tree被释放了 4、Timer定时器泄露定时器也是常见的产生泄露的地方12345678910111213for(var i=0;i&lt;90000;i++)&#123; var b=&#123; callAgain:function()&#123; var ref=this; var val=setTimeout(function()&#123; ref.callAgain(); &#125;,90000); &#125; &#125;b.callAgain();//虽然很想收回但是timer还在b=null;&#125; 11、作用域链作用域链、闭包、原型链是javascript中比较重要的知识点。 javascript中的作用域每一种语言都有作用域的概念，所谓作用域就是变量和函数的可用范围，确定了变量和函数的可见性和生命周期。javascript中有两种作用域，全局作用域和局部作用域。 全局作用域以下情况一般拥有全局作用域 全局声明的函数和变量 没有定义直接赋值的变量 所以window属性局部作用域在函数内部声明的函数和变量只能在函数内部访问到，即拥有局部作用域。作用域链javascript中，一切都是对象，包括函数。而函数有一个内部属性[[scope]]，里面包含了函数的可访问的作用域对象的集合，这个集合被称为作用域链。作用域链的创建作用域链在函数执行时创建。作用域的前端，始终是当前环境的变量对象。如果这个环境是函数，则将其活动对象作为变量对象，里面包含了该函数的所有局部变量、参数及this。把作用域链当成一个对象数组，先把该函数的变量对象push进数组，然后把函数的外部环境的作用域push进数组，下一个就是外部环境的外部环境的变量对象，一直往外直到全局环境，即作用域链的最后一个对象肯定是全局环境的作用域。作用域链的作用作用域链的目的是保证当前环境对可访问的变量和函数的有序访问。具体实现是：函数内部标识符解析时会沿着作用域链一级一级地搜索。搜索的过程始终从作用域链前端开始，直到最后一个对象即全局变量对象为止，如果找不到的话，就是undefined。这样可以保证内部变量的优先级始终大于外部变量。变量提升的问题1234567var name=&quot;123&quot;;function foo()&#123; console.log(name); //undefined var name=&quot;456&quot;; console.log(name); //456&#125;foo(); 以上例子，按常规连接，应该先输出全局变量“123”，再输出局部变量“456”，然而第一个却输出了undefined，为什么呢？因为函数在执行时首先胡创建作用域链，这是在整个函数执行之前就完成的，所以第一次输出时，该函数的变量对象已经包含了name这个变量，从而导致解析时在作用域链第一个对象就停止，，而不会访问到全局变量，同时那个时候局部变量没有赋值，所以会输出undefined。这种现象叫做变量提升。注：ES6中通过let标识符可以防止这种现象的出现 作用域链的延长部分语句可以在作用域链的前端临时增加一个变量对象，该变量对象会在代码执行后移除。主要由两种情况 with语句 try-catch语句with语句平时优化需要可以把所需对象存储在局部变量中，不推荐使用with语句，可能造成bug和性能损失。12345678function foo()&#123; var he=&quot;?name=1&quot;; with(location)&#123; var url=href+he; &#125; return url;&#125;foo(); 这里with语句把location对象添加到作用域链前端，因此在访问href时，其实是访问了location.href。在with语句执行完毕后，作用域链就返回之前的状态。 catch块12345try&#123; something();&#125;catch(e)&#123; console.log(e);&#125; 当try代码块中的语句发生错误时，执行块跳转到catch语句块，并且把一个异常对象添加到作用域的头部。在catch语句执行完毕后，作用域链就返回之前的状态。注：可以把错误处理委托给一个函数。这样的话就只执行一条语句，并且没有访问局部变量，对性能影响就比较小。12345try&#123; something();&#125;catch(e)&#123; handleError(e);&#125; 12、闭包闭包的特性 函数嵌套函数 内部的函数可以引用函数外部的参数和变量 参数和变量不能被垃圾回收机制回收闭包的定义及其优缺点闭包：是指有权访问另一个函数作用域中的变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量。闭包的缺点：常驻内存，会增加大量的内存使用，使用不当会造成内存泄漏。闭包的应用：一是前面提到的读取函数内部的变量，二是让这些变量的值始终保持在内存中。看个例子：1234567891011121314function f1()&#123; var n=999; add=function()&#123; n+=1; &#125; function f2()&#123; alert(n); &#125; return f2;&#125;var result=f1();result();//999add();result(); result实际上就是闭包f2函数，它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。为什么会这样呢？因为f1是f2的复函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制回收。另外要注意add，首先add前面没有使用var关键字，因此add是一个全局变量，而不是局部变量。其次add的值是一个匿名函数，而这个匿名函数本身也是一个闭包，所以add相当于一个setter，可以在函数外部对函数内部的局部变量进行操作。 闭包使用注意点 由于闭包会使得函数中的变量都保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页性能问题，IE中可能导致内存泄漏。解决办法是，在退出函数之前，将不适用的局部变量全部删除。 闭包会在父函数外部，改变父函数内部变量的值。如果把父函数当作对象使用，把闭包当作它的公用方法，把内部变量当作它的私有属性，这是一定要小心，不要随便改变父函数内部变量的值。13、javascript中的this一般而言，javascript中this指向函数执行时的当前对象。换句话说，这个关键字与函数的执行环境有关，与声明环境无关。所以this的指向要看如何去调用这个函数而不是声明。不同的调用方式1、作为对象的方法调用把函数赋值给对象的一个属性，然后通过该对象调用该方法，此时函数的执行环境就是这个对象，所以this指向该对象。12345678var name=&quot;haha&quot;;var obj=&#123; name:&quot;hehe&quot;, show:function()&#123; console.log(this.name); &#125;&#125;obj.show(); //hehe 换种更清晰的方式，我们把声明和调用放在两个对象里面1234567891011var obj=&#123; name:&quot;hehe&quot;, show:function()&#123; console.log(this.name) &#125;&#125;var t_obj=&#123; name:&quot;lala&quot;, show:obj_show&#125;t_obj.show(); //lala 可以看到show虽然在obj中声明过，但是通过t_obj调用了这个方法，所以此时this指向t_obj。 2、作为函数调用我们将上面的代码改一下，将obj.show赋值给全局变量show再调用，此时this绑定到全局对象。123456789var name=&quot;lala&quot;;var obj=&#123; name:&quot;hehe&quot;, show:function()&#123; console.log(this.name); &#125;&#125;var show=obj.show;show(); //lala 3、独立函数调用在函数内部调用一个函数，比如在一个对象的方法里面调用一个函数时，this会指向全局对象(讲道理的话应该指向对象），实际上是不带任何修饰的函数引用进行调用时，默认this指向全局变量。这是javascript设计比较坑的地方，平时经常使用命名一个新变量ctx(context，即上下文环境)替代this。1234567891011var name=&quot;lala&quot;;var obj=&#123; name:&quot;hehe&quot;, show:function()&#123; var test=function()&#123; console.log(this.name); &#125; test(); &#125;&#125;obj.show(); //lala 修正版12345678910111213var name=&quot;lala&quot;;var obj=&#123; name:&quot;hehe&quot;, show:function()&#123; var txt=this; console.log(this);//obj var test=function()&#123; console.log(this.name); &#125; test(); &#125;&#125;obj.show(); // hehe 再看一个例子123456789var name=&quot;lala&quot;;function b()&#123; var name=&quot;hehe&quot; function a()&#123; console.log(this.name); &#125; a();&#125;b(); //lala 修改1234567891011var name=&quot;lala&quot;;function b()&#123; var cxt=this; console.log(this);//window var name=&quot;hehe&quot; function a()&#123; console.log(ctx.name); &#125; a();&#125;b(); //lala 可以看到对比上一个例子，obj.show中的this指向obj，而第二个例子由于b是独立函数，b中的this指向全局对象，有一个误区认为this指向执行的函数，实际上不是的。 4、作为构造函数使用我们常使用new构造函数名()来创建一个对象，此时函数中的this指向新创建的对象。如果不使用new，则和普通函数一样绑定到全局对象。12345function Foo()&#123; console.log(this);&#125;var test=new Foo(); //testFoo(); //window 5、在setTimeout、setInterval和匿名函数中在setTimeout,setInterval和匿名执行时的对象为全局对象，所以this也指向全局对象。12345678910var name=&quot;lala&quot;;var obj=&#123; name:&quot;hehe&quot;, show:function()&#123; setTimeout(function()&#123; console.log(this.name); &#125;,500); &#125; &#125;obj.show(); 6、函数调用call和apply方法时两者的本质就是改变函数当前的上下文环境即this，两者的区别是call接收一个个参数，而apply接受一个参数数组。注：使用call和apply函数的时候要主要，如果传递的this值不是一个对象，javascript将会尝试使用内部ToObject操作将其转换为对象。因此，如果传递的值，如果传递的值是一个原始值比如7或者”foo”，那么就会使用相关构造函数将它转换为对象，所以原始值7通过new Number(7)被转换为对象，而字符串”foo”使用new String(“foo”)转化为对象。 7、函数调用bind方法时函数调用bind方法时会创建一个有相同函数体和作用域的函数，新函数的this指向bind的第一个参数。该方法不会调用函数，而是返回新函数。 14、prototype和原型链每个函数都有一个prototype属性，这个属性是指向一个对象的引用，这个对象称为原型对象，原型对象包含函数实例共享的方法和属性，也就是说将函数用作构造函数调用的时候，新创建的对象会从原型对象上继承属性和方法。不像传统的面向对象语言，javascript的继承机制基于原型，而不是class类。 1、javascript的设计意图 私有变量、函数javascript的作用域链，在函数内定义的变量和函数如果不对外提供接口，外部将无法访问到，也就是变为私有变量和私有函数。 12345678function Obj()&#123; var a=0; //私有变量 var fn=function()&#123; //私有函数 &#125;&#125;var o=new Obj();console.log(o.a) //undefinedconsole.log(o.fn) //undefined 静态变量、函数当定义一个函数后，通过“.”为其添加属性和函数，通过对象本身仍然可以访问得到，但是其实例访问不到，这样的变量和函数分别被称为静态变量和静态函数。 12345678910function Obj()&#123;&#125; Obj.a=0; //静态变量 Obj.fn=function()&#123; //静态函数 &#125;console.log(Obj.a) //0console.log(Obj.fn) //function()&#123; //静态函数 &#125;var o=new Obj();console.log(o.a) //undefinedconsole.log(o.fn) //undefined 实例变量、函数在面向对象编程中除了一些库函数我们还希望在对象定义的时候同时定义一些属性和方法，实例化后可以访问，javascript也可以做到这样。 1234567891011function Obj()&#123; this.a=[]; //实例变量 this.fn=function()&#123; //实例函数 &#125; &#125;console.log(typeof Obj.a) //undefinedconsole.log(typeof Obj.fn) //undefinedvar o=new Obj();console.log(typeof o.a) //objectconsole.log(typeof o.fn) //function 这样可以达到目的，然而12345678910111213function Obj()&#123; this.a=[];//实例变量 this.fn=function()&#123; //实例方法 &#125;&#125;var o1=new Obj();o1.a.push(1);o1.fn=&#123;&#125;; console.log(o1.a); //[1]console.log(typeof o1.fn); //objectvar o2=new Obj();console.log(o2.a); //[]console.log(typeof o2.fn) //function 虽然可以实例访问了，但是在o1中修改了a和fn，在o2中没有改变，由于数组和函数都是对象，是引用类型，这说明o1和o2中的属性和方法虽然同名但不是一个引用，而是对Obj对象定义的属性和方法的一个复制。这对属性来说没什么问题，但是对方法来说，因为方法都是在做完全一样的功能，但是却有两份复制，如果一个函数对象有上千个实例方法，每个实例都要保持一份上千个方法的复制，这显然不科学，因此prototype应运而生。原型对象的主要目的是让所有对象实例共享它所包含的属性和方法。 2、prototype原型在javascript中，所有都是对象。但对象是有区别的，分为普通对象和函数对象。凡是通过new Funtion()的方式创建的对象都是函数对象，其他都是普通对象。每个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。prototype就是调用构造函数而创建的那个对象实例的原型对象。普通对象没有prototype，但是有proto属性。原型对象其实就是普通对象（Funtion.prototype除外，它是函数对象，但它很特殊，它没有prototype属性（前面说函数对象都有prototype属性））。举个例子：123456function f1()&#123;&#125;;console.log(f1.prototype) //f1&#123;&#125;console.log(typeof f1.prototype) //objectconsole.log(typeof Function.prototype) // function，这个特殊console.log(typeof Object.prototype) // objectconsole.log(typeof Function.prototype.prototype) //undefined 从console.log(f1.prototype)//f1{}看出，f1.prototype就是f1的实例对象。就是f1创建的时候，创建了一个实例对象并赋值给它的prototype，过程如下：12var temp=new f1();f1.prototype=temp; 所以Function.prototype为什么时函数对象就迎刃而解，上文提到凡是new Function产生的对象都是函数对象，所以temp1是函数对象：12var temp1=new Function();Function.prototype=temp1; 那原型对象是用来做什么呢？主要是用来继承，举个例子：12345678var person=function(name)&#123; this.name=name;&#125;person.prototype.getName=function()&#123; return this.name;//this指向源性对象&#125;var xpg=new Person(&quot;alice&quot;)xpg.getName() //alice 从这里看出，person.prototype设置了一个函数对象的属性，那由person实例出来的对象就继承了这个属性。具体继承机制看原型链。无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性（同时它也是一个对象），默认情况下prototype属性会默认获得一个constructor（构造函数）属性，这个属性是一个指向prototype属性所在函数的指针。12function Person()&#123; &#125; 可以看到Person对象会自动获得prototype属性，而prototype也是一个对象，会自动获得constructor属性，该属性正是指向Person对象。当调用构造函数创建一个实例的时候，实例内部将包含一个内部指针（proto）指向构造函数的prototype，这个连接存在于实例和构造函数的prototype之间，而不是实例与构造函数之间。12345678function Person(name)&#123; this.name=name;&#125;Person.prototype.printName=function()&#123; alert(this.name)&#125;var person1=new Person(&quot;Byron&quot;)var person2=new Person(&quot;Frank&quot;) Person的实例person1中包含了name属性，同时自动生成一个proto属性，该属性指向Person的prototype，可以访问到prototype内定义的printName方法： 3、原型链由于proto是任何对象都有的属性，而js里万物皆对象，所以会形成一条proto连起来的链。代码读取某个对象的属性的时候，都会执行一遍搜索，目标是具有给定名字的属性，搜索首先从对象实例开始，如果实例中找到该属性则返回，如果没有则查找prototype，如果还没有找到则继续递归prototype的prototype对象，直到找到为止，如果递归到object仍然没有怎返回错误。同理如果在实例中定义prototype同名的属性或函数，则会覆盖prototype的属性或函数。这就是javascript的原型链。12345var A = function()&#123;&#125;;var a = new A();console.log(a.__proto__); //A &#123;&#125;（即构造器function A 的原型对象）console.log(a.__proto__.__proto__); //Object &#123;&#125;（即构造器function Object 的原型对象）console.log(a.__proto__.__proto__.__proto__); //null 4、hasOwnProperty与in操作符in操作符是只要能访问到该属性就返回true，hasOwnProperty只有属性存在于实例中时才返回true。123456Object.prototype.bar=1var foo=&#123;moo:2&#125;for(var i in foo)&#123;if(foo.hasOwnProperty(i)) console.log(i) //输出两个属性： moo和bar&#125; 我们没有办法改变for in语句的行为，所以想过滤结果就只能使用hasOwnProperty方法，代码如下：1234for(var i in foo)&#123; if(foo.hasOwnProperty(i)) console.log(i) // moo&#125; 总结prototype指向该方法的原型对象，只有函数对象有prototypeproto是指向该对象的构造函数的原型对象，所有对象都有proto，proto是普通对象的隐式属性，在new的时候会指向该对象的构造函数的原型对象1234function F()&#123;&#125;var f=new F();f.__proto__==F.prototype //true 构造函数.prototype=原型对象原型对象.constructor=构造函数实例.proto=构造函数.prototypeisPrototypeof(实例对象)判断实例对象的原型是不是当前对象。","categories":[],"tags":[],"keywords":[]},{"title":"原生JavaScript实现Ajax","slug":"原生JavaScript实现Ajax","date":"2017-06-25T12:21:18.000Z","updated":"2017-06-25T13:45:11.070Z","comments":true,"path":"2017/06/25/原生JavaScript实现Ajax/","link":"","permalink":"https://aliceflaviawang.github.io/2017/06/25/原生JavaScript实现Ajax/","excerpt":"","text":"Ajax实现步骤： 创建XMLHttpRequest对象XMLHttpRequest用于在后台与服务器交换数据，可以在不重新加载整个网页的情况下，对网页的部分进行更新。12345var XHR=if(window.XMLHttpRequest)&#123; XHR=new XMLHttpRequest();&#125;else if(window.ActiveXObject)&#123;//IE6 XHR=new ActiveXobject(&apos;Microsoft.XMLHTTP&apos;);&#125; 注：ActiveXObject对象在IE11中已移除。 想服务器发送请求首先调用open方法，有五个参数（常用的前三个）： method:必须提供，用来指定发送请求的HTTP方法（GET, POST等） uri：请求的url，会被自动解析成绝对地址 async:请求是否是异步的，默认是true username, password:如果需要服务器验证用户，则设置username和password这两个参数。然后调用send方法，按照open方法设定的参数将请求进去发送123456789101112131415if(type==&apos;GET&apos;)&#123; //拼接GET方法的URL if(typeof(data)!=&apos;undefined&apos;)&#123; url+=&apos;?&apos;; for(i in data)&#123; url+=i+&apos;=&apos;+data[i]+&apos;&amp;&apos;; &#125; url=url.substring(0,url.length-1); //去掉最后一个&apos;&amp;&apos; &#125; XHR.open(type,url,true); XHR.send(null);&#125;else if(type==&apos;POST&apos;)&#123; XHR.open(type,url,true); XHR.send(data);&#125; 注：理论上GET方法也有body，但一般约定GET的参数都放在URL上，所以type为GET时，send的参数一般是null. 服务器响应在讲响应之前，先介绍一下readyState属性，readyState标识了当前对象正处于什么状态。另外介绍一下status属性，status属性描述了HTTP状态代码，一下常用的状态码：123456789XHR.onreadystatechange=function()&#123;//readyState的值发生改变时就会触发onreadystatechange if(readystate==4)&#123; if(XHR.status&gt;=200&amp;&amp;XHR.status&lt;300||XHR.status==304)&#123; //请求成功 &#125;else&#123; //请求失败 &#125; &#125;&#125; 注： status仅当readyState的状态是3或者4的时候才可用 send()方法必须在readyState的属性值是1，即调用open()方法以后才能调用","categories":[],"tags":[],"keywords":[]},{"title":"jQuery $.proxy()方法","slug":"jQuery-proxy-方法","date":"2017-06-24T14:01:36.000Z","updated":"2017-06-24T14:30:06.774Z","comments":true,"path":"2017/06/24/jQuery-proxy-方法/","link":"","permalink":"https://aliceflaviawang.github.io/2017/06/24/jQuery-proxy-方法/","excerpt":"","text":"定义$.proxy方法接收一个已有的函数，并返回一个带特定上下文的新的函数。该方法通常用于向上下文只想不同对象的元素添加事件。 语法11$(selector).proxy(function,context) //function：要被调用的已有函数，context:函数所在对象的名称 举个例子：12345678910&lt;div&gt;div元素&lt;/div&gt;&lt;script&gt; test=function()&#123; this.text=&quot;这是一个对象属性&quot;; $(&quot;div&quot;).click(this.myClick); &#125; test.prototype.myClick=function()&#123; alert(this.text); &#125;&lt;/script&gt; 点击“div元素”，弹出undefined。这是因为执行$(“div”).click(this.myClick)后的this与test()中的this不是同一个。而使用$.proxy()可以将$(“div”).click(this.myClick)执行的this绑定到test的上下文环境中：12345678910&lt;div&gt;div元素&lt;/div&gt;&lt;script&gt; test=function()&#123; this.text=&quot;这是一个对象属性&quot;; $(&quot;div&quot;).click($.proxy(this.myClick),this); &#125; test.prototype.myClick=function()&#123; alert(this.text); &#125;&lt;/script&gt; 点击“div元素”，弹出的是“这是一个对象属性”。 语法21$(selector).proxy(context,name) //name:已有的函数，其上下文将被改变（应该是context对象的属性） 举个例子：123456789101112&lt;button&gt;执行test函数&lt;/button&gt;&lt;p&gt;&lt;/p&gt;&lt;script&gt; var objPerson=&#123; name:&quot;John&quot;, age:32, test:function()&#123; $(&quot;p&quot;).after(&quot;Name:&quot;+this.name+&quot;&lt;br&gt;Age:&quot;+this.age); &#125; &#125;$(&quot;button&quot;).click(objPerson.test.call(this));&lt;/script&gt; 点击button按钮，出现Name:undefined Age:undefined，因为test的上下文环境和objPerson的上下文环境不一样，test里面没有定义name和age对象。可以通过$.proxy()绑定test的上下文环境。123456789101112&lt;button&gt;执行test函数&lt;/button&gt;&lt;p&gt;&lt;/p&gt;&lt;script&gt; var objPerson=&#123; name:&quot;John&quot;, age:32, test:function()&#123; $(&quot;p&quot;).after(&quot;Name:&quot;+this.name+&quot;&lt;br&gt;Age:&quot;+this.age); &#125; &#125;$(&quot;button&quot;).click($.proxy(objPerson,&quot;test&quot;));&lt;/script&gt; 点击button按钮，出现Name:John Age:32。当然之前分析call函数时，也提到过call()也可以绑定上下文环境，实现与上面同样的效果：123456789101112&lt;button&gt;执行test函数&lt;/button&gt;&lt;p&gt;&lt;/p&gt;&lt;script&gt; var objPerson=&#123; name:&quot;John&quot;, age:32, test:function()&#123; $(&quot;p&quot;).after(&quot;Name:&quot;+this.name+&quot;&lt;br&gt;Age:&quot;+this.age); &#125; &#125;$(&quot;button&quot;).click(objPerson.test.call(objPerson));//将test()环境绑定到objPerson环境中&lt;/script&gt;","categories":[],"tags":[],"keywords":[]},{"title":"bind(), delegate(), on()方法区别","slug":"bind-delegate-on-方法区别","date":"2017-06-23T08:51:44.000Z","updated":"2017-06-23T09:12:23.824Z","comments":true,"path":"2017/06/23/bind-delegate-on-方法区别/","link":"","permalink":"https://aliceflaviawang.github.io/2017/06/23/bind-delegate-on-方法区别/","excerpt":"","text":"bind()：$(selector).bind(event,data,function)123$(&quot;div p&quot;).bind(&quot;click&quot;,function()&#123; &#125;) 使用bind()方法为所有div里的p元素都绑定了click事件，存在的问题：1）这里使用了隐式迭代，如果匹配到的元素特别多，影响了性能；2）对于尚未存在的元素，无法绑定。动态添加的p元素，点击会没有响应。顺便提一下，bind()的简写方式：123$(&quot;div p&quot;).click(function()&#123;&#125;) delegate():$(selector).delegate(childSelector,event,data,function)123$(&quot;div&quot;）.delegate(&quot;p&quot;,&quot;click&quot;,function()&#123; &#125;) 事件委托方式，不直接为p元素绑定事件，而是为其父元素（或祖先元素）绑定事件，当在div内任意元素点击时，事件会一层层从event.target向上冒泡，直到达到为其绑定事件的元素，如此例中的div元素。冒泡的过程中，如果事件的currentTarget与选择器匹配时就会执行代码。delegate()方法解决了bind具有的两个问题，但是如果事件目标在DOM树很深的位置，这样一层层来查找与选择器匹配的元素，又影响了性能。 on():$(selector).on(event,childselector,data,function)12$(&quot;div&quot;).on(&quot;click&quot;,&quot;p&quot;,function()&#123;&#125;) 看jQuery源代码发现，无论是bind()还是delegate()，都是通过on()方法实现的，只是参数不同。12345678910111213bind: function( types, data, fn ) &#123; return this.on( types, null, data, fn ); &#125;, unbind: function( types, fn ) &#123; return this.off( types, null, fn ); &#125;, delegate: function( selector, types, data, fn ) &#123; return this.on( types, selector, data, fn ); &#125; undelegate: function( selector, types, fn ) &#123; // ( namespace ) or ( selector, types [, fn] ) return arguments.length === 1 ? this.off( selector, &quot;**&quot; ) : this.off( types, selector || &quot;**&quot;, fn ); &#125; 总结1、选择器匹配元素较多时，不要使用bind()迭代绑定2、id选择器时，可以用bind()3、需要动态绑定时，用delegate()或on()4、用delegate()或on()，DOM树不要太深5、尽量使用on()","categories":[],"tags":[],"keywords":[]},{"title":"jQuery性能优化","slug":"jQuery性能优化","date":"2017-06-23T02:14:53.000Z","updated":"2017-06-23T08:48:32.480Z","comments":true,"path":"2017/06/23/jQuery性能优化/","link":"","permalink":"https://aliceflaviawang.github.io/2017/06/23/jQuery性能优化/","excerpt":"","text":"1、使用最新版本的jQuery类库jQuery每个新版本都会较上个版本进行bug修复和优化，同时进行一些创新。 2、使用合适的选择器jQuery提供了丰富的选择器来定位DOM元素，下面介绍几种常用的选择器及它们之间的性能差异： $(“#id”)使用id来定位DOM元素是最佳提高性能的方式，因为jQuery底层将直接调用本地方法document.getElementById()。如果不能直接找到，还可以考虑调用find()方法：1$(&quot;#content&quot;).find(&quot;div&quot;); 使用以上方法可以有效缩小定位DOM元素的范围，为了提高性能，可以从最近的ID元素开始往下搜索。 $(“p”),$(“div”),$(“input”)标签选择器是性能优化的第二选择，因为jQuery将直接调用本地方法document.getElementByTagName()来定位DOM元素。 $(“.class”)对于较新的浏览器，支持本地方法document.getElementByClassName(),老的浏览器如IE8及更早版本只能靠使用DOM搜索方式来实现，这无疑对性能产生较大的影响。所以有选择性的使用它。 $(“[attribute=value]”)利用属性定位DOM元素，本地JavaScript方法并没有直接实现，大多是使用DOM搜索方式来达到效果，很多现代浏览器支持querySelectAll()方法，但是浏览器之间还是有区别。 $(“:hidden”)和上面利用属性定位DOM方式类似，这种伪选择器也没有直接在本地JavaScript实现，并且jQuery需要搜索每一个元素来定位这个选择器，这对性能影响较大。如果一定要用这种方式，建议先用id定位父元素再使用该选择器，这样有助于优化性能。1$(&quot;#content&quot;).find(&quot;:hidden&quot;); 以上是使用选择器的基本规则，性能自上而下依次下降。 3、缓存对象开发人员经常喜欢这样写：12$(&quot;#traffic input.on&quot;).bind(&quot;click&quot;,function&#123;&#125;);$(&quot;#traffic&quot;).css(&quot;border&quot;,&quot;1px solid red&quot;)) 这样写导致的结果是jQuery会在每个选择器创建的过程中，查找DOM，创建多个jQuery对象。比较好的方式：123var $traffic=$(&quot;#traffic&quot;);$traffic.bind(&quot;click&quot;,function()&#123;&#125;).css(&quot;border&quot;,&quot;1px solid red&quot;) //使用链式结构让代码更简洁 如果希望在其他函数中使用jQuery对象，可以把它缓存放全局环境中。1234567891011//在全局范围内定义一个对象（例如window对象）window.$my=&#123; head:$(&quot;head&quot;), traffic:$(&quot;#traffic&quot;), &#125;function do()&#123; var script=document.createElement(&quot;script&quot;); $my.head.append(script); //现在可以引用存储的结果并操作它们 $my.coll=$(&quot;#ul li&quot;);//在函数内部操作时，可以继续将查询存入全局对象中 $my.coll.css(&quot;border-color&quot;,&quot;red&quot;); //将全局函数作为一个普通的jquery对象使用 &#125; 4、循环时的DOM操作使用for,while,$.each处理节点时，要注意：12345var top=[];//假设是100个字符串var list=$(&quot;#list&quot;);for(var i=0;i&lt;top.length;i++)&#123; list.append(&quot;&lt;li&gt;&quot;+top[i]+&quot;&lt;/li&gt;&quot;); &#125; 以上每添加一个新的标签元素都作为一个节点添加容器ID中，循环了100次，消耗较大。应该将整个元素字符串在插入DOM中全部创建好：1234567var top=[];//假设是100个字符串var list=$(&quot;#list&quot;);var mylist=&quot;&quot;;//暂存列表元素for(var i=0;i&lt;top.length;i++)&#123; mylist+=&quot;&lt;li&gt;&quot;+top[i]+&quot;&lt;/li&gt;&quot;; &#125;list.append(mylist); 非常类似与DOM操作中用createElementFragment一次性添加全部DOM节点，再一次性更新DOM：1234567var fragment=document.createElementFragment();for(var i=0;i&lt;items.length;i++)&#123; var item=document.createElement(&quot;li&quot;); item.append(document.createTextNode(&quot;option&quot;+i); fragment.appendChild(item); &#125;list.appendChild(fragment); 5、数组方式使用jQuery对象使用for或者while循环而不是$.each()能使代码更快。 6、事件代理每个javascript事件都会冒泡到父级节点。当需要给多个元素同个函数时，事件代理会很有用。123$(&quot;#table td&quot;).click(function()&#123; $(this).css(&apos;background&apos;,&apos;red&apos;) &#125;) 假设有100个td元素，使用上述方法，将会绑定100个事件，对性能影响很大。代替这种多元素事件监听的方法是，只需要向他们的父节点绑定一次事件，然后通过event.target获取到点击的当前元素：123$(&quot;#table&quot;).click(function(event)&#123; $(event.target).css(&apos;background&apos;,&apos;red&apos;); //event.target捕捉触发的目标元素 &#125;) 改进的方式中，只为一个元素绑定了1个事件。jQuery 1.7中提供了on方式，on(type,[selector],[data],fn)中增加了selector，如果能够匹配到该selector则执行此方法：123$(&quot;#table&quot;).on(&quot;click&quot;,&quot;td&quot;,function()&#123; $(this).css(&apos;background&apos;,&apos;red&apos;);&#125;) 7、将代码转化成jQuery插件将代码转化成插件能让代码具有更好的重用性。 8、使用join()来拼接字符串使用join来拼接字符串比使用”+“来拼接长字符串性能更优。首先创建一个数组，然后循环，最后通过join()将数组转化成字符串：12345var array=[];for(int i=0;i&lt;100;i++)&#123; array[i]=&apos;&lt;li&gt;&apos;+i+&apos;&lt;/li&gt;&apos;; &#125;$(&apos;#list&apos;).html(array.join(&apos;&apos;)); 9、合理利用HTML5的Data属性HTML5的data属性可以帮助我们插入数据，特别是前后端的数据交换。jQuery的data（）方法，有效的利用HTML5的属性，来自动得到数据。12345&lt;div id=&quot;dl&quot; data-role=&quot;page&quot; data-last=&quot;43&quot; data-options=&apos;&#123;&quot;name&quot;:&quot;John&quot;&#125;&apos;&gt;&lt;/div&gt;//读取数据$(&quot;#dl&quot;).data(&quot;role&quot;); //&quot;page&quot;$(&quot;#dl&quot;).data(&quot;last&quot;); //43$(&quot;#dl&quot;).data(&quot;options&quot;).name; //&quot;John&apos; 10、尽量使用原生的JavaScript方法123456var $cr=$(&quot;#cr&quot;);$cr.click(function()&#123; if($cr.is(&quot;:checked&quot;))&#123; //jQuery方式判断 &#125;&#125;) 它使用了jQuery提供的is方法来判断多选框是否被选中，但是这里可以直接使用原生的JavaScript方法：123456var $cr=$(&quot;#cr&quot;); //jQuery对象var cr=$cr.get(0); //DOM对象$cr.click(function()&#123; if(cr.checked)&#123; //原生的js方式判断 &#125;&#125;) 第二种方式比第一种方式效率高，因为它不需要拐弯抹角去调用许多函数。 11、压缩JavaScript一方面使用Gzip，另一方面去除JS文件里的注释、空白。","categories":[],"tags":[],"keywords":[]},{"title":"页面内跳转方法总结","slug":"页面内跳转方法总结","date":"2017-06-22T08:31:43.000Z","updated":"2017-06-22T09:04:27.613Z","comments":true,"path":"2017/06/22/页面内跳转方法总结/","link":"","permalink":"https://aliceflaviawang.github.io/2017/06/22/页面内跳转方法总结/","excerpt":"","text":"方法一：用标签，在href里写入定位的DIV的id.如：1234&lt;a href=&quot;#div1&quot;&gt;scroll to div1&gt;&lt;/a&gt; //定位到div1&lt;div id=&quot;div1&quot;&gt;div1&lt;/div&gt;&lt;div id=&quot;div2&quot;&gt;div2&lt;/div&gt;&lt;div id=&quot;div3&quot;&gt;div3&lt;/div&gt; 缺点：点击锚点后，浏览器的URL会发生变化，刷新会出现问题。 方法二：使用js中的window.location.hash=”divId”跳转，但地址也会发生变化，跟第一种方法差不多。123456&lt;a href=&quot;javascript:void(0)&quot; onclick=&quot;locate()&quot;&gt;&lt;/a&gt;&lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; funtion locate()&#123; window.location.hash=&quot;#div1&quot;;&#125; 方法三：用animate属性，当点击锚点后，页面滚动到相应的div。12345678&lt;a href=&quot;javascript:void(0)&quot; onclick=&quot;locate()&quot;&gt;&lt;/a&gt;&lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function lacate()&#123; $(&quot;html&quot;,&quot;body&quot;).animate(&#123; scrollTop:$(&quot;#div1&quot;).offset().top &#125;,&#123;duration:500,easing:&quot;swing&quot;&#125;) &#125; 优点：url地址不会改变，同时点击锚点会自动响应scroll事件，不需要重新绑定。缺点：如果页面复杂的话，偏移值可能会发生变化需要算法辅助。 方法四：用js的scrollIntoView方法，直接用：123456&lt;a href=&quot;javascript:void(0)&quot; onclick=&quot;locate()&quot;&gt;&lt;/a&gt;&lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;function lacate()&#123; docuemnt.getElementById(&quot;div1&quot;).scrollIntoView();&#125; 优点：url不会变，同时能够响应scroll事件，不需要算法什么的。注意：scrollIntoView是js方法，不能使用$(“#div1”).scrollIntoView().","categories":[],"tags":[],"keywords":[]},{"title":"JSON.parse()和Json.stringify()","slug":"JSON-parse-和Json-stringify","date":"2017-06-22T02:01:30.000Z","updated":"2017-06-22T02:14:29.284Z","comments":true,"path":"2017/06/22/JSON-parse-和Json-stringify/","link":"","permalink":"https://aliceflaviawang.github.io/2017/06/22/JSON-parse-和Json-stringify/","excerpt":"","text":"JSON.parse()parse是用一个字符串中解析出json对象，如：var str=’{“name”:”alice”,”age”:”23”}’结果：JSON.parse(str)Objectage:”23”name:”alice”proto:Object 注意：单引号写在{}外面，每个属性名必须用双引号，否则会报错 JSON.stringify()stringify是从对象解析出字符串，如：var a={a:1,b:2}JSON.stringify(a)‘{“a”:1,”b”:2}’","categories":[],"tags":[],"keywords":[]},{"title":"serialize()系列方法","slug":"serialize-系列方法","date":"2017-06-17T11:22:16.000Z","updated":"2017-06-17T13:25:38.569Z","comments":true,"path":"2017/06/17/serialize-系列方法/","link":"","permalink":"https://aliceflaviawang.github.io/2017/06/17/serialize-系列方法/","excerpt":"","text":"serialize()jQuery有方法$.fn.serialize()，可以将表单序列化成字符串。提交表单的时候，将表单的每个元素表达成如：username:$(“#username”).val(),content:$(“#content”).val()…无疑随着表单元素越来越复杂，这种方式在增大工作量的同时也使表单元素缺乏弹性。采用serialize（）方法可以将需要提交的字段内容序列化为字符串，username:$(“#username”).val(),content:$(“#content”).val()…可以用一个语句代替:$(“#form”).serialize(),其中#form是表单的id。 serialize()的其他两种方法–serializeArray()和serializeObject()serializeArray()是将表单序列化为JSON格式的数据，输出的是对象数组。而serializeObject()是基于serializeArray（）编写的。下面例子能非常清晰的看出其中的区别：123$(&quot;#form&quot;).serialize(); //username=&amp;content=$(&quot;#form&quot;).serializeArray(); //[&#123;name:&quot;username&quot;,value:&quot;&quot;&#125;,&#123;name:&quot;content&quot;,value:&quot;&quot;&#125;]$(&quot;#form&quot;).serializeObject(); //&#123;username:&quot;&quot;,content:&quot;&quot;&#125; 注意1、serializeObject()直接使用的话，会提示serializeObject()is not a funtion.因为serializeObject()本身并不是一个jQuery自带的功能，而是基于serializeArray（）的添加功能，需要对其进行定义如下：12345678910111213141516$.fn.serializeObject()&#123; var o=&#123;&#125;; //保存对象 var a=this.serializeArray(); //先将元素序列化为对象数组 $.each(a,function()&#123; if(o[this.name])&#123;//表单中可能有多个相同的label，在插入第一个label后，还有继续插入，这个时候o[label]已经存在了，所以要把o[label]做嵌套处理 if（！o[this.name].push)&#123; //如果o[label]不是嵌套在数组里面，实际上就是看o[this.name]是不是一个数组，数组有push方法，对象没有 o[thos.name]=[o[this.name]];将o[label]初始为嵌套数组 &#125; o[this.name].push(this.value||&apos;&apos;); //将值插入o[label]数组里 &#125; else&#123; o[this.name]=this.value||&apos;&apos;;//第一次在o中插入o[label] &#125; &#125;) return o;&#125; 举个例子,对于下面的表单：123456&lt;form id=&quot;form&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt; &lt;input type=&quot;text&quot; name=&quot;content&quot; /&gt; &lt;input type=&quot;button&quot; id=&quot;send&quot; onclick=&quot;sen();&quot;&gt;&lt;/form&gt; 执行三个函数，分别结果为：12345var a=$(&quot;#form&quot;).serialize(); //username=alice&amp;username=bob&amp;content=123 var b=$(&quot;#form&quot;).serializeArray(); //[&#123;name:&quot;username&quot;,value=&quot;alice&quot;&#125;,&#123;name:&quot;username&quot;,value=&quot;bob&quot;&#125;,&#123;name:&quot;content&quot;,value=&quot;123&quot;&#125;]var c=$(&quot;#form&quot;).serializeObject(); //&#123;username:[&quot;alice&quot;,&quot;bob&quot;],content:&quot;123&quot;&#125; 2、表单元素要序列化必须要使用name属性，form里的name不能用js、jquery的关键字，否则获取不到值。3、不光表单能用到serialize()方法，其他选择器元素也可以。比如：1$(&quot;:checkbox,:radio&quot;).serialize()","categories":[],"tags":[],"keywords":[]},{"title":"EasyUI更改弹出框位置","slug":"EasyUI更改弹出框位置","date":"2017-06-15T02:15:18.000Z","updated":"2017-06-15T02:21:15.667Z","comments":true,"path":"2017/06/15/EasyUI更改弹出框位置/","link":"","permalink":"https://aliceflaviawang.github.io/2017/06/15/EasyUI更改弹出框位置/","excerpt":"","text":"EasyUI的dialog弹出一般用的是$(‘#dlg’).dialog(‘open’)，要想调整其位置，可以采用$(‘#dlg’).window(‘open’)，再用window的resize方法重新布局就可以了。如：1$(&apos;#dlg&apos;).dialog(&apos;open&apos;).dialog(&apos;center&apos;).dialog(&apos;setTitle&apos;, &apos;添加题目&apos;); 可以改成：1$(&apos;#dlg&apos;).window(&apos;open&apos;).window(&apos;setTitle&apos;,&apos;添加题目&apos;).window(&apos;resize&apos;,&#123;width:&apos;500px&apos;,height:&apos;800px&apos;,top:&apos;30px&apos;&#125;","categories":[],"tags":[],"keywords":[]},{"title":"a标签中href=''的几种用法","slug":"a标签中href-的几种用法","date":"2017-06-13T06:54:22.000Z","updated":"2017-06-13T12:29:08.779Z","comments":true,"path":"2017/06/13/a标签中href-的几种用法/","link":"","permalink":"https://aliceflaviawang.github.io/2017/06/13/a标签中href-的几种用法/","excerpt":"","text":"a标签的主要作用是实现超链接和锚点，下面总结下a标签href的几种用法。 一、href的几种调用方法1、a href=”javascript:js_method();”这是常用的方法，但是这种方法在传递this等参数的时候很容易出问题，而且javascript：协议作为a的href属性的时候不仅会导致不必要的触发window.onbeforeunload事件，在IE里面更会使gif动画图片停止播放。W3C标准不推荐在href里面执行javascript语句。 2、a href=”javascript:void(0);” onclick=”js_method()”这种方法是很多网站最常用的方法，也是最周全的方法，onclick方法负责执行js函数，而void是一个操作符，void(0)返回undefined，地址不发生跳转。而且这种方法不会像第一种方法一样直接js方法暴露在浏览器的状态栏。 3、a href=”javascript:;” onclick=”js_method()”这种方法跟2类似，区别只是执行了一条空的js代码 4、a href=”#” onclick=”js_method()”这种方法也是网上很常见的代码，#是标签内置的一个方法，”#”包含了一个位置信息，默认的锚点是#top,就是点击后返回页面的顶端。（如果希望不返回页面顶端，可以在#后面加任意无效的位置信息，如###） 5、a href=”#” onclick=”js_method();return false;”这种方法点击执行了js函数后return false,页面不发生跳转，执行后还是在页面的当前位置。","categories":[],"tags":[],"keywords":[]},{"title":"return false实现同时对事件对象停止冒泡和默认行为","slug":"return-false实现同时对事件对象停止冒泡和默认行为","date":"2017-06-12T08:06:54.000Z","updated":"2017-06-12T09:17:10.934Z","comments":true,"path":"2017/06/12/return-false实现同时对事件对象停止冒泡和默认行为/","link":"","permalink":"https://aliceflaviawang.github.io/2017/06/12/return-false实现同时对事件对象停止冒泡和默认行为/","excerpt":"","text":"冒泡网页上有两个元素，其中一个元素嵌套在另一个元素里面，并且都被绑定了click事件，那么点击内层元素，会冒泡到外层元素上。1234567891011121314151617181920212223242526&lt;body&gt;&lt;div id=&quot;content&quot;&gt; 外层div元素 &lt;span&gt;内层div元素&lt;/span&gt; 外层div元素&lt;/div&gt;&lt;div id=&apos;msg&apos;&gt;&lt;/div&gt;&lt;script&gt;$(function()&#123; $(&apos;span&apos;).bind(&apos;click&apos;,function()&#123; var txt=$(&apos;#msg&apos;).html()+&apos;&lt;p&gt;内层div元素被单击。&lt;/p&gt;&apos;; $(&apos;#msg&apos;).html(txt); &#125;) $(&apos;#content&apos;).bind(&apos;click&apos;,function()&#123; var txt=$(&apos;#msg&apos;).html()+&apos;&lt;p&gt;外层div元素被单击。&lt;/p&gt;&apos;; $(&apos;#msg&apos;).html(txt) &#125;) $(&apos;body&apos;).bind(&apos;click&apos;,function()&#123; var txt=$(&apos;#msg&apos;).html()+&apos;&lt;p&gt;body元素被单击。&lt;/p&gt;&apos;; $(&apos;#msg&apos;).html(txt) &#125;)&#125;)&lt;/script&gt;&lt;/body&gt; 效果如图：点击span元素点击外层div元素点击内层元素，会冒泡到外层的点击事件。 阻止冒泡stopPropagation()方法可以停止事件冒泡。12345$(&apos;span&apos;).bind(&apos;click&apos;,function(event)&#123; var txt=$(&apos;#msg&apos;).html()+&apos;&lt;p&gt;内层div元素被单击。&lt;/p&gt;&apos;; $(&apos;#msg&apos;).html(txt); event.stopPropagation(); &#125;) 点击span元素 阻止默认行为网页中的元素有自己的默认行为，例如，单击“提交”按钮后表单会提交，有时需要阻止元素的默认行为。1234567891011121314151617&lt;form action=&quot;test.html&quot;&gt;用户名：&lt;input type=&quot;text&quot; id=&quot;username&quot;&gt;&lt;br/&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot; id=&quot;sub&quot;&gt;&lt;/form&gt;&lt;div id=&quot;msg&quot;&gt;&lt;/div&gt;&lt;script&gt;$(function()&#123; $(&apos;#sub&apos;).bind(&apos;click&apos;,function()&#123; var username=$(&apos;#username&apos;).val(); if(username==&apos;&apos;)&#123; $(&apos;#msg&apos;).html(&apos;&lt;p&gt;文本框的值不能为空。&lt;/p&gt;&apos;); &#125; &#125;)&#125;)&lt;/script&gt; 如果不阻止默认行为，用户名为空的时候，也能提交表单。阻止默认行为使用preventDefault()方法。1234567$(&apos;#sub&apos;).bind(&apos;click&apos;,function(event)&#123; var username=$(&apos;#username&apos;).val(); if(username==&apos;&apos;)&#123; $(&apos;#msg&apos;).html(&apos;&lt;p&gt;文本框的值不能为空。&lt;/p&gt;&apos;); event.preventDefault(); &#125; &#125;) 同时对事件对象停止冒泡和默认行为——return false将event.stopPropagation()和event.preventDefault()替换为return false就可以实现同样的效果。 return false到底做了什么1、event.preventDefault()2、event.stopPropagation()3、停止回调函数执行并立即返回return false看似实现了阻止冒泡或者阻止默认事件，实际上还做了另外的操作，阻止浏览器默认行为的只有preventDefault()，除非你想停止事件冒泡，否则使用return false会为你的代码埋下很大的隐患。 ###扩展-stopImmediatePropagation()stopImmediatePropagagtion()函数用于阻止剩余的事件处理函数的执行(为同一对象绑定了多个事件处理函数)，并防止当前事件在DOM树上冒泡。12345678910111213141516171819202122232425&lt;p&gt;段落文本内容 &lt;input type=&quot;button&quot; value=&quot;点击&quot; /&gt;&lt;/p&gt;&lt;script&gt;// 为所有p元素绑定click事件$(&quot;p&quot;).click( function(event)&#123; alert(&quot;p-click&quot;);&#125; );// 为所有button元素的click事件绑定第一个事件处理函数$(&quot;:button&quot;).click( function(event)&#123; alert(&quot;button-click-1&quot;); // 阻止事件冒泡到DOM树上，并阻止剩余的事件处理函数的执行 // 只执行button-click-1，如果注释掉该行，将执行button-click-1、button-click-2和p-click // 如果换成event.stopPropagation() 将执行button-click-1和button-click-2 event.stopImmediatePropagation();&#125; );// 为所有button元素的click事件绑定第二个事件处理函数$(&quot;:button&quot;).click( function(event)&#123; alert(&quot;button-click-2&quot;);&#125; );&lt;/script&gt; 与stopPropagation()相比，stopImmediatePropagation()还能阻止剩余事件处理函数的执行。","categories":[],"tags":[],"keywords":[]},{"title":"ajax dataType","slug":"ajax-dataType","date":"2017-06-08T02:42:09.000Z","updated":"2017-06-09T06:30:48.124Z","comments":true,"path":"2017/06/08/ajax-dataType/","link":"","permalink":"https://aliceflaviawang.github.io/2017/06/08/ajax-dataType/","excerpt":"","text":"遇到一个很奇怪的问题12345678910$.ajax(&#123; type:&quot;POST&quot;, async:false, contentType: &quot;application/json; charset=utf-8&quot;, // dataType: &apos;json&apos;, url:baseUrl+&quot;/office/getEmploymentPeriod.do&quot;, success:function(data)&#123; console.log(data) //&#123;&quot;body&quot;:&quot;2017年3月-2017年7月&quot;,&quot;message&quot;:&quot;成功&quot;,&quot;status&quot;:0&#125; console.log(data.body) // undefined &#125; 如果没有dataType:’json’,返回的data是json对象，访问data.body是undefined。加上dataType:’json’，返回的是普通对象，访问data.body可以获取到。疑问是，dataType:’json’是指定返回数据的格式是’json’，为什么会返回数据的格式是普通对象，不指定反而返回的是’json’对象，另外返回数据无论是普通对象还是json对象，按理都应该能通过对象.属性访问到。12345678910$.ajax(&#123; type:&quot;POST&quot;, async:false, contentType: &quot;application/json; charset=utf-8&quot;, dataType: &apos;json&apos;, url:baseUrl+&quot;/office/getEmploymentPeriod.do&quot;, success:function(data)&#123; console.log(data) //&#123;body: &quot;2017年3月-2017年7月&quot;, message: &quot;成功&quot;, status: 0&#125; console.log(data.body) // 2017年3月-2017年7月 &#125;","categories":[],"tags":[],"keywords":[]},{"title":"apply,call,bind用法","slug":"apply-call-bind用法","date":"2017-06-06T03:10:43.000Z","updated":"2017-06-06T06:45:04.789Z","comments":true,"path":"2017/06/06/apply-call-bind用法/","link":"","permalink":"https://aliceflaviawang.github.io/2017/06/06/apply-call-bind用法/","excerpt":"","text":"1、apply()方法——apply([thisObj[,argArray]])apply()接收两个参数：一个是运行函数的作用域，另一个是参数数组。其中第二个参数可以是Array的实例，也可以是arguments对象。 2、call()方法——call([thisObj[,arg1[, arg2[, [,.argN]]]]])与apply作用相同，区别在于接收参数方式不同。第一个参数this的值没有变化，其余参数是以列举的方式直接传递给函数。 apply, call共同之处都可以用来代替另一个对象调用一个方法，将一个函数的对象上下文从初始上下文改变为由thisObj指定的新对象。 不同之处apply最多只能有两个参数——新this对象和一个数组argArray，如果argArray不是一个有效的数组或者不是arguments对象，那么将导致一个TypeError，如果没有提供argArray和thisObj任何一个参数，那么Global对象将被用作thisObj，并且无法被传递任何参数call传递的是参数列表，。如果没有提供thisObj参数，那么Global对象被用作thisObj。apply和call功能一样，只是传入参数列表形式不同，如果某个参数数量是不固定的，当参数明确时用call，不明确时用apply，然后把参数push进数组传递，函数内部也可以通过arguments数组来遍历所有参数。 3、bind()方法——fun.bind(thisObj[,arg1[, arg2[, [,.argN]]]]])与apply和call不同的是，bind会返回一个改变this指向的新函数，新函数与之前的使用的不是同一块内存地址，所以需要重复使用这个函数的时候，必须将其保存到一个变量，方便下次调用。而apply和call都是调用即执行。另外，bind函数中的首个参数，会自动成为返回新函数中参数的默认值，那么正式调用的时候，只需给出除首个参数外，剩余参数即可。 123456function f(x,y)&#123; console.log(x+y);&#125;f.call(null,1,1) //return 2var new_f=f.bind(null,1,1);new_f(2); //return 2 上面实例中thisArg参数均用null代替了，在未给出指定thisArg对象情况下，null与undefined下this指向的是全局对象，即js代码执行环境。 apply, call, bind比较123456789101112var obj=&#123;bar:&apos;hello&apos;&#125;var foo=&#123; get:function()&#123; return this.bar; &#125;&#125;var bind=foo.get.bind(obj), call=foo.get.call(obj), apply=foo.get.apply(obj);console.log(bind(),call,apply); //hello hello helloconsole.log(bind,call,apply); //function()&#123;return this.bar;&#125; &quot;hello&quot; &quot;hello&quot;console.log(typeof bind,typeof call,typeof apply); function string stringconsole.log(typeof bind(),typeof call,typeof apply); //string string string 三者的区别是：当你希望改变上下文环境之后并非立即执行，而是回调执行的时候，使用bind()方法，而apply/call则会立即执行函数。1234apply, call, bind三者都是用来改变函数的this对象的指向apply, call, bind三者第一个参数都是this要指向的对象，也就是想指定的上下文apply, call, bind三者都可以利用后续参数传参bind是返回对应的函数，便于稍后调用；apply, call则立即调用","categories":[],"tags":[],"keywords":[]},{"title":"JS定义变量的三种方式","slug":"JS定义变量的三种方式","date":"2017-06-05T03:05:49.000Z","updated":"2017-06-05T03:18:28.496Z","comments":true,"path":"2017/06/05/JS定义变量的三种方式/","link":"","permalink":"https://aliceflaviawang.github.io/2017/06/05/JS定义变量的三种方式/","excerpt":"","text":"1、最常见的var定义变量，可以修改，如果不初始化会输出undefined,但不会报错。12345678var a=1;console.log(&apos;函数外定义a:&apos;+a); //输出a=1function change()&#123; a=4; console.log(&apos;函数内定义a:&apos;+a); //可以输出a=4;&#125;change();console.log(&apos;函数调用后var定义a为函数内部修改值:&apos;+a); //输出a=4 2、const定义的变量不可以修改，而且必须初始化。12345const b=2;// const b; //错误，必须初始化console.log(b); //有输出值// b=5;console.log(b); //报错，不能给常量赋值 3、let是块级作用域，函数内部使用let定义后，对函数外部无影响。12345678let c=3;console.log(&apos;函数外定义c:&apos;+c); //输出c=3;function change()&#123; let c=6; console.log(&apos;函数内定义c:&apos;+c); //输出c=6;&#125;change();console.log(&apos;函数调用后let定义c不受函数内部定义的影响：&apos;+c); //输出c=3;","categories":[],"tags":[],"keywords":[]},{"title":"从输入URL到浏览器显示页面发生了什么","slug":"从输入URL到浏览器显示页面发生了什么","date":"2017-05-27T02:06:07.000Z","updated":"2017-05-27T07:15:26.824Z","comments":true,"path":"2017/05/27/从输入URL到浏览器显示页面发生了什么/","link":"","permalink":"https://aliceflaviawang.github.io/2017/05/27/从输入URL到浏览器显示页面发生了什么/","excerpt":"","text":"从输入URL到浏览器显示页面，这个过程分为两个部分：网络通信和页面渲染。 一、网络通信互联网内各网络设备间的通信都遵循TCP/IP协议，利用TCP/IP协议族进行网络通信时，会通过分层顺序与对方进行通信。分层由高到低分别为：应用层、传输层、网络层、数据链路层。发送端从应用层往下走，接收端从数据链路层往上走。如下图所示： 1.在浏览器中输入URL用户输入URL，例如http://www.baidu.com。其中http为协议，www.baidu.com为网络地址，及指出需要的资源在那台计算机上。一般网络地址可以为域名或IP地址，此处为域名。使用域名是为了方便记忆，但是为了让计算机理解这个地址还需要把它解析为IP地址。 2.应用层DNS解析域名客户端先检查本地是否有对应的IP地址，若找到则返回响应的IP地址。若没找到则请求上级DNS服务器，直至找到根节点。 3.应用层客户端发送HTTP请求HTTP请求包括请求报头和请求主体两个部分，其中请求报头包含了至关重要的信息，包括请求的方法（GET/POST)、目标URL、遵循的协议（HTTP/HTTPS/FTP…),返回的信息是否需要缓存，以及客户端是否发送cookie等。 4.传输层TCP传输报文位于传输层的TCP协议为传输报文提供可靠的字节流服务。它为了方便传输，将大块的数据分割成以报文段位单位的数据包进行管理，并为它们编号，方便服务器接收时能准确地还原报文信息。TCP协议通过“三次握手”等方法保证传输的安全可靠。“三次握手”的过程是，发送端先发送一个带有SYN标志的数据包给接收端，在一定的延迟时间内等待接收的回复。接收端收到数据包后，传回一个带有SYN/ACK标志的数据包以示传达确认信息。接收方收到后再发送一个带有ACL标志的数据包给接收端以示握手成功。在这个过程中，如果发送端在规定延迟时间内没有收到回复则默认接收方没有收到请求，而再次发送，直到收到回复为止。 5.网络层IP协议查询MAC地址IP协议的作用是把TCP分割好的各种数据包传送给接收方。而要保证确实能传到接收方还需要接收方的MAC地址，也就是物理地址。IP地址和MAC地址是一一对应的关系，一个网络设备的IP地址可以更换，但是MAC地址一般是固定不变的。ARP协议可以将IP地址解析成对应的MAC地址。当通信的双方不在同一个局域网时，需要多次中转才能到达最终的目标，在中转的过程中需要通过下一个中转站的MAC地址来搜索下一个中转目标。 6.数据到达数据链路层在找到对方的MAC地址后，就将数据发送到数据链路层传输。这时客户端发送请求的阶段结束。 7.服务器接收数据接收端的服务器在链路层接收到数据包，再层层向上直到应用层。这过程中包括在运输层通过TCP协议将分段的数据包重新组成原来得HTTP请求报文。 8.服务器响应请求服务接收到客户端发送的HTTP请求后，查找客户端请求的资源，并返回响应报文，响应报文中包括一个重要的信息————状态码。状态码由三位数字组成，其中比较常见的是200 OK表示请求成功。301表示永久重定向，即请求的资源已经永久转移到新的位置。在返回301状态码的同时，响应报文也会附带重定向的URL，客户端接收后将HTTP请求的URL做相应的改变再重新发送。404 not found表示客户端请求的资源找不到。 9.服务器返回相应文件请求成功后，服务器会返回相应的HTML文件。接下来就到了页面渲染阶段了。 二、页面渲染现代浏览器渲染页面的过程是这样的：解析HTML以构建DOM树——&gt;构建渲染树——&gt;布局渲染树——&gt;绘制渲染树。DOM树是由HTML文件中的标签排列组成，渲染树是在DOM树种加入CSS或HTML中的style样式而形成。渲染树只包含显示在页面中的DOM元素，像元素或display属性值为none的元素都不在渲染树中。在浏览器还没接收到完整的HTML文件时，它就开始渲染页面了，在遇到外部链入的脚本标签或样式标签或图片时，会再次发送HTTP请求重复上述的步骤。在收到CSS文件后会对已经渲染的页面重新渲染，加入它们应有的样式，图片文件加载完立刻显示在相应位置。在这一过程中可能会触发页面的重绘或重排。","categories":[],"tags":[],"keywords":[]},{"title":"DOM性能提升","slug":"DOM性能提升","date":"2017-05-26T07:42:01.000Z","updated":"2017-05-26T08:51:27.848Z","comments":true,"path":"2017/05/26/DOM性能提升/","link":"","permalink":"https://aliceflaviawang.github.io/2017/05/26/DOM性能提升/","excerpt":"","text":"DOM(文档对象模型)是针对HTNL和XML文档的一个API（应用程序编程接口），DOM可以将任何一个HTML或XML文档描绘成一个由多层节点构成的节点树，允许开发人员添加、移除和修改页面的某一部分。 DOM的核心问题DOM会导致一系列的重绘(repaint)、重新排版(reflow)操作。为了确保执行结果的准确性，所有的修改是按顺序同步进行的，大部分浏览器都不会在执行过程中更新DOM。相应的，这些浏览器将对DOM的操作放在一个队列，并在JavaScript脚本执行完毕以后按顺序一次执行完毕。也就是说，在JavaScript执行的过程，直到发生重新排版，用户一直被阻塞。一般的浏览器中（不含IE），repaint的速度远快于reflow，所以避免reflow更重要。reflow:例如某个子元素样式发生改变，直接影响到了其父元素以及往上追溯很多祖先元素（包括兄弟元素），这时候浏览器要重新渲染这个子元素相关联的所有元素的过程。reflow几乎无法避免。repaint:如果只是改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性，将只会引起浏览器的repaint。 解决方案关键：减少DOM操作引起的reflow。 1、使用DoucumentFragment一次性更新DOM12345678//使用容器保存临时变更，最后一次性更新DOMvar fragment=document.createDocumentFragment();for(var i=0;i&lt;items,length;i++)&#123; var item=document.createElement(&quot;li&quot;); item.appendChild(document.createTextNode(&quot;Option&quot;+i); fragment.appendChild(item); &#125;list.appendChild(fragment); 2、操作DOM前，先把DOM节点删除或隐藏，因为隐藏的节点不会发生重排1234567list.style.display=&quot;none&quot;;for(var i=0;i&lt;items,length;i++)&#123; var item=document.createElement(&quot;li&quot;); item.appendChild(document.createTextNode(&quot;Option&quot;+i); list.appendChild(item); &#125;list.style.display=&quot;&quot;; 3、一次性修改样式属性1234//这样做很引起多次重排element.style.backgroundColor=&quot;blue&quot;;element.style.color=&quot;red&quot;;element.style.fontSize=&quot;12em&quot;; 1234567//更好的做法是，把样式放在一个class下.newStyle&#123; background-color:blue; color:red; font-size:12em;&#125;element.className=&quot;newStyle&quot;; 4、使用缓存，缓存临时节点12//不好的做法document.getElementById(&quot;myDiv&quot;).style.left=document.getElementById(&quot;myDiv&quot;).offsetLeft+document.getElementById(&quot;myDiv&quot;).offsetWidth+&quot;px&quot;; 123//更好的做法var myDiv=document.getElementById(&quot;myDiv&quot;);myDiv.style.left=myDiv.offsetLeft+myDiv.offsetWidth+&quot;px&quot;;","categories":[],"tags":[],"keywords":[]},{"title":"跨浏览器事件对象———EventUtil","slug":"跨浏览器事件对象———EventUtil","date":"2017-05-24T02:12:22.000Z","updated":"2017-05-24T07:19:29.935Z","comments":true,"path":"2017/05/24/跨浏览器事件对象———EventUtil/","link":"","permalink":"https://aliceflaviawang.github.io/2017/05/24/跨浏览器事件对象———EventUtil/","excerpt":"","text":"前言EventUtil:在JavaScript中，DOM0级、DOM2级与旧版本IE（8-）为对象添加事件的方法不同，为了以跨浏览器的方式处理时间，需要编写一段“通用代码”，即跨浏览器的事件处理程序，这个方法属于一个名为EventUtil的对象，编写并使用该对象后，可保证处理事件的代码能在大多数浏览器下一致地运行。 EventUtil对象123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106var EventUtil=&#123; addHandler:function(element,type,handler)&#123;//添加事件 if(element.addEventListener)&#123; element.addEventListener(type,handler,false); //使用DOM2级方法添加事件，三个参数分别是：要处理的事件名、作为事件处理的函数和一个布尔值（布尔值表示在捕获阶段(true)还是冒泡阶段(false)调用事件处理程序） &#125; else if(element.attachEvent)&#123; element.attachEvent(&quot;on&quot;+type,handler); //使用IE方法添加事件，两个参数分别为：事件处理程序名称和事件处理程序的函数 &#125; else&#123; element[&quot;on&quot;+type]=handler; //使用DOM0级方法添加事件 &#125; &#125;， removeHandler:function(element,type,handler)&#123; //取消事件 if(element.removeEventListener)&#123; element.removeEventListener(type,handler,false); &#125; else if(element.detachEvent)&#123; element.detachEvent(&quot;on&quot;+type,handler); &#125; else&#123; element[&quot;on&quot;+type]=null; &#125; &#125;, getEvent:function(event)&#123; //使用这个方法跨浏览器取得event对象 return event?event:window.event; //在IE中，使用DOM0级添加事件处理程序时，event对象作为window对象的一个属性存在，而且在IE中，event对象的一些属性/方法跟其他支持DOM的浏览器不同，正是由于这些差异，EventUtil中的getEvent方法应运而生 &#125;, getTarget:function(event)&#123; //返回事件的实际目标 return event.target||event.srcEelment; //在IE中，获取事件的目标对象的方法为event.srcElement，而其他兼容DOM的浏览器中，获取事件目标对象的方法却为event.target &#125;, preventDefault:function(event)&#123; //阻止事件的默认行为 if(event.preventDefault)&#123; //在其他兼容DOM的浏览器中，阻止特定事件的默认行为只需要使用event对象自带的preventDefault()方法 event.preventDefault(); &#125;else&#123; //而IE中，则需要赋予event.returnValue的值为false才能阻止特定事件的默认行为 event.returnValue=false; &#125; &#125; stopPropagation:function(event)&#123; if(event.stopPropagation)&#123; event.stopPropagation(); //DOMO级或DOM2级取消事件进一步冒泡或者捕获 &#125;else&#123; event.cancelBubble=true; //IE中取消时间冒泡 &#125; &#125;, getRelatedTarget:function(event)&#123; //获取mouseover和mouseout相关元素//mouseover与mouseout有“主目标”和“相关元素”的概念，因为在发生mouseover或mouseout事件时，还会涉及到其他元素，这两个事件都会涉及把鼠标指针从一个元素移到另一个元素。具体来说，对mouseover事件，事件的主目标是获得光标的元素，而相关元素是那个失去光标的元素，对mouseout事件而言，事件的主目标是失去光标的元素，而相关元素是那个获得光标的元素。 if(event.relatedTarget)&#123; return event.relatedTarget; &#125; else if(event.toElement)&#123; //mouseout触发时，IE的toElement保存的相关元素属性 return event.toElement; &#125; else if(event.formElement)&#123; //mouseover触发时，IE的formElement保存相关元素属性 return event.formElement; &#125; else&#123; return null; &#125; &#125;, getButton:function(event)&#123; //获取mousedown或mouseup按下或释放的按钮是鼠标的哪一个 if(document.implementation.hasFeature(&quot;MouseEvents&quot;,&quot;2.0&quot;))&#123; return event.button; &#125;else&#123; switch(event.button)&#123;//将IE模型下的button属性映射为DOM模型下的button属性 case 0: case 1; case 3; case 5; case 7; return 0; //按下的是鼠标主按钮（一般是左键） case 2: case 6: return 2; //按下的是中间的鼠标按钮 case 4: return 1; //鼠标次按钮（一般是右键） &#125; &#125; &#125;, getWheelDelta:function(event)&#123; //获取表示鼠标滚轮滚动方向的数值//解决的是与Firefox的差异 if(event.wheelDelta)&#123; return event.wheelDelta; &#125; else&#123; return -event.detail*40; &#125; &#125;, getCharCode:function(event)&#123; //跨浏览器取得相同的字符编码，需在keypress事件中使用//在所有浏览器中，按下能够插入或删除的字符的按键都会触发keypress事件，但IE8-及Opera取得字符编码的方式与其他浏览器有差异 if(typeof event.charCode==&quot;number&quot;)&#123; return event.charCode; &#125;else&#123; return event.keyCode; &#125; &#125;&#125; 举例用法1234567//添加了EventUtil之后，获取了event对象、取消了事件进一步捕获或者冒泡、指定了事件的处理程序而无须担心浏览器兼容问题var btn=document.getElementById(&quot;#btn&quot;);var handler=function(event)&#123; event=EventUtil.getEvent(event); EventUtil.stopPropagation(event); &#125;Event.addHandler(btn,&quot;click&quot;,handler);","categories":[],"tags":[],"keywords":[]},{"title":"为什么js没有函数签名","slug":"为什么js没有函数签名","date":"2017-05-01T02:30:42.000Z","updated":"2017-05-02T01:18:01.450Z","comments":true,"path":"2017/05/01/为什么js没有函数签名/","link":"","permalink":"https://aliceflaviawang.github.io/2017/05/01/为什么js没有函数签名/","excerpt":"","text":"什么是函数签名MDN上关于函数签名的说明：A function signature(or type signature, or method signature) defines input and putput of functions or methods.A signature can include: parameters and their types a return value and type exceptions that might be thrown or passed back information about the availability of the method in an object-oriented program(such as the keywords public, static, or prototype).翻译过来就是函数签名定义了函数或方法的输入输出，签名包括参数个数和类型、返回值和类型、抛出或者往后传的异常、面向对象程序方法可行性的信息。为什么js没有函数签名在其他语言中，命名参数必须要求事先创建函数签名，将来调用也必须与该签名一致；而js的参数是由包含0个或多个值的数组来表示的，命名参数只是提供便利，但不是必须的，解析器也不会验证命名参数，所以js没有签名。举个例子：1234function sayHi()&#123; alert(&quot;Hi &quot;+arguments[0]+&quot;, &quot;+arguments[1]);&#125;sayHi(&quot;Alice&quot;,&quot;how are you?&quot;); 对这个例子，命名参数为空，但是照样可以按照两个参数的格式去调用该方法，是因为对ECMAScript，无论传递给函数的参数是什么，函数接收到的始终都是数组，通过arguments对象访问的参数数组。所谓的参数类型、参数个数、参数位置、出入参数，js都不关心，它所有的值都被放倒arguments中了，需要返回值的话直接return，不用声明。","categories":[],"tags":[],"keywords":[]},{"title":"slice(), substring(), substr()总结","slug":"slice-substring-substr-总结","date":"2017-04-25T13:47:05.000Z","updated":"2017-04-25T13:56:07.132Z","comments":true,"path":"2017/04/25/slice-substring-substr-总结/","link":"","permalink":"https://aliceflaviawang.github.io/2017/04/25/slice-substring-substr-总结/","excerpt":"","text":"slice(), substring(), substr()都是用来获取子字符串，，且不会修改字符串本身的值。区别：1、参数不同slice: slice(start, end) //start表示子字符串开始的位置，end是子字符串最后一个字符后面的位置substring: substring(start, end) //同slicesubstr: substr(start, num) //num表示返回字符的个数2、参数是负值的情况不同slice: 将负值与字符串长度相加substring： 将所有的负值转换成0，且会将较小的数作为开始位置，较大的数作为结束位置substr: 将负的第一个参数加上字符串长度，负数第二个参数转换为0```var s=”hello world”;s.slice(3,-4); //“lo w”s.substring(3,-4); //“hel”s.substr(3,-4); //“”（空字符串）","categories":[],"tags":[],"keywords":[]},{"title":"append和prepend","slug":"append和prepend","date":"2017-04-24T14:09:07.000Z","updated":"2017-04-24T14:17:54.922Z","comments":true,"path":"2017/04/24/append和prepend/","link":"","permalink":"https://aliceflaviawang.github.io/2017/04/24/append和prepend/","excerpt":"","text":"append()和prepend()方法都是jQuery文档操作方法，append()在被选元素的结尾插入指定内容，而prepend()则是在被选元素的前面插入制定内容。比如：1234&lt;div id=&quot;console&quot;&gt; &lt;h2&gt;Console Log&lt;/h2&gt; &lt;ul&gt;&lt;/ul&gt;&lt;/div&gt; 添加元素到ul中123456var $consoleLog = $(&quot;#console ul&quot;); var show = function(msg) &#123; var $msg = $(&quot;&lt;li&gt;&lt;/li&gt;&quot;); $msg.text(msg); $consoleLog.prepend($msg); &#125;; 此处采用prepend是从下往上的添加元素，最新添加的元素显示在最上面.注：$(&quot;&lt;li&gt;&lt;/li&gt;&quot;)是创建一个li元素并返回jQuery对象，不是选中它，因为这样创建的元素还不在html结构中，只是在内存中存在。","categories":[],"tags":[],"keywords":[]},{"title":"transform-origin,rotate实现绕中心旋转","slug":"transform-origin-rotate实现绕中心旋转","date":"2017-04-24T13:40:49.000Z","updated":"2017-04-24T14:00:43.434Z","comments":true,"path":"2017/04/24/transform-origin-rotate实现绕中心旋转/","link":"","permalink":"https://aliceflaviawang.github.io/2017/04/24/transform-origin-rotate实现绕中心旋转/","excerpt":"","text":"一般实现环形旋转可以通过animation动画的方式举个例子：1&lt;img src=&quot;images/min-iconfont-rocket-active.png&quot;&gt; 通过animation，对应的css代码为：1234567891011121314@keyframes spin&#123; to&#123; transform: rotate(1turn); &#125;&#125;img&#123; position: absolute; top:50px; left:50px; width:50px; height:50px; animation:spin 10s infinite linear; transform-origin:150px 150px;&#125; 也可以通过transform-origin+rotate的js实现，transform-origin对应旋转中心的位置，rotate可以设置旋转的角度。设置一个图片进行旋转，对于的css代码12345678img&#123; position: absolute; top:50px; left:50px; width:50px; height:50px; transform-origin: 150px 150px; //设置旋转的中心位置 &#125; 对应的js123456789var deg=0;var timer=setInterval(function()&#123; deg+=10; rotate(deg);&#125;,20)function rotate(deg)&#123; var my=&quot;rotate(&quot;+deg+&quot;deg)&quot; $(&quot;img&quot;).css(&quot;transform&quot;,my)&#125; 对于transform-orgin其默认的位置是元素的中心位置，可以通过设置重新确定中心。注：想了解更多transform实现环形路径平移动画，可以参看 http://www.open-open.com/lib/view/open1478661385568.html.","categories":[],"tags":[],"keywords":[]},{"title":"apply()和call()用法","slug":"apply-和call-用法","date":"2017-04-24T03:10:47.000Z","updated":"2017-04-24T06:38:18.222Z","comments":true,"path":"2017/04/24/apply-和call-用法/","link":"","permalink":"https://aliceflaviawang.github.io/2017/04/24/apply-和call-用法/","excerpt":"","text":"每个函数都有两个非继承的方法：apply（）和call()。这两个方法都是在特定作用域中调用函数，实际上等于设置函数体内this对象的值。 方法定义1、apply()方法——apply([thisObj[,argArray]])apply()接收两个参数：一个是运行函数的作用域，另一个是参数数组。其中第二个参数可以是Array的实例，也可以是arguments对象。 2、call()方法——call([thisObj[,arg1[, arg2[, [,.argN]]]]])与apply作用相同，区别在于接收参数方式不同。第一个参数this的值没有变化，其余参数是以列举的方式直接传递给函数。 作用1、扩充函数赖以运行的作用域12345678910window.color=&quot;red&quot;;var o=&#123;color:&quot;blue&quot;&#125;;function sayColor()&#123;alert(this.color)&#125;sayColor(); //redsayColor.call(this); //redsayColor.call(window); //redsayColor.call(o); //blue sayColor.call(o)与o.sayColor()效果一样，但是使用call()(或apply())是的对象不需要与方法有任何耦合关系。 2、实现继承1234567891011function Animal(name)&#123;this.name=name;this.showName=function()&#123;alert(this.name);&#125;&#125;function Cat(name)&#123;Animal.call(this,name);&#125;var cat=new Cat(&apos;Black Cat&apos;);cat.showName(); //Black Cat 3、实现多重继承12345678910111213141516171819202122var s1=function(name)&#123;this.name=name;&#125;var s2=function(sex)&#123;this.sex=sex;&#125;var s3=function(age)&#123;this.age=age;&#125;var Student=function(name,sex,age,score)&#123;s1.call(this,name);s2.call(this,sex);s3.call(this,age);this.score=score;&#125;Student.prototype.construction=Student;var s=new Student(&apos;jack&apos;,&apos;male&apos;,&apos;32&apos;,&apos;100&apos;);console.log(s.name); //jackconsole.log(s.sex); //maleconsole.log(s.age); //32console.log(s.score); //100","categories":[],"tags":[],"keywords":[]},{"title":"理解arguments","slug":"理解arguments","date":"2017-04-24T02:02:40.000Z","updated":"2017-04-24T02:38:43.554Z","comments":true,"path":"2017/04/24/理解arguments/","link":"","permalink":"https://aliceflaviawang.github.io/2017/04/24/理解arguments/","excerpt":"","text":"ECMAScript中的参数是用一个数组表示的。无论传递给函数的参数是什么（有或者没有），函数接收到的始终都是这个数组。在函数体内通过arguments对象来访问这个参数数组，从而获取传递给函数的每个参数。例如：1234function sayHi(name,message)&#123;return;alert(&quot;Hello &quot;+name+&quot;,&quot;+message);&#125; 可以用arguments重写不显示的使用命名参数：1234function sayHi()&#123;return;alert(&quot;Hello &quot;+arguments[0]+&quot;,&quot;+arguments[1]);&#125; arguments特性1、arguments对象的长度是由传入的参数的长度决定的，不是由定义函数时的命名参数的个数决定的123456function howManyArgs(&#123;alert(arguments.length);&#125;howManyArgs(&quot;string&quot;,45); //2howManyArgs(); //0howManyArgs(12) //1 2、arguments的值永远与对应命名参数的值保持同步1234function doAdd(num1,num2)&#123;arguments[1]=10;alert(arguments[0]+num2);&#125; 每次执行doAdd函数都会重写第二个参数（将其修改为10），因为arguments[1]的对象的值会自动反映到对应的命名参数，所以修改了arguments[1]也就修改了num2，他们的值会同步（但内存空间是独立的）。如果只传入了一个参数，arguments[1]的值不会反映到命名参数中（因为特性1）。 3、arguments对象有个callee属性callee属性是一个指针，指向拥有这个arguments对象的函数。1234567fucntion factorial(num)&#123;if(num&lt;=1)&#123;return 1;&#125;else&#123;return num*factorial(num-1);&#125;&#125; 上面的函数的执行与函数名紧紧耦合在一起，为了消除这种紧密耦合现象，可以用arguments.callee。1234567function factorial(num)&#123;if(num&lt;=1)&#123;return 1;&#125;else&#123;return num*arguments.callee(num-1);&#125;&#125; 这样，无论引用函数是时使用的什么名字，都可以保证正常递归调用。看一个例子：12345678910111213function factorial(num)&#123;if(num&lt;=1)&#123;return 1;&#125;else&#123;return num*arguments.callee(num-1);&#125;&#125;var trueFactoral=factorial;factorial=function()&#123;return 0;&#125;alert(trueFactoral(5)); //120alert(factorial(5)); //0 而使用函数名，则：12345678910111213function factorial(num)&#123;if(num&lt;=1)&#123;return 1;&#125;else&#123;return num*factorial(num-1);&#125;&#125;var trueFactoral=factorial;factorial=function()&#123;return 0;&#125;alert(trueFactoral(5)); //0alert(factorial(5)); //0 后记——函数对象的caller属性当一个函数调用另一个函数时，被调用的函数会自动生成一个caller属性，指向调用它的函数对象。若该函数未被调用或没有被其他函数调用，caller为null。而arguments.callee是函数被调用时，arguments.callee对象指向自身，是对自己的引用。注：arguments在函数调用时才有效，因为arguments.callee在函数未调用时是不存在的（即null.callee)。","categories":[],"tags":[],"keywords":[]},{"title":"translate(-50%,-50%)的作用","slug":"translate-50-50-的作用","date":"2017-04-22T14:01:12.000Z","updated":"2017-04-22T14:01:34.391Z","comments":true,"path":"2017/04/22/translate-50-50-的作用/","link":"","permalink":"https://aliceflaviawang.github.io/2017/04/22/translate-50-50-的作用/","excerpt":"","text":"当使用top:50%;left:50%的时候，是以左上角为原点，故元素不处于中心位置。translate(-50%,-50%)的作用是往上（x轴），左（y轴）移动自身长宽的50%，使得元素处于中心位置。例如：1234&lt;div id=&quot;outer&quot;&gt; &lt;div id=&quot;inner&quot;&gt; &lt;/div&gt;&lt;/div&gt; 如果不加transform属性1234567891011121314#outer&#123; position: relative; width: 500px; height: 500px; border: 1px solid black;&#125;#inner&#123; position: absolute; top: 50%; left: 50%; width: 100px; height: 100px; background-color: red;&#125; inner框的左上角处于中心位置，如果希望其中心居于中心位置，将应该向上和向左移动一半的边长长度。加上transform属性，就可以实现这个效果：123456789101112#inner &#123; position: absolute; top: 50%; left: 50%; width: 100px; height: 100px; background-color: red; -ms-transform: translate(-50%,-50%); -moz-transform: translate(-50%,-50%); -o-transform: translate(-50%,-50%); transform: translate(-50%,-50%); &#125;","categories":[],"tags":[],"keywords":[]},{"title":"阿里暑期前端面试总结","slug":"阿里暑期前端面试总结","date":"2017-04-19T10:40:53.000Z","updated":"2017-04-19T10:40:53.645Z","comments":true,"path":"2017/04/19/阿里暑期前端面试总结/","link":"","permalink":"https://aliceflaviawang.github.io/2017/04/19/阿里暑期前端面试总结/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"腾讯暑期实习面试前端面试总结","slug":"腾讯暑期实习面试前端面试总结","date":"2017-04-19T07:36:12.000Z","updated":"2017-04-19T08:25:23.576Z","comments":true,"path":"2017/04/19/腾讯暑期实习面试前端面试总结/","link":"","permalink":"https://aliceflaviawang.github.io/2017/04/19/腾讯暑期实习面试前端面试总结/","excerpt":"","text":"4月13号参加的腾讯面试，不得不说面试机制还是比较完善，通知的10点面试，9点20到达酒店之后，差不多10点就通知了面试地点去候场。因为房间门是开的，所以听到了前一个人的部分面试问题：1、http状态码有哪些，代表的什么意思2、用过缓存没有，local storage和session storage有什么区别3、你说你学过node js，讲一下于是我在门外默默的准备了一下，进去之后面试官看了我的简历上写本科是信息安全，于是问我公钥加密和私钥加密有什么区别。。。我大概记得，但是说反了，然后开始问我一串安全相关的问题，安全掌握的不怎么好，面试官大概没有很多兴趣，就简单问了下css和一个逻辑题就完了：1、Web安全2、url是怎么加密的3、css的优先级4、逻辑题：给一个不规则的5L和6L的桶，装一个3升的水然后很显然就没有然后了，通过此次面试，觉得自己还是要多注意Web安全方面的知识，另外简历上处处都有可能问到，主要看面试官比较擅长哪方面，所以只要写上去都要有所准备。","categories":[],"tags":[],"keywords":[]},{"title":"easyui两个datagrid的问题","slug":"easyui两个datagrid的问题","date":"2017-04-11T11:11:39.000Z","updated":"2017-04-11T11:21:49.478Z","comments":true,"path":"2017/04/11/easyui两个datagrid的问题/","link":"","permalink":"https://aliceflaviawang.github.io/2017/04/11/easyui两个datagrid的问题/","excerpt":"","text":"问题easyui框架下，当一个页面出现两个datagrid，或者说出现两个table的时候，datagrid的某些属性会失效，比如说pagination分页会失效. 解决办法使用两个div将两个datagrid分开，但是使用两个div后，页面不能填充整个屏幕，所以解决两个datagrid分页失效的问题转化为了如何让div填充整个屏幕的问题。解决方法如下：123456789&lt;style&gt;html, body&#123;margin:0;padding:0;&#125;div&#123;width:100%;&#125;&lt;/style&gt;","categories":[],"tags":[],"keywords":[]},{"title":"easyui表格查询","slug":"easyui表格查询","date":"2017-04-10T13:09:22.000Z","updated":"2017-04-10T13:24:40.892Z","comments":true,"path":"2017/04/10/easyui表格查询/","link":"","permalink":"https://aliceflaviawang.github.io/2017/04/10/easyui表格查询/","excerpt":"","text":"easyui表格查询非常简单，比如说对于一个datagrid如下1234567891011121314151617181920212223242526272829303132333435363738&lt;div id=&quot;toolbar1&quot;&gt; &lt;div style=&quot;padding:3px&quot;&gt; &lt;span&gt;部门 ID:&lt;/span&gt; &lt;input id=&quot;deptId&quot; style=&quot;line-height:26px;border:1px solid #ccc&quot;&gt; --&gt; &lt;span&gt;部门名称:&lt;/span&gt; &lt;input id=&apos;dd&apos; &gt; &lt;span&gt;岗位类型:&lt;/span&gt; &lt;input id=&apos;dd3&apos; &gt; &lt;span&gt;设岗科室名称:&lt;/span&gt; &lt;input id=&apos;dd2&apos; style=&quot;line-height:22px;border:1px solid #ccc;border-radius:5px;&quot;&gt; &lt;span&gt;指导老师:&lt;/span&gt; &lt;input id=&apos;dd1&apos; style=&quot;line-height:22px;border:1px solid #ccc;border-radius:5px;&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;easyui-linkbutton&quot; plain=&quot;true&quot; iconCls=&quot;icon-search&quot; onclick=&quot;doFind()&quot;&gt;查询&lt;/a&gt; &lt;/div&gt; &lt;div&gt;&lt;table id=&quot;tt1&quot; title=&quot;岗位申请&quot; class=&quot;easyui-datagrid&quot; style=&quot;width:100%;height:auto;&quot; singleSelect=&quot;true&quot; data-options=&quot;fit:true&quot; rownumbers=&quot;true&quot; idField=&apos;deptId&apos; method=&apos;post&apos; toolbar=&apos;#toolbar1&apos;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th rowspan=&quot;2&quot; field=&quot;deptId&quot; width=&quot;5%&quot; align=&quot;center&quot;&gt;学院/部门ID&lt;/th&gt; &lt;th rowspan=&quot;2&quot; field=&quot;deptName&quot; width=&quot;6%&quot; align=&quot;center&quot;&gt;学院/部门名称&lt;/th&gt; &lt;th rowspan=&quot;2&quot; field=&quot;jobTime&quot; width=&quot;6%&quot; align=&quot;center&quot;&gt;岗位时间&lt;/th&gt; &lt;th rowspan=&quot;2&quot; field=&quot;teacherName&quot; width=&quot;6%&quot; align=&quot;center&quot;&gt;指导老师&lt;/th&gt; &lt;th rowspan=&quot;2&quot; field=&quot;telephone&quot; width=&quot;7%&quot; align=&quot;center&quot;&gt;指导老师电话&lt;/th&gt; &lt;th rowspan=&quot;2&quot; field=&quot;guideTrain&quot; width=&quot;10%&quot; align=&quot;center&quot;&gt;指导与培训体系&lt;/th&gt; &lt;th colspan=&quot;6&quot; align=&quot;center&quot; &gt;岗位要求&lt;/th&gt; &lt;th rowspan=&quot;2&quot; field=&quot;statusCodeName&quot; align=&quot;center&quot; width=&quot;5%&quot;&gt;审核状态&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th field=&quot;officeName&quot; align=&quot;center&quot; width=&quot;9%&quot;&gt;设岗科室名称&lt;/th&gt; &lt;th field=&quot;typeName&quot; align=&quot;center&quot; width=&quot;8%&quot;&gt;岗位类型&lt;/th&gt; &lt;th field=&quot;jobNum&quot; align=&quot;center&quot; width=&quot;8%&quot;&gt;设岗科室岗位数&lt;/th&gt; &lt;th field=&quot;jobWork&quot; align=&quot;center&quot; width=&quot;8%&quot;&gt;科室工作量&lt;/th&gt; &lt;th field=&quot;responsibility&quot; align=&quot;center&quot; width=&quot;10%&quot;&gt;科室工作职责&lt;/th&gt; &lt;th field=&quot;ability&quot; align=&quot;center&quot; width=&quot;12%&quot;&gt;科室岗位培养的综合素质&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;/table&gt; 查询部分的js代码12345678910111213function doFind()&#123;//获取查询条件 var val = $(&apos;#dd&apos;).combobox(&apos;getValue&apos;); var teacherName = $(&apos;#dd1&apos;).val(); var officeName = $(&apos;#dd2&apos;).val(); var type = $(&apos;#dd3&apos;).combobox(&apos;getValue&apos;);//根据查询条件在表格tt中load出来$(&quot;#tt1&quot;).datagrid(&apos;load&apos;,&#123;deptId:val,teacherName:teacherName,officeName:officeName,type:type&#125;) 但是发现这样有问题，如果某项没填，比如teacherName为空，那么将会在表格中查询teacherName为空的项，从而查不到结果。因此采取先判断查询项是否为空，才能得出正确结果。123456789101112131415161718192021222324252627function doFind()&#123; var val = $(&apos;#dd&apos;).combobox(&apos;getValues&apos;);//允许多选的情况，首先要在id为dd的combobox设置multipl为true if (val[0] == &apos;&apos;) &#123; val = val.slice(1) &#125; var teacherName = $(&apos;#dd1&apos;).val(); var officeName = $(&apos;#dd2&apos;).val(); var type = $(&apos;#dd3&apos;).combobox(&apos;getValue&apos;) var deptIds = val.join(&apos;,&apos;);//将每项用,分开 var query = &#123;&#125; //判断查询条件是否为空，将查询条件保存到对象中 if(teacherName)&#123; query.teacherName=teacherName; &#125; if(officeName)&#123; query.officeName=officeName; &#125; if(type)&#123; query.type=type; &#125; if(deptIds)&#123; query.deptId=deptIds; &#125; $(&apos;#tt1&apos;).datagrid(&apos;load&apos;, query); &#125;","categories":[],"tags":[],"keywords":[]},{"title":"easyui的dialog中插入下拉框","slug":"easyui的dialog中插入下拉框","date":"2017-04-10T12:53:55.000Z","updated":"2017-04-10T13:06:30.491Z","comments":true,"path":"2017/04/10/easyui的dialog中插入下拉框/","link":"","permalink":"https://aliceflaviawang.github.io/2017/04/10/easyui的dialog中插入下拉框/","excerpt":"","text":"easyui是一个集成了各种用户界面的插件的框架，特别使用各种表格的开发，能大大节省时间。在项目中遇到的问题时，下dialog中无法使用combobox生成下拉框，于是只能通过打开dialog时插入一个下拉框。1234567891011121314151617181920212223$(&apos;#fm_deptId&apos;).append(&apos;&lt;option&gt;bitem6&lt;/option&gt;&apos;); var depts = []; var query = &#123; rows: 200, page: 1 &#125; var newHtml = &apos;&apos;; $.ajax(&#123; type: &apos;POST&apos;, async: false, url: url_queryDept,//向接口请求下拉框数据 contentType: &quot;application/json; charset=utf-8&quot;, data: JSON.stringify(query), dataType: &apos;json&apos;, success: function(data) &#123; $.each(data.result, function(i, val) &#123; var temp = val.deptId + val.deptName;数据由一个id和name组成 var option = &apos;&lt;option value=&apos; + val.deptId + &apos;&gt;&apos; + temp + &apos;&lt;/option&gt;&apos;; newHtml = newHtml + option; &#125;) $(&apos;#fm_deptId&apos;)[0].innerHTML = newHtml; &#125;&#125;) 注：如果想要选中下拉框的某一个选项作为下拉框的默认值1$(&apos;#fm_deptId option[value=&apos;+ current_deptId+&apos;] &apos;).attr(&quot;selected&quot;,true);","categories":[],"tags":[],"keywords":[]},{"title":"win10永久激活方方法","slug":"win10永久激活方方法","date":"2017-04-10T12:44:58.000Z","updated":"2017-04-10T12:48:18.180Z","comments":true,"path":"2017/04/10/win10永久激活方方法/","link":"","permalink":"https://aliceflaviawang.github.io/2017/04/10/win10永久激活方方法/","excerpt":"","text":"今天提示win10许可证要过期了，于是尝试了各种工具，Microsoft Toolkit、HEU_KMS_Activator、KMS10_Crack2都不行，最后在网上找到了这个方法，一分钟不到就搞定了，分享一下网址https://jingyan.baidu.com/article/73c3ce282431dbe50343d9a9.html。","categories":[],"tags":[],"keywords":[]},{"title":"JS与jQuery显示和隐藏div","slug":"JS与jQuery显示和隐藏div","date":"2017-04-10T12:25:07.000Z","updated":"2017-04-10T12:39:10.062Z","comments":true,"path":"2017/04/10/JS与jQuery显示和隐藏div/","link":"","permalink":"https://aliceflaviawang.github.io/2017/04/10/JS与jQuery显示和隐藏div/","excerpt":"","text":"关于div隐藏很显示的问题，经常遇到，JS和jQuery有不同的处理方式。1&lt;div id=&quot;div&quot;&gt;&lt;/div&gt; JS方式123document.getElementById(&quot;div&quot;).style.display=&quot;block&quot;;document.getElementById(&quot;div&quot;).style.display=&quot;none&quot;;//不占用空间document.getElementById(&quot;div&quot;).style.display=&quot;hidden&quot;;//仍然占用空间 jQuery方式123456//通过css方法设置属性$(&quot;#div&quot;).css(&quot;diaplay&quot;,&quot;block&quot;);//给元素换class，提前将换的class样式定义好display属性$(&quot;#div&quot;).attr(&quot;class&quot;,&quot;blockclass&quot;);//通过attr方法$(&quot;#div&quot;).attr(&quot;display&quot;,&quot;block&quot;); 注：jQuery的css方法和attr方法的区别,css顾名思义就是标签自带的css属性，atrr只能取自己定义的属性，例如，如果div中没有diaplay这个属性的话，不能用过attr给其赋值，但是可以用css方法。","categories":[],"tags":[],"keywords":[]},{"title":"JS与jQuery清空输入框","slug":"JS与jQuery清空输入框","date":"2017-04-10T12:12:09.000Z","updated":"2017-04-10T12:16:41.820Z","comments":true,"path":"2017/04/10/JS与jQuery清空输入框/","link":"","permalink":"https://aliceflaviawang.github.io/2017/04/10/JS与jQuery清空输入框/","excerpt":"","text":"input输入框输入之后，再次输入的时候需要清空输入框。对于input输入框，JS与jQuery清空方式不同。1&lt;input id=&quot;input&quot; type=&quot;text&quot; name=&quot;input&quot;&gt; JS方式1document.getElementById(&quot;input&quot;).value=&quot;&quot;; jQuery方式1$(&quot;#input&quot;).val(&quot;&quot;);","categories":[],"tags":[],"keywords":[]},{"title":"java二维排序数组查找元素","slug":"java二维排序数组查找元素","date":"2017-04-09T13:09:30.000Z","updated":"2017-04-09T13:14:14.944Z","comments":true,"path":"2017/04/09/java二维排序数组查找元素/","link":"","permalink":"https://aliceflaviawang.github.io/2017/04/09/java二维排序数组查找元素/","excerpt":"","text":"题目描述在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 简单做法看到这个题目，如果不考虑数组元素的排序，只考虑能不能找到的话，非常简单。12345678910public boolean Find(int target, int [][] array) &#123; for(int i=0;i&lt;array.length;i++)&#123; for(int j=0;j&lt;array[0].length;j++)&#123; if(array[i][j]==target)&#123; return true; &#125; &#125; &#125; return false; &#125; 运行效果 题目的本质因为数组是排序的，所以考虑用二分查找，而查找不能盲目的查找，比如从第一个元素开始查找，如果比目标元素小，是往下找还是往右找呢，同里也不能从最后一个元素开始查找，可以从第一行最右边开始查找，如果比目标元素大就往左查找，反之往下查找，同理也可以从第一列最下边开始查找。举例从第一行最右边开始查找，代码如下：12345678910111213141516public boolean Find(int target, int [][] array) &#123; int row=0; int col=array[0].length-1; while(row&lt;array.length&amp;&amp;col&gt;=0)&#123; if(array[row][col]==target) &#123; return true; &#125; else if(array[row][col]&lt;target)&#123; row++; &#125; else&#123; col--; &#125; &#125; return false; &#125; 运行效果 完整代码1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.company;import java.util.Scanner;public class Solution &#123; public boolean Find(int target, int [][] array) &#123; int row=0; int col=array[0].length-1; while(row&lt;array.length&amp;&amp;col&gt;=0)&#123; if(array[row][col]==target) &#123; return true; &#125; else if(array[row][col]&lt;target)&#123; row++; &#125; else&#123; col--; &#125; &#125; return false; &#125; public static void main(String srgs[])&#123; Scanner s=new Scanner(System.in); System.out.println(&quot;请输入数组的行和列&quot;); int x=s.nextInt(); int y=s.nextInt(); int [][]arr=new int[x][y]; System.out.println(&quot;请输入数组元素&quot;); for(int i=0;i&lt;x;i++)&#123; for(int j=0;j&lt;y;j++)&#123; arr[i][j]=s.nextInt(); &#125; &#125; System.out.println(&quot;请输入你想查找的数：&quot;); int t=s.nextInt(); Solution a=new Solution(); if(a.Find(t,arr))&#123; System.out.println(&quot;数组&quot;+arr+&quot;中有数&quot;+t); &#125;else&#123; System.out.println(&quot;数组&quot;+arr+&quot;中没有数&quot;+t); &#125; &#125;&#125;","categories":[],"tags":[],"keywords":[]},{"title":"基于easyui项目学习的总结（一）","slug":"基于easyui项目学习的总结（一）","date":"2017-04-09T12:59:26.000Z","updated":"2017-04-09T13:02:35.130Z","comments":true,"path":"2017/04/09/基于easyui项目学习的总结（一）/","link":"","permalink":"https://aliceflaviawang.github.io/2017/04/09/基于easyui项目学习的总结（一）/","excerpt":"","text":"最近在做的项目，是基于easyui框架，项目进度非常紧张，并没有太多时间来总结，就用零碎时间一点点总结吧，主要是从网上及大神同学身上学到了很多。 easyui placeholder解决方案因为easyui经常用到table、textbox，因此会遇到需要用placeholder来提示输入内容的时候，但是easyui不支持h5的placeholder,因此，为了实现这个效果，在网上找到了解决方案。1、给input标签添加placeholder1&lt;input id=&quot;fm_jobTime&quot;&quot; name=&quot;jobTime&quot; class=&quot;easyui-textbox&quot; required=&quot;true&quot; label=&quot;岗位时间:&quot; style=&quot;width:100%&quot; placeholder=&quot;xxxx年x月-xxxx年x月&quot;&gt; 2、页面加载完毕的时候，将easyui生成的input标签的placeholder重置12345678910111213141516$(function()&#123;window.onload = inputPlaceholder();&#125;);/**easyui number placeholder*/function numberinputPlaceholder()&#123;$(&quot;.easyui-textbox&quot;).each(function(i)&#123;var span = $(this).siblings(&quot;span&quot;)[0];var targetInput = $(span).find(&quot;input:first&quot;);if(targetInput)&#123;$(targetInput).attr(&quot;placeholder&quot;, $(this).attr(&quot;placeholder&quot;));&#125;&#125;);&#125;","categories":[],"tags":[],"keywords":[]},{"title":"git bash命令上传下载代代码","slug":"git bash命令上传下载代代码","date":"2017-04-08T12:37:28.000Z","updated":"2017-04-08T12:38:13.134Z","comments":true,"path":"2017/04/08/git bash命令上传下载代代码/","link":"","permalink":"https://aliceflaviawang.github.io/2017/04/08/git bash命令上传下载代代码/","excerpt":"","text":"git bash是window下的命令行工具，在官网上下载git for windows安装即可。如何通过git bash将代码传到git上和下载到本地的呢remote 上传到git1、安装完成后，在命令行输入下面的代码进行配置12$ git config --global user.name &quot;your real name&quot;$ git config --global user.email &quot;your eamil address&quot; 注：”your real name“是你的真实姓名，”your eamil address”是你的注册github的邮箱2、在主用户目录下，输入下面的代码1$ ssh-keygen -t rsa -C &quot;your eamil address 然后在自己电脑的C盘下找到.ssh文件夹，用记事本打开里面的id_rsa.pub,复制里面的内容。登陆Github，在账户设置里找到SSH keys页面，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容。3、利用”cd”命令将路径切换到你要上传的代码所在的文件夹下面（或者打开你要上传的代码的文件夹，右键git bash here）,输入一下代码：123$git init //把目录变成git可以管理的仓库$git add . //add后面加&quot;.&quot;表示上传所以的代码，如果想上传指定的，只需要把&quot;.&quot;改成文件名即可$git commit -m &quot;你对文件的描述&quot; //提交你对文件的描述 4、在本地仓库目录下输入下面命令将本地仓库和远程仓库关联（如果已经上传过代码了，可以直接跳到第6步）1$git remote add orgin git@github.com:yonghuming/kuming.git origin可是换成你想要的任何名字，但是要记住这个源名字（与第6步的origin对应，我每次都是新起一个名字因为经常提示origin已经存在了）5、输入如下代码，将自己的文件上传1$git push -u origin master 其实github上每次创建一个新的仓库的时候，都有命令提示 从git上下载$git clone git@github.com:yonghuming/kuming.git 更新$git pull origin master 经常遇到的问题error:src refspec master does not match any原因：本地版本库为空，空目录不能提交","categories":[],"tags":[],"keywords":[]},{"title":"Github Pages+Hexo搭建教程","slug":"Github-Pages-Hexo搭建教程","date":"2017-04-04T13:44:17.000Z","updated":"2017-04-07T03:11:41.888Z","comments":true,"path":"2017/04/04/Github-Pages-Hexo搭建教程/","link":"","permalink":"https://aliceflaviawang.github.io/2017/04/04/Github-Pages-Hexo搭建教程/","excerpt":"","text":"前言越来越感觉世界真是太大了，每天学习很多东西，希望能够记录下来自己学习的点点滴滴，也能分享给更多的人，因此搭建了这个博客。关于为什么选择github pages而不是wordpress，因为github pages有300M免费空间，资料自己管理，保存可靠，而且现在的项目开发，团队协作都需要用到github，通过搭建博客也更好的学习了如何使用github。 github安装在官网https://git-for-windows.github.io/上下载git，安装比较简单。访问http://www.github.com/，注册username和邮箱，注册过程也比较简单。 使用GitHub Pages建立博客github建立仓库登陆系统后，在github首页，点击页面右下角New Repository填写项目信息：project name:aliceflaviawang.github.io注：GitHub Pages的Repository名字是特定的，比如我的Github账号是aliceflaviawang,那么我的GitHub Pages Repository名字就是aliceflaviawang.github.io。点击Create Reposity完成创建。进入创建的仓库，打开Settings选择一个主题选择完毕，回到仓库页面，发现多了两个文件，_config.yml是配置文件。此时打开aliceflaviawang.github.io，可以看到index.md显示的内容。 安装node.js参考教程http://www.runoob.com/nodejs/nodejs-install-setup.html，非常简单。 用Hexo克隆主题Hexo介绍Hexo是一个简单、快速、强大的博客发布工具，支持Markdown格式 安装Hexo打开git bash或者cmd,进入node文件夹，安装hexo注：-g是全局安装的意思 部署Hexo在我的电脑中建立一个名叫Hexo的文件夹，然后在此文件夹中右键打开Git Bash.Hexo会自动在目标文件夹建立网站所需要的所有文件。 复制主题建立Hexo之后就可以复制主题了，网上有很多好看的主题可以自己选择。此处选择的是wuchong的主题。 启用主题修改Hexo目录下的_config.yml,将theme属性设置为jacman。 更新主题 本地查看调试 hexo g是生成，hexo d是部署，可是先后使用或者直接使用组合命令hexo d -g，发现Hexo文件夹生成了public文件。 查看搭建效果浏览器输入http://localhost:4000,查看搭建效果。如果localhost:4000无法访问，是因为你的电脑端口被占用了，而hexo默认的端口是4000，可以通过修改端口来解决这个问题。 比如将端口改成4040现在就可以看到效果了 Hexo设置网站搭建完成之后，可以根据需要对Hexo生产的网站进行设置，设置是修改_config.yml，我复制一下别人的设置，可以参考一下。 Hexo Configuration123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: XTong notessubtitle: Live beautifully, dream passionately, love completelydescription: You Never Know Who You Areauthor: X T Wlanguage: zh-Hanstimezone: Asia/Shanghai# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: https://aliceflaviawang.github.io/root: /permalink: :year/:month/:day/:title/permalink_defaults:# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: false tab_replace:# Category &amp; Tagdefault_category: othercategory_map:tag_map:# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 8pagination_dir: page# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: jacman# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/aliceflaviawang/aliceflaviawang.github.io.git branch: masterfeed: type: atom path: atom.xml limit: 20 hub: baidusitemap: path: baidusitemap.xmlsearch: path: search.xml field: post format: html limit: 10000 注：与gitgub pages建立关联（非常关键） 发表新文章使用hexo发表文章1$ hexo n #写文章 写完之后，推送到服务器上，执行12$ hexo g #生成$ hexo d #部署 或者hexo d -g 或者使用markdown来写文章常用命令1$ hexo new post &quot;postname&quot; #新建文章 注：如果 $ hexo d命令提示ERROR Deployer not found: git，解决办法 $ npm install hexo-deployer-git –save,然后再重新生成部署。hexo d实际上就是将博客部署到gitgub上去。hexo new post执行后会在项目source_posts中生成postname.md文件，用编辑器打开即可编辑，也可以直接在source_posts中新建一个md文件。写完之后，部署到服务器上12$ hexo g$ hexo d 打开aliceflaviawang.github.io,可以看到第一篇博客了 域名其实搭建博客不一定需要域名，当然如果你嫌github.io不够高大上，当然可以买个域名来装x.很多地方可以买域名，不只是godaddy，像腾讯云、万网…很多，我在godaddy中文网站上上买了aliceflaviawang.com这个网站，因为中文网站指引比较明确，就不详说了。 将域名与Github Pages空间绑定GitHub pages设置方法一：在Repository的根目录下面，新建一个名为CNAME的文本文件，里面写入你想要绑定的域名，比如aliceflaviawang.com方法二：点击setting，在custom domain下面天上你想要绑定的域名，点击save，会自动生成一个CNAME文件，里面保存的就是你的域名了。 DNS设置用DNSpod，我在腾讯云上注册了下，注意必须实名认证了才让你解析域名，由于我的域名已经退了，就直接使用别人的图片 添加域名，如下图设置其中A的两条记录指向的ip地址是github pages提供的地址，这个记录是云解析解析出来的结果，云解析会提示去godaddy修改dns地址。我采用的方式是自己添加，首先ping http://aliceflaviawang.github.io的地址，获得A的地址添加，然后添加www域名地址。 godaddy修改DNS点击我的账户里–&gt;点击域名–&gt;将godaddy的NameServer更改成f1g1ns1.dnspod.net和f1g1ns2.dnspod.net （域名解析后提示）。 访问博客现在就不需要访问aliceflaviawang.github.io了，可以直接访问aliceflaviawang.com注：如果访问的时候发现页面是github首页，说明需要清除一下缓存了。 后记本博客主要参考的是http://blog.sina.com.cn/s/blog_617ccc0c0101h84p.html。","categories":[],"tags":[],"keywords":[]},{"title":"我的第一篇博客","slug":"我的第一篇博客","date":"2017-04-04T13:28:41.000Z","updated":"2017-04-04T13:42:27.261Z","comments":true,"path":"2017/04/04/我的第一篇博客/","link":"","permalink":"https://aliceflaviawang.github.io/2017/04/04/我的第一篇博客/","excerpt":"","text":"感想清明节放假的最后一天，终于搭建了这个博客，心情还是比较激动的，希望以后能够通过博客这种方式记录下每天的进步！","categories":[],"tags":[],"keywords":[]}]}