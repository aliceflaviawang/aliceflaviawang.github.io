{"meta":{"title":"笑呵呵","subtitle":"We were moving mountains long before we knew we could","description":"You Never Know Who You Can Be","author":"Alice","url":"https://aliceflaviawang.github.io"},"pages":[{"title":"about","date":"2017-04-17T13:23:23.000Z","updated":"2017-04-17T13:23:23.051Z","comments":true,"path":"about/index.html","permalink":"https://aliceflaviawang.github.io/about/index.html","excerpt":"","text":""}],"posts":[{"title":"一些类似于null==0之类的判断","slug":"一些类似于null-0之类的判断","date":"2017-08-17T02:35:10.000Z","updated":"2017-08-17T03:10:19.725Z","comments":true,"path":"2017/08/17/一些类似于null-0之类的判断/","link":"","permalink":"https://aliceflaviawang.github.io/2017/08/17/一些类似于null-0之类的判断/","excerpt":"","text":"null==0 //flasenull&gt;=0（null&lt;=0） //true原因：关系运算符和相等运算符并不是一个类别的，关系运算符在设计上总是尝试转为一个number，而相等运算符并没有这方面的考虑。更进一步：关系运算符，是先算出原始值，如果两个都是String类型进行字符串比较，否则转换成Number，之后比较；相等运算符只在两数分别是String和Number类型或者其中之一为Boolean进行数字转换外，其他类型都不进行转换成数字。 所以：“”==0 //trueflase==0 //trueundefined==0 //flase ,Number(undefinded)是NaN []==![] //true这个实际上也是涉及==运算的规则，来个详细的首先[]==![]匹配的是规则7，会递归调用[]==ToNumber(flase)进行比较（！[]是false），9.3节定义了ToNumber原语，ToNumber(false)等于0，于是比较[]==0；此时采用规则9，比较ToPrimitive([])==0,ToPrimitive默认调用ToString方法，于是ToPrimitive([])等于””；现在就是比较””==0,按照规则5，比较ToNumber(“”)==0,ToNumber(“”)的结果是0，所以结果为true。","categories":[],"tags":[],"keywords":[]},{"title":"JS的堆栈及深浅拷贝","slug":"JS的堆栈及深浅拷贝","date":"2017-08-14T02:39:57.000Z","updated":"2017-08-14T08:25:58.800Z","comments":true,"path":"2017/08/14/JS的堆栈及深浅拷贝/","link":"","permalink":"https://aliceflaviawang.github.io/2017/08/14/JS的堆栈及深浅拷贝/","excerpt":"","text":"堆栈堆栈是两种数据结构，只能在一端对数据项进行插入和删除。 栈：由操作系统自动分配释放，存放函数的参数值，局部变量的值等。 堆：动态分配的空间一般由程序员分配释放，若程序员不释放，则程序释放时可能由OS回收。 JS中的堆栈与基本类型、引用类型js中的数据类型分为两种 ： 基本类型：undefined,bool,number,string,null，这5中基本数据类型可以直接访问，它们是按照值进行分配的，存放在栈内存中的简单数据段，数据大小确定，内存空间大小可以分配。 引用类型：存放在堆中的对象，变量实际保存的是一个指针，这个指针指向另一个位置。 浅拷贝基本类型的拷贝只是在内存中又开辟了新的空间，和它的父元素（称被拷贝的对象为父元素）互不相干，因此深浅拷贝是相对于引用类型的，以便于对引用类型父对象的保存。12345678910111213141516171819202122var father1=&#123;name:&apos;shanghai&apos;,age:1000,job:[&apos;teacher&apos;,cook]&#125;;//浅拷贝函数function copy(obj)&#123; var childs=&#123;&#125;; for(var key in obj)&#123; childs[key]=obj[key]; &#125; return childs;&#125;var child1=copy(father1);console.log(child1); //&#123;name:&apos;shanghai&apos;,age:1000,job:Array(2)&#125;console.log(typeof child1); //object//改变子对象的name属性，发现对父对象的name没有影响child1.name=&apos;chengdu&apos;;console.log(father1); //&#123;name:&apos;shanghai&apos;,age:1000,job:Array(2)&#125;console.log(child1); //&#123;name:&apos;chengdu&apos;,age:1000,job:Array(2)&#125;//注意：这次改变子对象的job属性也就是改变数组，发现对都对象的job受到了影响child1.job.push(&apos;programmer&apos;);console.log(father1) ;//&#123;name:&apos;shanghai&apos;,age:1000,job:[&apos;teacher&apos;,&apos;cook&apos;,&apos;programmer&apos;]&#125;console.log(child1) ;//&#123;name:&apos;chengdu&apos;,age:1000,job:[&apos;teacher&apos;,&apos;cook&apos;,&apos;programmer&apos;]&#125; 由上，浅拷贝的时候，子对象数组改变时父对象也跟着改变，说明子对象和父对象在浅拷贝的时候指向同一个内存的数组。 如果想让子对象拷贝和父对象没有关联，就必须使用深度拷贝。 深拷贝深拷贝就是父对象拷贝到子对象上，而且两者的内存和以后的操作都互不影响。1234567891011121314151617181920212223242526272829function deepCopy(obj)&#123; var o; switch(typeof obj)&#123; case &apos;undefined&apos;:break; case &apos;string&apos;:o=obj+&apos;&apos;;break; case &apos;number&apos;:o=obj-0;break; case &apos;boolean&apos;:o=obj;break; case &apos;object&apos;: if(obj===null)&#123; o=null; &#125;else&#123; if(obj instanceof Array)&#123; o =[]; for(var i=0,len=obj.length;i&lt;len;i++)&#123; o.push(deepCopy(obj[i])); &#125; &#125;else&#123; o=&#123;&#125;; for(var k in obj)&#123; o[k]=deepCopy(obj[k]); &#125; &#125; &#125; break; default: o=obj; break; &#125; return o;&#125;","categories":[],"tags":[],"keywords":[]},{"title":"JS异步编程","slug":"JS异步编程","date":"2017-08-14T01:51:34.000Z","updated":"2017-08-15T06:24:55.443Z","comments":true,"path":"2017/08/14/JS异步编程/","link":"","permalink":"https://aliceflaviawang.github.io/2017/08/14/JS异步编程/","excerpt":"","text":"ES6增加了Promise和Generator等解决办法。大致整理一下到ES6为止的JS异步解决方法及其优缺点。 setTimeout常用于：定时器，动画效果用法：setTimeout(func|code,delay) 缺点：不精准。比如，通过setTimeout设定了一个任务在10毫秒之后执行，但是在9毫秒之后，有一个任务占用了5毫秒的CPU时间片，再轮到定时器执行时，时间就已经过期了4毫秒。 事件监听任务执行不取决于代码的顺序，而取决于某个事件是否发生。用法：f1.on(‘done’,f2)优点：比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以去耦合，有利于实现模块化。缺点：整个程序都要变成事件驱动型，运行流程会变得不是很清晰。 回调函数js对异步编程的实现就是回调函数。所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，直接调用这个函数。 回调函数是实现JS异步的一种方法，并不是说回调函数就是异步的。只是我们用的大部分回调函数都是用于异步。 Promise对象Promise原理状态机一个Promise可以理解为一个状态机1234567891011121314const PENDING = 0const FULFILLED = 1const REJECTED = 2function Promise ()&#123; // 存储该 Promise 的状态信息 let state = PENDING // 存储 FULFILLED 或 REJECTED 时带来的数据 let value = null // 存储 then 或 done 时调用的成功或失败回调 var handlers = []&#125; 状态迁移指定状态机的状态后，可以实现基本的状态迁移功能，即fullfill和reject这两个用于改变状态的函数：12345678910111213141516171819202122232425const PEDNDING=0const FULFILLED=1const REJECTED=2function Promise()&#123; //存储Promise的状态信息 let state=PENDING //存储FULFILLED和REJECTED时带来的数据 let value=null //存储then或done时调用的成功或失败回调 let handlers=[] funtion fulfill(result)&#123; state=FULFILLED value=result &#125; function reject(error)&#123; state=REJECTED value=error &#125;&#125; 在此基础上需要实现一种更高级的状态迁移方式，这就是resolve123456789101112131415161718192021222324252627282930313233343536const PENDING = 0const FULFILLED = 1const REJECTED = 2function Promise ()&#123; // 存储该 Promise 的状态信息 let state = PENDING // 存储 FULFILLED 或 REJECTED 时带来的数据 let value = null // 存储 then 或 done 时调用的成功或失败回调 let handlers = [] function fulfill (result)&#123; state = FULFILLED value = result &#125; function reject (error)&#123; state = REJECTED value = error &#125; function resolve(result)&#123; try&#123; let then=getThen(result) if(then) &#123; //递归resolve，待解析的Promise ,doResolve(then.bind(result),resolve,reject) return &#125; fulfill(result) &#125;catch(e)&#123; reject(e) &#125; &#125; resolve既可以接收一个Promise，也可以接收一个基本类型。当resolve一个Promise时，就是用doResolve辅助函数来执行这个Promise并等待其完成。通过resolve隐藏了底层的fulfill接口。在这个过程中用到的辅助函数有：1234567891011121314151617181920212223242526272829303132/**检查一个值是否为Promise，若为Promise则返回该Promise的then方法*/function getThen(value)&#123; let t=typeof value if(value&amp;&amp;(t===&apos;object&apos;||t===&apos;function&apos;))&#123; const then=value.then //可能需要更负责的thenable判断 if(typeof then===&apos;function&apos;) return then &#125; return null &#125;/**传入一个需被resolve的函数，该函数可能存在不确定的行为*确保onFulfilled和onRejected只会被调用一次*在此不保证该函数一定会被异步执行*/function doResolve(fn,onFulfilled,onRejected)&#123; let done=false try&#123; fn(function(value)&#123; done=true //执行由resolve传入的resolve回调 onFulfilled(value) function(reason)&#123; if(done) return done=true onRejected(reason) &#125; &#125;) &#125;&#125; done接口到此形成了一个完整的状态机，但仍没有暴露一个合适的方法来观察其状态变更。最终目标是实现then，但是由于事先done接口容易一下，因此先实现done。下面的例子是要实现promise.done(onFulfilled,onRejected)，使得： onFulfilled与onRejected二者只有一个被调用 该接口只会被调用一次 该接口总是被异步执行 调用done的执行时机与调用时Promise是否已reoslevd无关123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869const PENDING = 0const FULFILLED = 1const REJECTED = 2function Promise (fn)&#123; // 存储该 Promise 的状态信息 let state = PENDING // 存储 FULFILLED 或 REJECTED 时带来的数据 let value = null // 存储 then 或 done 时调用的成功或失败回调 let handlers = [] function fulfill (result)&#123; state = FULFILLED handlers.forEach(handle) handlers = null &#125; function reject (error)&#123; state = REJECTED value = error handlers.forEach(handle) handlers = null &#125; function resolve (result)&#123; try &#123; let then = getThen(result) if (then) &#123; // 递归 resolve 待解析的 Promise doResolve(then.bind(result), resolve, reject) return &#125; fulfill(result) &#125; catch (e) &#123; reject(e) &#125; &#125; // 保证 done 中回调的执行 function handle (handler)&#123; if (state === PENDING) &#123; handlers.push(handler) &#125; else &#123; if (state === FULFILLED &amp;&amp; typeof handler.onFulfilled === &apos;function&apos;) &#123; handler.onFulfilled(value) &#125; if (state === REJECTED &amp;&amp; typeof handler.onRejected === &apos;function&apos;) &#123; handler.onRejected(value) &#125; &#125; &#125; this.done = function (onFulfilled, onRejected)&#123; // 保证 done 总是异步执行 setTimeout(function ()&#123; handle(&#123; onFulfilled: onFulfilled, onRejected: onRejected &#125;) &#125;, 0) &#125; doResolve(fn, resolve, reject)&#125; then方法12345678910111213141516171819202122this.then = function (onFulfilled, onRejected)&#123; const _this = this return new Promise(function (resolve, reject)&#123; return _this.done(function (result)&#123; if (typeof onFulfilled === &apos;function&apos;) &#123; try &#123; return resolve(onFulfilled(result)) &#125; catch (ex) &#123; return reject(ex) &#125; &#125; else return resolve(result) &#125;, function (error)&#123; if (typeof onRejected === &apos;function&apos;) &#123; try &#123; return resolve(onRejected(error)) &#125; catch (ex) &#123; return reject(ex) &#125; &#125; else return reject(error) &#125;) &#125;)&#125;","categories":[],"tags":[],"keywords":[]},{"title":"JS严格模式","slug":"JS严格模式","date":"2017-08-09T13:53:55.000Z","updated":"2017-08-09T14:56:07.914Z","comments":true,"path":"2017/08/09/JS严格模式/","link":"","permalink":"https://aliceflaviawang.github.io/2017/08/09/JS严格模式/","excerpt":"","text":"概述除了正常模式，ES5添加了第二种运行模式：“严格模式”。设立严格模式的目的： 消除JS语法的一些不合理、不严谨之处，减少一些怪异行为 消除代码运行的一些不安全之处，保证代码运行的安全 提供编译器效率，增加运行速度 为未来新版本的JS做好铺垫进入标志1&quot;use strict&quot; 如何调用针对单个脚本文件将”use strict”放在脚本文件的第一行，则整个脚本都将以“严格模式”运行，如果这行语句不在第一行，则无效，整个脚本以“正常模式”运行。1234567&lt;script&gt; &quot;use strict&quot; console.log(&quot;这是严格模式&quot;)&lt;/script&gt;&lt;script&gt; console.log(&quot;这是正常模式&quot;)&lt;/script&gt; 针对单个函数将”use strict”放在函数体的第一行，则整个函数以“严格模式”运行。12345678function strict()&#123; &quot;use strict&quot;; return &quot;这是严格模式。&quot;; &#125; function notStrict() &#123; return &quot;这是正常模式。&quot;; &#125; 脚本文件的变通写法第一种调用方法不利于文件合并，所以更好的做法是，借用第二种方法，将整个脚本文件放在一个立即执行的匿名函数之中。1234567(function ()&#123; &quot;use strict&quot;; // some code here &#125;)(); 语法和行为改变严格模式对JS的语法和行为，都做了一些改变。 1.全局变量显示声明在正常模式中，如果一个变量没有声明就赋值，默认是全局变量，严格模式禁止这种用法，全局变量必须显式声明，否则报错。 2.静态绑定JS允许“动态绑定”，即某些属性和方法到底属于哪个对象，不是在编译时确定，而是在运行时确定。严格模式对动态绑定做了一些限制，某些情况下，只允许静态绑定。也就是说，属性和方法到底归属于哪个对象，在编译阶段就确定，这样做有利于编译效率的提供，也使得代码更易读。具体涉及以下方面： 禁止使用with语句 因为with语句在编译时就无法确定，属性到底归属哪个对象 创设eval作用域 正常模式下，JS语言有两种变量作用域：全局作用域和函数作用域。严格模式下创设了第三种作用域：eval作用域。正常模式下，eval作用域，取决于它处于全局作用域，还是处于函数作用域。严格模式下，eval语句本身就是一个作用域，不能再生成全局变量了，它生成的变量只能用于eval内部。1234&quot;use strict&quot;var x=2;console.info(eval(&quot;var x=5;x&quot;)); //5console.info(x); //2 如果将var x=2去掉，console.info(x)将报错。 3.增加安全措施 禁止this关键字指向全局对象12345function f()&#123; &quot;use strict&quot; this.a=1;&#125;f();//报错，this未定义 执行f()时，this指向全局对象，严格模式下报错，使用构造函数var aa=new f()；aa.a则正常，此时this指向aa。 禁止在函数内部遍历栈123456function f1()&#123; &quot;use strict&quot; f1.caller;//报错 f1.arguments;//报错&#125;f1(); 4.禁止删除变量严格模式下无法删除变量。只有configurable为true时才能被删除。123456789101112&quot;use strict&quot;; var x; delete x; // 语法错误 var o = Object.create(null, &#123;&apos;x&apos;: &#123; value: 1, configurable: true &#125;&#125;); delete o.x; // 删除成功 5.显式报错正常模式下，对一个对象的只读属性进行赋值，不会报错，只会默默失败，严格模式下，将报错。1234567&quot;use strict&quot;; var o = &#123;&#125;; Object.defineProperty(o, &quot;v&quot;, &#123; value: 1, writable: false &#125;); o.v = 2; // 报错 6.重名错误 对象不能有重名的属性(经测试谷歌浏览不会报错，但是IE浏览器会报错）正常模式下，如果对象有多个重名的属性，最后赋值的那个属性会覆盖前面的值。严格模式下会报错。123456&quot;use strict&quot;; var o = &#123; p: 1, p: 2 &#125;; // 语法错误 2.函数不能有重名的参数1234567&quot;use strict&quot;; function f(a, a, b) &#123; // 语法错误 return ; &#125; 7.禁止八进制表示法正常模式下，整数的第一位如果是0，表示是八进制数，比如0100等于十进制的64。严格模式禁止这种表达方式，整数第一位为0会报错。 8.arguments对象的限制1.不允许对arguments赋值2.不再追踪参数的变化123456789101112131415161718192021function f(a) &#123; a = 2; return [a, arguments[0]]; &#125; f(1); // 正常模式为[2,2] function f(a) &#123; &quot;use strict&quot;; a = 2; return [a, arguments[0]]; &#125; f(1); // 严格模式为[2,1] 禁止使用arguments.callee这意味着，无法在匿名函数内部调用自身了1234 &quot;use strict&quot;; var f = function() &#123; return arguments.callee; &#125;; f(); // 报错 9.函数声明必须在顶层(经测试IE10以上及谷歌浏览器取消了这个)JS的新版本引入块级作用域，为了与新版本接轨，严格模式只允许在全局作用域或函数作用域的顶层声明函数。也就是说，不允许在非函数的代码块内声明函数。1234567&quot;use strict&quot;; if (true) &#123; function f() &#123; &#125; // IE10及以下报错 &#125; 10.保留字为了向将来Javascript的新版本过渡，严格模式新增了一些保留字：implements, interface, let, package, private, protected, public, static, yield。 使用这些词作为变量名将会报错。 此外，ECMAscript第五版本身还规定了另一些保留字（class, enum, export, extends, import, super），以及各大浏览器自行增加的const保留字，也是不能作为变量名的。","categories":[],"tags":[],"keywords":[]},{"title":"箭头函数","slug":"箭头函数","date":"2017-08-09T12:10:13.000Z","updated":"2017-08-09T13:47:57.637Z","comments":true,"path":"2017/08/09/箭头函数/","link":"","permalink":"https://aliceflaviawang.github.io/2017/08/09/箭头函数/","excerpt":"","text":"基本用法ES6允许使用“箭头”定义函数1var f= v =&gt; v; 上面的箭头函数等同于：123var f = function(v)&#123; return v;&#125; 如果箭头函数不需要参数或者需要多个参数，就使用一个圆括号代表参数部分。1var sum=(num1,num2) =&gt; num1+num2; 如果箭头函数的代码部门多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。1var sum=(num1,num2) =&gt; &#123;return num1+num2; &#125; 由于大括号被解释为代码块，如果箭头函数直接返回一个对象，必须在对象外面加上括号。1var getTempItem =id =&gt; (&#123;id:id,name:&quot;Temp&quot;&#125;) 箭头函数可以与变量结构结合使用1const full=(&#123;first,last&#125;) =&gt; first+&apos; &apos;+last; 使用注意点 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象 不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误 不可以使用arguments对象，该对象在函数体内不存在，如果要用，可以用Rest参数代替 不可以使用yield命令，因为箭头函数不能用作Generator函数 this指向固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正因为它没有this，所以也就不能用作构造函数。 除了this以外，以下三个变量在箭头函数中也是不存在的，指向外层函数的对应变量：arguments、super、new.target。1234567function foo()&#123; setTimeout(() =&gt; &#123; console.log(&apos;args:&apos;, arguments); &#125;, 100);&#125;foo(2,4,6,8)//[2,4,6,8] 注意此处箭头函数内部的变量arguments，是函数foo的arguments变量，因为foo是普通函数，具有arguments。如果将function foo(){}换成var foo=()=&gt;{}，将会报arguments is undefined的错。使用rest参数代替arguments：123456var foo=(...numbers)=&gt;&#123;setTimeout(() =&gt; &#123; console.log(&apos;args:&apos;, numbers); &#125;, 100);&#125;foo(2,4,6,8) 另外，由于箭头函数没有自己的this，所以当然也就不能用call,apply,bind这些方法改变this的指向。123456(function()&#123; return [ (()=&gt;this.x).bind(&#123;x:&apos;inner&apos;&#125;)() ]&#125;).call(&#123;x:&apos;outer&apos;&#125;)//outer 箭头函数没有自己的this，所以bind方法无效，内部的this指向外部的this，相当于：123456var x=&apos;outer&apos;;(function() &#123; return [ (() =&gt; this.x).bind(&#123; x: &apos;inner&apos; &#125;)() ]; &#125;)(); 函数绑定箭头函数可以绑定this对象，大大减少了显式绑定this对象的写法（call、bind、apply）。但是很多场合不适用，于是ES7提出了”函数绑定”运算符来取代call、bind、apply调用。函数绑定运算符是并排两个双冒号(::)，双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（this对象），绑定到右边的函数上面。1234567foo::bar//等同于bar.bind(foo)foo:bar(...arguments)//等同于bar.apply(foo,arguments) 如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定到该对象上面。123let log=::console.log//等同于var log=console.log.bind(console)","categories":[],"tags":[],"keywords":[]},{"title":"ES6箭头函数的this与普通函数的this对比","slug":"ES6箭头函数的this与普通函数的this对比","date":"2017-08-09T03:16:19.000Z","updated":"2017-08-09T09:26:32.764Z","comments":true,"path":"2017/08/09/ES6箭头函数的this与普通函数的this对比/","link":"","permalink":"https://aliceflaviawang.github.io/2017/08/09/ES6箭头函数的this与普通函数的this对比/","excerpt":"","text":"普通函数中的this有以下几种情况 this总是代表它的直接调用者，例如obj.func，那么func中的this就是obj 在默认情况（非严格模式下，未使用’use strict’），没找到直接调用者，则this指向window 1234567891011var obj=&#123; func:function()&#123;&#125;, say:function()&#123; var that=this; setTimeout(function()&#123; console.log(this) //window that.func() &#125;); &#125;&#125;obj.say(); 匿名函数、定时器中的函数，由于没有默认的宿主对象，所以默认指向window。如果想使用这个对象的引用，通常是使用一个变量提前把正确的this引用保存起来，我们通常使用that=this或者_this=this来保存我们需要的this指针。12345678910111213window.val=1;var obj=&#123; val:2, dbl:function()&#123; this.val*=2; val*=2; console.log(val); console.log(this.val); &#125;&#125;;obj.dbl();var func=obj.dbl;func(); 结果：2 4 8 8val变量在没有指定对象前缀，默认从函数中找，找不到则从window中找全局变量，即val=2就是window.val=2,this.val默认指的是obj.val(因为dbl()第一次被obj直接调用)。func()没有任何前缀，类似于全局函数，即window.func调用，所以第二次调用的时候，this指的是window，val指的是window.val，obj.dbl()使得window.val的结果变成了2，this.val和val都是指向全局的val，因此this.val2使得全局的val变成了4，再val2使其变为8，最后val和this.val就都等于8。 在严格模式下，没有直接调用者的函数中的this是undefined 12345function test()&#123; &apos;use strict&apos;; console.log(this);&#125;test(); //undefined 使用call、apply、bind绑定的，this指向绑定的对象 箭头函数中的this默认指向在定义它时它所处的对象，而不是执行时的对象，定义它的时候，可能环境是window。箭头函数根本就没有绑定自己的this，实际上箭头函数中调用this是沿着作用域链向上寻找，找到最近的一个this拿来使用。12345678var obj=&#123; say:function()&#123; setTimeout(() =&gt; &#123; console.log(this); &#125;) &#125;&#125;obj.say(); //obj 此时this是定义它的对象，最近的this就是obj而不是window。1234567891011var obj=&#123; say:function()&#123; var f1=() =&gt; &#123; console.log(this); //obj setTimeout(() =&gt; &#123; console.log(this); //obj &#125;) &#125; f1(); &#125;&#125; f1最近的作用域的this就是obj，不管f1有几层嵌套，都是obj。123456789101112var obj=&#123; say:function()&#123; var f1=function()&#123; console.log(this); //window setTimeout(() =&gt; &#123; console.log(this); //window &#125;) &#125; f1(); &#125;&#125;obj.say(); 第一个this:f1调用时，this指向window对象第二个this：找到最近的作用域的this即f1的this，f1的this指向window","categories":[],"tags":[],"keywords":[]},{"title":"DNS解析","slug":"DNS解析","date":"2017-08-01T14:03:18.000Z","updated":"2017-08-01T14:27:51.147Z","comments":true,"path":"2017/08/01/DNS解析/","link":"","permalink":"https://aliceflaviawang.github.io/2017/08/01/DNS解析/","excerpt":"","text":"由来：IP地址由21位二进制数字组成，用户与因特网上某台主机通信，32位的IP地址显然很难记忆，因此使用比较容易记忆的主机名字（域名）。但是域名长度不固定，机器处理比较困难，而IP地址长度固定，因此处理数据报时用的IP地址。 解析过程：当某一个应用需要把主机名解析为IP地址时，该应用进程就调用解析程序，并成为DNS的一个客户，把待解析的域名放在DNS请求报文中，以UDP用户数据报方式发送给本地域名服务器。本地域名服务器在查找域名后，把对应的IP地址放在回答报文中返回。应用程序获得目的主机的IP地址后即可进行通信。 具体的解析过程： 主机向本地域名服务器的查询一般都是采用递归查询。所谓递归查询是:如果主机所询问的本地域名服务器不知道被查询的域名的IP地址，那么本地域名服务器就以DNS客户的身份，向其他根域名服务器继续发出查询请求报文（即替主机继续查询），而不是让主机自己进行下一步查询。因此，递归查询返回的查询结果或者是所要查询的IP地址，或者是报错，表示无法查询到所需的IP地址。 本地域名服务器向根域名服务器的查询是迭代查询。迭代查询：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的IP地址，要么告诉本地服务器下一步向哪个域名服务器进行查询。然后本地服务器进行后续查询。根域名服务器通常是把自己知道的顶级域名服务器的IP地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询。","categories":[],"tags":[],"keywords":[]},{"title":"for...of的优势","slug":"for-of的优势","date":"2017-08-01T06:51:45.000Z","updated":"2017-08-01T07:18:12.511Z","comments":true,"path":"2017/08/01/for-of的优势/","link":"","permalink":"https://aliceflaviawang.github.io/2017/08/01/for-of的优势/","excerpt":"","text":"以数组为例，js提供了多种遍历语法。 最原始的是for循环。123for(var index=0;index&lt;arr.length;index++)&#123; console.log(arr[index]);&#125; 这种写法比较麻烦，于是数组提供内置的forEach方法。123arr.forEach(function(value)&#123; console.log(value);&#125;) forEach的缺点在于中途无法退回出forEach循环，break命令或return命令无法生效。 for…in循环可以遍历数组的键名。123for(var index in arr)&#123; console.log(arr[index]);&#125; for…in循环的缺点： 数组的键名是数字，但是for…in循环是以字符串作为键名，如”0”,”1”等； for…in循环不仅遍历数字键名，还会遍历手动添加其他的键，甚至包括原型链上的键； 某些情况下，for…in循环会以任意顺序遍历键名。for…in循环主要是为了遍历对象而设计的，不适用于遍历数组。 for…of循环相比上面几种做法的有点，有一些显著的优点。 有着同for…in一样简洁语法，但是没有for…in那些缺点； 不同于forEach方法，它可以与break、continue、return配合使用 提供了遍历所有数据结构的统一操作接口。12345for(var n of fibonacci)&#123; if(n&gt;1000) break; console.log(n);&#125; 注：ES6引入for…of作为遍历所有数据结构的统一的方法。一个数据结构只要部署了Symbol.iterator属性，就被视为具有iterable接口，就可以用for…of循环遍历它的成员。for…of可以使用的范围包括数组、Set和Map、类数组的对象、Generator对象以及字符串。","categories":[],"tags":[],"keywords":[]},{"title":"Promise","slug":"Promise","date":"2017-07-31T01:33:29.000Z","updated":"2017-08-01T07:46:02.025Z","comments":true,"path":"2017/07/31/Promise/","link":"","permalink":"https://aliceflaviawang.github.io/2017/07/31/Promise/","excerpt":"","text":"Promise含义Promise是一种异步编程的解决方案，比传统的回调函数和事件更合理和更强大。Promise简单来说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上来说，Promise是一个对象，从它可以获取异步操作的消息。 Promise对象有一下两个特点： 对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：Pending(进行中)、Resolved(已完成，或者Fullfilled)、Rejected(已失败)。只有异步操作能决定当前是哪一种状态，任何其他操作都无法改变这个状态。 一旦状态改变，就不会变，任何时候都可以得到这个结果。Promise对象状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只要这两种情况发生，状态就不会再变了。如果改变已经发生，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。 Promise的优点和缺点： 优点：将异步操作以同步流程表达出来，避免层层嵌套的回调函数；另外Promise对象提供统一的接口，使得异步操作更加容易。 缺点：无法取消Promise，一旦新建它就会立即执行，无法中途取消；其次如果不设置回调函数，Promise内部抛出的错误，不会反应到外部；第三当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。 基本用法1234567var promise=new Promise(function(resolve,reject)&#123; if(/*异步操作成功*/)&#123; resolve(value); &#125;else&#123; reject(error); &#125;&#125;) resolve和reject是两个函数，由JS引擎提供。resolve将Promise的状态从Pending变为Resolved，在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject将状态由Pending变为Rejected，在异步操作失败时调用，并将异步操作报出的错误作为参数传递出去。 Promise实例生成之后，可以用then方法分别指定Resolved状态和Rejected状态的回调函数。12345promise.then(function(value)&#123; //success&#125;,function(error)&#123; //error&#125;) Promise.prototype.then()then方法是定义在原型对象Promise.prototype上的，then方法的第一个参数是Resolved状态的回调函数，第二个参数是Rejected状态的回调函数。 then方法返回的是一个新的Promise实例，因此可以采用链式写法，即then方法后面再调用另一个then方法（第一个回调函数完成后会将结果作为参数，传入第二个回调函数）。 Promise.prototype.catch()Promise.prototype.catch方法是.then(null,rejection)的别名，用于指定错误发生时的回调函数。123p.then((val)=&gt;console.log(&apos;fullfilled:&apos;,val)).catch((err)=&gt; console.log(&apos;rejected&apos;,err));等同于p.then((val)=&gt;console.log(&apos;fullfilled:&apos;,val)).then(null,(err)=&gt;console.log(&apos;rejected&apos;,err)) Promise.all()Promise.all将多个Promise实例，包装成一个新的Promise实例。参数可以不是数组，但必须具有Iterator接口，且返回的每个成员都是Promise实例。1var p=Promise.all([p1,p2,p3]); p的状态取决于p1、p2、p3，分成两种情况： 只有p1、p2、p3的状态都变成fullfilled，p的状态才会变成fullfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。 只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被rejected的实例的返回值，会传递给p的回调函数。123456789// 生成一个Promise对象的数组var promises = [2, 3, 5, 7, 11, 13].map(function (id) &#123; return getJSON(&apos;/post/&apos; + id + &quot;.json&quot;);&#125;);Promise.all(promise).then(function(posts)&#123;//...&#125;).catch(function(reason)&#123;//...&#125;) Promise.race()Promise.race方法同样是将多个Promise实例，包装成一个新的Promise实例。1var promise=new Promise.race([p1,p2,p3]) p1,p2,p3只要有一个状态改变，p的状态就跟着改变。那个率先改变的Promise实例的返回值，就传给p的回调函数。 Promise.resolve()Promise.resolve方法可以将现有对象转为Promise对象。Promise.resolve方法的参数分为四种情况 参数是一个Promise实例如果参数是Promise实例，Promise.resolve将不做任何修改原封不动的返回这个实例 参数是一个thenable对象thenable对象指的是具有then方法的对象，Promise.resolve会将这个对象转为Promise对象，然后立即执行thenable对象的then方法。 123456789let thenable=&#123; then: function(resolve,reject)&#123; resolve(42); &#125;&#125;let p1=Promise.resolve(thenable);p1.then(function(value)&#123; console.log(value); //42&#125;) 参数不是具有then方法的对象，或者根本不是对象如果参数是一个原始值，或者一个不具有then方法的对象，则Promise.resolve方法返回一个新的Promise对象，状态为Resolved。 1234var p=Promise.resolve(&apos;Hello&apos;);p.then(function(s)&#123; console.log(s); //Hello&#125;) 不带有任何参数Promise.resolve方法允许调用时不带参数，直接返回一个Resolved状态的Promise对象。 需要注意的是，立即resolve的Promise对象，实在本轮”事件循环（event loop）”结束时，而不是在下一轮”事件循环”开始时。12345678910setTimeout(function()&#123; console.log(&apos;three&apos;);&#125;,0);Promise.resolve().then(function()&#123; console.log(&apos;two&apos;);&#125;)console.log(&apos;one&apos;);//one//two//three setTimeout(fn,0)是在下一轮“事件循环”开始时执行，Promise.resolve()在本轮“时间循环”结束时执行，而console.log(‘one’)立即执行。 Promise.reject()Promise.reject(reason)方法也会返回一个新的Promise实例，该实例的状态为rejected。123456var p=Promise.reject(&apos;出错了&apos;);//等同于var p=new Promise(resolve,reject)=&gt;reject(&quot;出错了&quot;);p.then(null,function(s)&#123; console.log(s);&#125;) 额外提供的两个方法 done()Promise对象的回调链，不管是以then方法还是catch方法结尾，要是最后一个方法抛出错误，都有可能无法捕捉到（因为Promise内部的错误不会冒泡到全局）。因此提供done方法，总是处于回调链的尾端，保证抛出任何可能的错误。12345ayncFunc() .then(f1) .catch(r1) .then(f2) .done(); done方法的实现1234567Promise.prototype.done=function(onFulfilled,onRejected)&#123; this.then(onFulfilled,onRejected) .catch(function(reason)&#123; //抛出一个全局错误 setTimeout(()=&gt;&#123; throw reason&#125;,0); &#125;)&#125; finally()finally方法用于指定不管Promise对象的最后状态如何，都会执行的操作，它与done方法最大的区别，它接收一个普通的回调函数作为参数，该函数不管怎样都必须执行。它的实现：1234567Promise.prototype.finally=function(callback)&#123; let P=this.constructor; return this.then( value =&gt; P.resolve(callback()).then(()=&gt;value), reason =&gt; P.resolve(callback()).then(()=&gt;&#123;throw reason&#125;) ); &#125;; Promise.try()实际开发中：不知道或者不想区分，函数f是同步还是异步操作，但是想用Promise来处理。这样不管f是同步还是异步操作，都用then方法指定下一步流程，用catch方法来处理f抛出的错误。12345const f=()=&gt;console.log(&quot;now&quot;);Promise.resolve().then(f);console.log(&quot;next&quot;);//next//now 上面写法的一个缺点，如果f是同步函数，那么它会在本轮事件循环的末尾执行。上面函数f是同步的，经过Promise包装之后就变成异步执行了。 现在想让同步函数同步执行，异步函数异步执行，有两种方法： async函数12345const f=()=&gt;console.log(&apos;now&apos;);(async ()=&gt;f())();console.log(&apos;next&apos;);//now//next 上面第二行是一个立即执行的匿名函数，会立即执行里面的async函数，因此f是同步的，就会得到同步的结果；如果f是异步的，就可以用then指定下一步。（注意async ()=&gt;f()会吃掉f()抛出的错误，如果响应抛出错误，要使用Promise.catch方法。（async ()=&gt;f())().then(…).catch()）。 new Promise()123456789const f=()=&gt;console.log(&apos;now&apos;);( ()=&gt;new Promise( resolve=&gt;resolve(f) ))();console.log(&apos;next&apos;);//now//next 上面也是使用匿名函数，执行new Promise()。 基于上面的需求，提供了Promise.try方法替代了上面的写法。12345const f=()=&gt;console.log(&apos;now&apos;);Promise.try(f);console.log(&apos;next&apos;);//now //next","categories":[],"tags":[],"keywords":[]},{"title":"猜数游戏","slug":"猜数游戏","date":"2017-07-29T08:44:01.000Z","updated":"2017-07-29T09:29:45.325Z","comments":true,"path":"2017/07/29/猜数游戏/","link":"","permalink":"https://aliceflaviawang.github.io/2017/07/29/猜数游戏/","excerpt":"","text":"牛客上的猜数题，分析过程非常有意思，记录一下。12345678牛牛和羊羊在玩一个有趣的猜数游戏。在这个游戏中,牛牛玩家选择一个正整数,羊羊根据已给的提示猜这个数字。第i个提示是&quot;Y&quot;或者&quot;N&quot;,表示牛牛选择的数是否是i的倍数。例如,如果提示是&quot;YYNYY&quot;,它表示这个数使1,2,4,5的倍数,但不是3的倍数。注意到一些提示会出现错误。例如: 提示&quot;NYYY&quot;是错误的,因为所有的整数都是1的倍数,所以起始元素肯定不会是&quot;N&quot;。此外,例如&quot;YNNY&quot;的提示也是错误的,因为结果不可能是4的倍数但不是2的倍数。现在给出一个整数n,表示已给的提示的长度。请计算出长度为n的合法的提示的个数。例如 n = 5:合法的提示有:YNNNN YNNNY YNYNN YNYNY YYNNN YYNNYYYNYN YYNYY YYYNN YYYNY YYYYN YYYYY所以输出12 输入描述:输入包括一个整数n(1 ≤ n ≤ 10^6),表示已给提示的长度。输出描述:输出一个整数,表示合法的提示个数。因为答案可能会很大,所以输出对于1000000007的模输入例子1:5输出例子1:12 分析：首先看有几种可能： 如果第i个数是素数，前面除了1没有能除尽的，所以i有Y和N两种可能 如果第i个数是素数的幂次，比如输入的是12，那么其中2、4、8是素数2的幂次，分析下2、4、8，有YYY、NNN、YNN、YYN四种可能，3、9是素数3的幂次，有YY、NN、YN两种可能…总结规律得出如果有n个幂次，就有n+1种可能的情况。 如果第i个数不是素数的幂次，比如6、10，可以发现，6取决于2、3，如果2、3为YY，6必然为Y，其他情况都为N，也就是6、10这种并非素数的幂次的数并不影响可能的情况 因此，只需要考虑素数幂次的个数（素数是特殊的幂次即一次幂，如果有n个幂次，就有n+1种可能）。对12来说：有43222种可能，对应的分别是（2、4、8）、（3、9）、（5）、（7）、（9）.代码如下：123456789101112131415161718192021function count(n)&#123; var mod=Math.pow(10,9)+7; //防止答案过大，输出对于1000000007的模 var ans=1;//结果 var arr=[];//定义布尔数组 for(var i=2;i&lt;=n;i++)&#123; var count=0; //统计幂次 //找出素数 if(arr[i]) continue; for(var j=i+i;j&lt;=n;j+=i)&#123; arr[j]=true; &#125; var mi=i; while(mi&lt;=n)&#123; count++; mi*=i; &#125; ans=ans*(count+1)%mod; &#125; console.log(ans);&#125;","categories":[],"tags":[],"keywords":[]},{"title":"ORACLE导入dmp文件详解","slug":"ORACLE导入dmp文件详解","date":"2017-07-27T02:19:16.000Z","updated":"2017-07-27T03:28:15.657Z","comments":true,"path":"2017/07/27/ORACLE导入dmp文件详解/","link":"","permalink":"https://aliceflaviawang.github.io/2017/07/27/ORACLE导入dmp文件详解/","excerpt":"","text":"折腾了一天终于导入成功并查看到了，决定写个教程。准备：下载oracle 11g和pl/sql developer，我使用的是64位，据说用32位可能错误要少一点。 安装oracle 11g这个比较简单，百度上很多教程如：http://www.cnblogs.com/qfb620/p/4577255.html。 需要注意的是这一步不要填电子邮件，否则会报连接错误这一步填写口令的时候主要开头不要是数字，否则安装完会报错（但是不确定有没有影响） 安装完成后修改用户名和密码在控制台用sqlplus / as sysdba登陆oracle系统使用命令修改用户名密码alter user 用户名 indentified by “密码” 打开pl/sql developer初始打开时用户名和密码为第2步修改的用户名和密码，数据库是“ip/数据库名（默认是orcl）” 点击登录，报错解决办法：在未登陆的情况下进入pl/sql，在工具-&gt;首选项-&gt;连接里面设置Oracle主目录名和OCI库（其中Oracle主目录在Oracle安装目录下，OCI在安装目录的BIN目录下） 再次登陆，依然报错，原因是无法load BIN目录下的oci.dll文件解决办法： 在这个地址http://download.csdn.NET/detail/shenkxiao/4181424下载包含oci.dll文件包，解压到&quot;D:\\Program Files\\”下，然后将上一步OCI目录改成”D:\\Program Files\\instantclient_10_2\\instantclient_10_2\\oci.dll”。 重新登陆，发现出现了“连接为”这一项，并且自动出现了用户名和数据库地址，点击出现了”Oracle client ORA-12541: TNS:no listener [closed]”错误。解决办法：首先找到Oracle安装目录下的listener.ora和tnsnames.ora(我的是在E:\\app\\Alice\\product\\11.2.0\\dbhome_1\\NETWORK\\ADMIN下)，将host=localhost改成host=ip然后重启Oracle服务，WinKey+r 再次打开pl/sql，点击确定登录成功 导入dmp文件打开工具-&gt;导入表-&gt;Oracle导入（dmp文件选择Oacle导入）在“导入可执行文件”栏填入的是可执行的文件，比如Oracle安装目录的BIN目录下的imp.exe文件（我的地址是”E:\\app\\Alice\\product\\11.2.0\\dbhome_1\\BIN\\imp.exe”），导入文件就是你要导入的dmp文件的地址。 导入成功，下方会有提示 点击左侧的Table的项，刷新，可以看到导入的表，然后右键编辑表可以看到新导入的表结构 此时你可能会发现表里有些乱码，解决办法是：新建环境变量NLS_LANG，值为SIMPLIFIE DCHINESE_CHINA.ZHS16GBK，保存后重启pl/sql，如果还是乱码，则将环境变量值改为AMERICAN_AMERICA.ZHS16GBK（我将值改为AMERICAN_AMERICA.ZHS16GBK才成功）。 至此，Oracle安装、导入及查看dmp文件过程完成。","categories":[],"tags":[],"keywords":[]},{"title":"尾递归","slug":"尾递归","date":"2017-07-24T07:59:48.000Z","updated":"2017-07-24T13:49:17.786Z","comments":true,"path":"2017/07/24/尾递归/","link":"","permalink":"https://aliceflaviawang.github.io/2017/07/24/尾递归/","excerpt":"","text":"函数调用自身，成为递归。如果尾调用自身，就称为尾递归。 递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误（出自阮一峰ECMAScript6入门，但是亲测尾递归还是会出现栈溢出，只不过情况要比普通的递归情况好很多）。 举个例子：123456function factorial(n)&#123; if(n===1) return 1; return n*factorial(n-1);&#125;factorial(5)&#125; 上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度O(n)。如果改成尾递归，只保留一个调用记录，复杂度O(1)。12345function factorial(n,total)&#123; if(n&lt;=1) return total; return factorial(n-1,n*toatl);&#125;factorial(5,1) 非常经典的例子，Fibonacci数列：1234567function Fibonacci(n)&#123; if(n&lt;=1)&#123;return 1&#125;; return Fibonacci(n-1)+Fibonacci(n-2);&#125;Fibonacci(10); //89Fibonacci(100); //堆栈溢出Fibonacci(1000); //堆栈溢出 如果将其改为尾递归实现：1234567function Fibonacci(n,ac1=1,ac2=1)&#123; if(n&lt;=1)&#123;return ac2&#125;; return Fibonacci(n-1,ac2,ac1+ac2);&#125;Fibonacci(100) //573147844013817200000Fibonacci(1000) //7.0330367711422765e+208Fibonacci(10000) //栈溢出 递归函数的改写尾递归的实现往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。有两种方法可以解决： 在尾递归之外，再提供一个正常行驶的函数。 12345678funtion tailFactorial(n,total)&#123; if(n===1) return total; return tailFactorial(n-1,n*total);&#125;function factorial(n)&#123; tailFactorial(n,1)&#125;factorial(5); 采用ES6的函数默认值 12345function factorial(n,toatl=1)&#123; if(n===1) return toatl; return factorial(n-1,n*total);&#125;factorial(5); 递归本质上是一种循环操作，循环可以用递归代替，而一旦使用递归，最好使用尾递归。","categories":[],"tags":[],"keywords":[]},{"title":"inline-block和float的区别","slug":"inline-block和float的区别","date":"2017-07-17T05:38:48.000Z","updated":"2017-07-17T05:59:31.968Z","comments":true,"path":"2017/07/17/inline-block和float的区别/","link":"","permalink":"https://aliceflaviawang.github.io/2017/07/17/inline-block和float的区别/","excerpt":"","text":"inline-block:块状内联元素。inline属性使元素内联展示，内联设置宽度无效，相邻的inline元素会在一行显示不换行，直到本行排满为止。block元素始终会独占一行，呈块状显示，可设置宽高。inline-block让元素容器属性为block，内容为inline。 float：设置元素浮动时，相邻元素会根据自身大小，排满一行，如果父容器宽度不够则换行。浮动元素脱离了文档流，相邻元素会呈现环绕状排列。 共同点：都能实现元素在一行显示，并且可以自由设置元素大小 区别：inline-block：水平排列一行，即使元素高度不一，也会以最大元素高度为行高，即使高度小的元素周围留空，也不会有第二行元素上浮补位（inline-block仍在文档流里，减少了程序对DOM的更改操作，因为DOM的每一次更改，浏览器会重绘DOM树）float：让元素脱离文档流，呈环绕状排列，如遇上行有空白，而当前元素的大小可以挤进去，这个元素会在上行补位排列","categories":[],"tags":[],"keywords":[]},{"title":"http头：Expires,Cache-Control,Last-Modified,ETag","slug":"http头：Expires-Cache-Control-Last-Modified-ETag","date":"2017-07-17T02:01:46.000Z","updated":"2017-08-08T02:48:26.140Z","comments":true,"path":"2017/07/17/http头：Expires-Cache-Control-Last-Modified-ETag/","link":"","permalink":"https://aliceflaviawang.github.io/2017/07/17/http头：Expires-Cache-Control-Last-Modified-ETag/","excerpt":"","text":"缓存分为很多种：服务器缓存，第三方缓存，浏览器缓存。其中浏览器缓存是代价最小的，因为浏览器缓存依赖客户端，而且几乎不耗费服务器端资源。 让浏览器做缓存需要给浏览器发送指定的Http头，告诉浏览器缓存多长时间，或者坚决不要缓存。 1. Expires（过期时间）Http头信息Expire属性是Http控制缓存的基本手段，这个属性告诉缓存器：相关副本在多长时间内是新鲜的。 缺点： 客户端与服务器时间不同步导致Expire的配置出现问题 很容易在配置后忘记具体的过期时间，导致过期来临出现浪涌现象 2. Cache-Control（缓存控制） Http头信息Cache-Control让网站发布者可以更全面的控制他们的内容，并定位过期时间的限制。 public响应头，通知浏览器无条件缓存该响应 private响应头，通知浏览器只针对单个用户缓存响应。且可以具体指定某个字段。如：private-“username” no-cache请求头，浏览器去服务器取数据并验证缓存。响应头告诉浏览器必须要回复服务器校验，不管有没有缓存。如果确定没有被改，可以使用缓存中的数据 no-store要求浏览器任何情况下都不要缓存 max-age 强制浏览器根据该值校验缓存。即自身age值，与请求时间做比较，如果超过max-age值，则强制去服务器端验证。以确保返回一个新鲜的响应。其功能与传统的Expire类似，但区别在于Expire是根据某个特定日期值做比较，一旦客户端自身的时间不准确，则结果可能就是错误的，而max-age则是客户端时间比较。max-age的优先级高于Expire。 Expire指定的时间可以是相对文件的最后访问时间（Atime）或者修改时间（Mtime），而max-age相对的是文档的请求时间（Atime） 3. Last-Modified/If-Modified-Since客户端第一次访问资源的时候，服务器返回资源内容的同时返回Last-Modified:Wed, 07 Aug 2013 15:32:18 GMT，服务器告诉客户端你获取的文件最后修改时间是这个时间。浏览器在获取这个文件到缓存中的时候，给缓存中的文件同时记录上这个最后修改时间。 第二次访问的时候，服务器访问资源的时候会带上If-Modified-Since:Wed, 07 Aug 2013 15:32:18 GMT. 客户端询问服务器：这个资源我这边已经缓存了，我的缓存文件的最后修改时间是这个，如果你那边资源没有修改的话，你就告诉我一下就好了，不需要返回实际的资源的内容；反之要是你有修改的话，你就把内容返回给我吧。 4. ETag/If-None-Match是实现与最近修改数据检查同样的功能的另一种方法，没有变化时不重新下载数据。第一次客户端访问资源的时候，服务端返回资源内容的同时返回ETag:1234，告诉客户端这个文件的标签是1234，如果修改了的话，这个标签就会不一样。 第二次客户端访问资源的时候，由于缓存中已经有了ETag为1234的资源，客户端要去服务端查询的是这个资源有没有过期呢？所以带上If-None-Match:1234。告诉服务端：如果你那边的资源还是1234标签的资源，你就返回304告诉我，不需要返回资源内容了；如果不是的话你就返回内容给我。 总结：Exipire/Cache-Control header是控制浏览器是否直接从浏览器缓存中获取数据还是重新发送请求到服务器取数据。只是Cache-Control比Expires控制的多些，而且Cache-control会重写Expires规则。 Last-Modified/ETag是浏览器发送请求到服务器后判断文件是否修改过，如果没有修改过就只发送一个304给浏览器，告诉浏览器从本地缓存取数据；如果修改过那就返回200连同整个数据重新发送给浏览器。 补充：刷新理解了上面的缓存标签之后就很好理解各种刷新了，刷新有三种：浏览器中写地址、回车,F5,Ctrl+F5三种。 假设对一个资源:浏览器第一次访问，获取资源内容和cache-control:max-age:600,last-modified:Wed, 07 Aug 2013 15:32:18 GMT，于是浏览器把资源文件放到缓存中，并且决定下次使用的时候直接去缓存中取了。 浏览器url回车浏览器发现缓存中有这个文件，就不发送人任何请求，直接去缓存中获取展现。（最快） F5F5告诉浏览器别偷懒，去服务器看下这个文件是否有过期。于是浏览器就发送一个请求带上If-Modified-Since:Wed, 07 Aug 2013 15:32:18 GMT，然后浏览器发现，这个文件我在找个时间后还没修改过，不需要给你任何信息了，返回304就行了。于是浏览器获取到304后就去缓存中获取资源了。 3.Crtl+F5这个告诉浏览器先要把缓存中的这个文件给删了，然后再去服务器请求整个完整的资源文件下来，于是客户端就完成了强行更新的操作。","categories":[],"tags":[],"keywords":[]},{"title":"border-radius:50%和100%","slug":"border-radius-50-和100","date":"2017-07-16T13:27:16.000Z","updated":"2017-07-16T13:50:30.142Z","comments":true,"path":"2017/07/16/border-radius-50-和100/","link":"","permalink":"https://aliceflaviawang.github.io/2017/07/16/border-radius-50-和100/","excerpt":"","text":"用来画圆border-radius必不可少，我们把这个值设成50%，发现设成100%也有效。 下面是一个150px x 150px大小的方形，将它的四个角的半径都设置成50%。根据W3C的规范定义，如果border-radius的值是百分比，就是相对于border box的宽度和高度的百分比。在本例中，50%就是75px。 border-radius工作原理如果两个相邻的角的半径和超过了对应的盒子的边的长度，那么浏览器要重新计算保证它们不会重合。 如果左上角的圆角被设置成100%，那么圆角就会从这个方形左下角跨到右上角，相当于把圆角半径设置成150px。如果右上角的圆角半径也设置成100%，则两个相邻的圆角合起来就有200%。这种情况自然是不允许的，所以浏览器会重新计算，匀出空间给右边的圆角，同时缩放两个圆角的半径直到它们刚好符合这个方形，所以半径就变成了50%。 实际上方形所能拥有的最大半径是其宽高的50%，超过了就会重新计算。","categories":[],"tags":[],"keywords":[]},{"title":"TCP连接与关闭过程","slug":"TCP连接与关闭过程","date":"2017-07-16T11:58:42.000Z","updated":"2017-07-16T12:23:33.084Z","comments":true,"path":"2017/07/16/TCP连接与关闭过程/","link":"","permalink":"https://aliceflaviawang.github.io/2017/07/16/TCP连接与关闭过程/","excerpt":"","text":"建立连接：三次握手在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接，如图： 客户端A发送SYN包（SYN=j）到服务器B，并进入SYN_SEND状态，等待服务器B确认； 服务器B收到SYN包，必须确认客户A的SYN（ACK=J+1）,同时也发送一个SYN包（SYN=k），即ACK+SYN包，此时服务器B进入SYN_RECV状态； 客户端A收到服务器B的SYN+ACK包，，向服务器B发送确认包ACK（ACK=K+1）。此包发送完毕，客户端A和服务器B进入ESTABLISHED状态，完成三次握手。客户端与服务器端开始传送数据。 断开连接：四次挥手由于TCP是双全工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务就能发送一个FIN来终止这个方向的连接。收到一个FIN只意味着一个方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方进行主动关闭，而另一方执行被动关闭。 客户A发送一个FIN，用来关闭客户A到服务器B的数据传送 服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序列号。 服务器B关闭与客户端A的连接，发送一个FIN给客户端A。 客户端A发回ACK报文确认，并将确认序号设置为收到序号加1。","categories":[],"tags":[],"keywords":[]},{"title":"如何选择图片格式GIF,JPG,PNG","slug":"如何选择图片格式GIF-JPG-PNG","date":"2017-07-16T08:37:15.000Z","updated":"2017-07-16T09:13:34.310Z","comments":true,"path":"2017/07/16/如何选择图片格式GIF-JPG-PNG/","link":"","permalink":"https://aliceflaviawang.github.io/2017/07/16/如何选择图片格式GIF-JPG-PNG/","excerpt":"","text":"JPEG（简写jpg）JPEG是一种大小与质量相平衡的压缩图片格式。通俗的说：高的压缩比=低的图片质量=小的文件大小。由于JPEG无法保持100%的原始图像的像素数据，所以它不被认为是一种无损图像格式。 它支持上百万种颜色。适合轻微是真的像素色彩丰富的图片唱歌，并不适合简单色彩的图片如logo，icons。 它不支持图形渐进、北京透明，更不支持动画，有损压缩不可恢复 GIF是为了使图片能够应用在在线应用程序上所特别开发的图片格式。GIF，是一种无损（100%保持原始图片像素数据信息），8位图片格式（一个8位图像仅能支持256中不同颜色，多于将出现失真）。 压缩特性：采用LZW算法进行压缩 透明特性：支持基本的透明性 支持隔行扫描：隔行扫描能够令图片在浏览器中更快的加载和显示 动画GIF：支持动画。Flash动画出来之前，GIF动画可以说是唯一的动画。GIF将单帧的图像组合起来，然后轮流播放每一帧而成为动画。 PNGPNG也是一种无损压缩，但与GIF不同的是，PNG同时支持8位和24位的图像。 8位PNG图片的用途与GIF格式基本相同 24位PNG：24位PNG，支持160万种不同的像素颜色且支持Alpha透明效果。也就是说无论透明度设为多少，PNG图片均能够与背景很好的融合在一起。 不支持动画，高级压缩，支持全彩图像，对色彩丰富的图像取得不错的视觉效果 总比较大小：PNG≈JPG&gt;GIF透明性：PNG&gt;GIF&gt;JPG色彩丰富度：JPG&gt;PNG&gt;GIF兼容度：GIF≈JPG&gt;PNG","categories":[],"tags":[],"keywords":[]},{"title":"childNodes和children的区别","slug":"childNodes和children的区别","date":"2017-07-16T04:07:05.000Z","updated":"2017-07-16T08:37:23.722Z","comments":true,"path":"2017/07/16/childNodes和children的区别/","link":"","permalink":"https://aliceflaviawang.github.io/2017/07/16/childNodes和children的区别/","excerpt":"","text":"childNodes标准的，它返回指定元素的子元素集合，包括HTML节点，属性节点和文本节点。可以通过nideType来判断是哪个类型的节点，只有当nodeType==1时才是元素节点，2是属性节点，3是文本节点。 children非标准的，它只返回HTML节点（IE中包含注释节点）。","categories":[],"tags":[],"keywords":[]},{"title":"渐进增强和优雅降级","slug":"渐进增强和优雅降级","date":"2017-07-16T03:56:59.000Z","updated":"2017-07-16T04:02:31.988Z","comments":true,"path":"2017/07/16/渐进增强和优雅降级/","link":"","permalink":"https://aliceflaviawang.github.io/2017/07/16/渐进增强和优雅降级/","excerpt":"","text":"渐进增强针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。 优雅降级一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。 区别： 优雅降级是从复杂的现状开始，并试图减少用户体验的供给； 渐进增强是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要； 降级（功能衰退）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带。","categories":[],"tags":[],"keywords":[]},{"title":"立即执行函数的作用","slug":"立即执行函数的作用","date":"2017-07-15T14:39:58.000Z","updated":"2017-07-15T14:58:37.352Z","comments":true,"path":"2017/07/15/立即执行函数的作用/","link":"","permalink":"https://aliceflaviawang.github.io/2017/07/15/立即执行函数的作用/","excerpt":"","text":"(function(){})()是立即执行函数（IIFE），它会默认将函数作为表达式去解析，而不是函数声明（注意圆括号内不能包含声明）。它的作用： 最主要的作用是隔离作用域，直到ES5JS没有块作用域，用来隔离作用域避免污染。 惰性，利用立即执行特性，返回需要的业务函数或对象，避免每次通过条件判断来处理。 惰性函数惰性载入表示函数执行的分支只会在函数第一次调用的时候执行，在第一次调用的过程中，该函数会被覆盖为另一个按照合适方式执行的函数，这样任何对原函数的调用就不用再经过执行的分支了。举个经典的例子1234567891011function addEvent(type,element,fun)&#123; if(element.addEventListener)&#123; element.addEventListener(type,element,fun); &#125; else if(element.attachEvent)&#123; element.attachEvent(type,element,fun); &#125; else&#123; element[&apos;on&apos;+type]=fun; &#125;&#125; 上面注册监听函数主要是为了兼容浏览器。由于浏览器差异，不得不再用的时候做能力检测。但是这样做，每次绑定监听，都会对能力做一次检测，然而真正的应用中，同一个应用环境，其实只需要做一次检测即可。下面重写addEvent:1234567891011121314151617function addEvent(type,element,fun)&#123; if(element.addEventListener)&#123; addEvent=function(type,element,fun)&#123; element.addEventListener(type,fun,false); &#125; &#125; else if(element.attachEvent)&#123; addEvent=function(type,element,fun)&#123; element.attachEvent(&quot;on&quot;+type,fun); &#125; &#125; else&#123; addEvent=function(type,element,fun)&#123; element[&apos;on&apos;+type]=fun; &#125; &#125;&#125; 由于第一调用addEvent会对浏览器做能力检测，然后重写addEvent。下次再调用的时候，由于函数被重写，不会再做能力检测。 惰性函数的应用场景： 应用频繁。用的次数也多越能体现出优势来； 固定不变。一次判断，在固定的应用环境中不会发生改变； 复杂的分支判断。没有差异性的，不需要用这种模式。","categories":[],"tags":[],"keywords":[]},{"title":"同步和异步","slug":"同步和异步","date":"2017-07-15T13:11:06.000Z","updated":"2017-07-15T14:29:16.945Z","comments":true,"path":"2017/07/15/同步和异步/","link":"","permalink":"https://aliceflaviawang.github.io/2017/07/15/同步和异步/","excerpt":"","text":"延伸 摘自阮一峰es6入门： 于是，这个问题又回到了最开始的起点：JavaScript是单线程的。 JavaScript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。那么，为什么JavaScript不能有多个线程呢？这样能提高效率啊。 JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？ 所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。 为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。 单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。于是就有一个概念，任务队列。 如果排队是因为计算量大，CPU忙不过来，倒也算了，但是很多时候CPU是闲着的，因为IO设备（输入输出设备）很慢（比如Ajax操作从网络读取数据），不得不等着结果出来，再往下执行。 JavaScript语言的设计者意识到，这时主线程完全可以不管IO设备，挂起处于等待中的任务，先运行排在后面的任务。等到IO设备返回了结果，再回过头，把挂起的任务继续执行下去。 于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。 具体来说，异步执行的运行机制如下。（同步执行也是如此，因为它可以被视为没有异步任务的异步执行。） （1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。（2）主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。（3）一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。（4）主线程不断重复上面的第三步。下图就是主线程和任务队列的示意图。 只要主线程空了，就会去读取”任务队列”，这就是JavaScript的运行机制。这个过程会不断重复。 “任务队列”是一个事件的队列（也可以理解成消息的队列），IO设备完成一项任务，就在”任务队列”中添加一个事件，表示相关的异步任务可以进入”执行栈”了。主线程读取”任务队列”，就是读取里面有哪些事件。 “任务队列”中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入”任务队列”，等待主线程读取。 所谓”回调函数”（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。 “任务队列”是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，”任务队列”上第一位的事件就自动进入主线程。但是，由于存在后文提到的”定时器”功能，主线程首先要检查一下执行时间，某些事件只有到了规定的时间，才能返回主线程。 进程和线程一个程序就是一个进程，而一个程序中的多个任务则被称为线程。进程是表示资源分配的基本单位，又是调度运行的基本单位。线程是进程中执行运算的最小单位，亦即执行处理机调度的基本单位。进程和线程的关系： 一个线程只属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程是操作系统可以识别的最小执行和调度单位。 资源分配给进程，同一个进程的所有线程共享该进程的所有资源。同一进程中的多个线程共享代码段、数据段、扩展段。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。 处理机分给线程。即真正在处理机上运行的是线程。 线程在执行过程中，需要同步写作，不同的线程间要利用消息通信的办法实现同步。","categories":[],"tags":[],"keywords":[]},{"title":"src和href的区别","slug":"src和href的区别","date":"2017-07-15T12:00:43.000Z","updated":"2017-07-16T14:45:25.556Z","comments":true,"path":"2017/07/15/src和href的区别/","link":"","permalink":"https://aliceflaviawang.github.io/2017/07/15/src和href的区别/","excerpt":"","text":"hrefhref标志超文本引用，用在link和a元素上，href是引用和页面关联，是在当前元素和引用资源之间建立联系。 当浏览器解析到这一句的时候会识别该文档为css文件，会下载并且不会停止对当前文档的处理，这也是为什么建议使用link来加载css而不是使用@import。 src一般用在img,script,frame等元素上。指向外部资源的位置，指向的内部会嵌入到当前标签所在的位置；在请求src资源时会将其指向的资源下载并应用到当前文档中。 当浏览器解析到这一句的时候会暂停其他资源的下载和处理，直至将该资源加载、编译执行完毕（这也是为什么要把js放到底部而不是头部），图片和框架元素也是如此，类似于该元素所指向的资源嵌套到当前标签内。 顺便提一下css,js的放置位置css放在页面头部，页面渲染时是根据DOM结构生成了一个DOM树然后加上css样式生成渲染树，如果css放在后面可能页面会出现闪跳的感觉，白屏或者布局混乱直到css加载完成。 js一般放在之前：因为 执行到这句的时候，会中断其他资源的下载和处理(因为js有可能会修改DOM，所以会阻塞其他的下载和呈现)，知道其下载、解析、执行完毕，因此不能放在头部会组阻塞页面 不能将需要访问dom元素的放在body之前，因为此时还没生成dom，在body之前访问dom元素会出错（ 但也不能将所有的放在body之后，一些页面的效果的实现，是需要预先动态的加载一些js脚本的）","categories":[],"tags":[],"keywords":[]},{"title":"li元素逆序","slug":"li元素逆序","date":"2017-07-14T13:41:08.000Z","updated":"2017-07-24T13:53:47.268Z","comments":true,"path":"2017/07/14/li元素逆序/","link":"","permalink":"https://aliceflaviawang.github.io/2017/07/14/li元素逆序/","excerpt":"","text":"直接上代码1234567var ul=document.getElementById(&quot;ul&quot;);var children=Array.prototype.slice.call(ul.getElementsByTagName(&quot;li&quot;),0);var str=&quot;&quot;;children.reverse();for(var i=0;i&lt;children.length;i++)&#123; str+=children[i].outerHTML;&#125; getElementsByTagName(“li”)实际上返回的就是类数组，为什么要用Array.prototype.slice.call(ul.getElementsByTagName(“li”),0)呢？在此之前先说说js的类数组对象：HTMLCollection，NodeList,arguements.类数组：拥有length的属性，但不是数组（使用instanceof检查返回false），没有forEach,map,slice等数组方法。 类数组常见的三个对象1. 函数的argumentsarguments:函数通过arguments访问传入函数的参数。它是个对象（不是数组），有length属性。 2. HTMLCollection对象HTMLCollection是一个借口，表示HTML元素的集合，提供可以遍历的列表的方法和属性。拥有length,item,nameItem属性（可以访问元素的name和id属性）。返回HTMLCollection集合的有：document.getElementsByTagName,document.getElementsByClassName。 3. NodeList对象NodeList代表乐意个有顺序的节点列表（不光有元素，还有其他节点如文本节点、注释节点）。有length,item属性。返回NodeList集合的有：document.getElementsByName，document.querySelectorAll，document.getElementById(“table”).childNodes，document.styleSheets。 类数组转化成数组1.argumentsarguments的数组话，只需要运用[].slice.call()方法便可以将传递给函数的参数数组化。12345function person()&#123; var args=[].slice.call(arguments); console.log(args);&#125;person(10,20); 2.HTMLCollection和NodeList对于这两类数组对象的元素集合，如果我们使用[].slice.call()方法，IE8及以下的浏览器竟然会报错，报错的内容是：”Array.prototype.slice:’this’不是javascript对象”，很明显HTMLCollection和NodeList并不是Object的子类。所以为了让类数组转化成纯数组，需要进行处理： jQuery早期的makeArray做法 123456789101112131415161718var div=document.getElementsByTagName(&quot;div&quot;);function makeArray(array)&#123; var ret=[]; if(array!=null)&#123; var i=array.length; //The window,strings (and functions) also have length if(i==null||typeof array===&quot;string&quot;||array.setInterval)&#123; ret[0]=array; &#125;else&#123; while(i)&#123; ret[--i]=array[i]; //此处将类数组转化成数组，因为类数组可以遍历，因此适用于所有的类数组对象，将其取出放入数组中 &#125; &#125; &#125; return ret;&#125;var arr=makeArray(div);console.log(arr); prototype的做法 12var div=document.getElementsByTagName(&quot;div&quot;);var array=Array.prototype.slice.call(div,0); 其中，第一种做法兼容性比较好，很通用，第二种做法比较高级，但是只适合高版本主流浏览器。 ES6增加的Array.from方法Array.from可将两类对象转为整正的数组：类似数组的对象（array-like object,类数组对象的本质特征是必须有length属性，即任何有length属性的对象，都可以通过Array.from方法转为数组）和可遍历（iterator）的对象。12var div=document.getElementsByTagName(&quot;div&quot;);var array=Array.from(div); 后记HTMLCollection的集合访问dom元素必须要加上[0]，比如document.getElementsByTagName(“li”)[0]","categories":[],"tags":[],"keywords":[]},{"title":"阿里面试题","slug":"阿里面试题","date":"2017-07-13T13:08:21.000Z","updated":"2017-07-20T02:15:31.696Z","comments":true,"path":"2017/07/13/阿里面试题/","link":"","permalink":"https://aliceflaviawang.github.io/2017/07/13/阿里面试题/","excerpt":"","text":"1. 判断一个对象是否为空目前知道两种方式：第一种将JSON对象变成字符串，看字符串是否为“{}”12345var a=&#123;&#125;;if(JSON.stringify(a)==&quot;&#123;&#125;&quot;)&#123; console.log(&quot;是空对象&quot;);&#125;//是空对象 另外可以使用jQuery的isEmptyObject()方法12345678var a=&#123;&#125;;function isEmptyObject(e)&#123; for(var t in e)&#123; return !1; &#125; return !0;&#125;console.log(isEmptyObject(a)); //true 2. 判断一个数组是数组方法很多:比如：使用instanceof看是不是Array的实例12var arr=[];console.log(arr instanceof Array); //true 或者看arr是否具有push方法（push方法是数组独有的，其他数组独有的方法都可以）12345678var arr=[];function judgeArray(arr)&#123; if(arr.push)&#123; return !0; &#125;return !1;&#125;judgeArray(arr);//true 或者使用Object.prototype.toString.call()方法12var arr=[];Object.prototype.toString.call(arr); //&quot;[Object Array]&quot; Object.prototype.toString.call()方法的原理toString被调用时，执行以下步骤： 获取this对象的[[class]]属性值 计算出三个字符串”[Object”, “第一步的操作结果”,”]”连接的新字符串 返回第二步的操作结果[[class]]是一个内部属性，所有对象都具有该属性。通过[[class]]属性达到判断对象类型的目的。（jQuery的$.type()就是干这个的）通过Object.prototype.toString.call()可以判断： 判断基本类型Object.prototype.toString.call(null);//“[Object Null]”Object.prototype.toString.call(undefined);//“[Object Undefined]”Object.prototype.toString.call(“abc”);//“[Object String]”Object.prototype.toString.call(123);//“[Object Number]”Object.prototype.toString.call(true);//“[Object Boolean]” 判断引用类型函数类型Function fn(){console.log(“test”);}Object.prototype.toString.call(fn);//”[object Function]”日期类型var date = new Date();Object.prototype.toString.call(date);//”[object Date]”数组类型var arr = [1,2,3];Object.prototype.toString.call(arr);//”[object Array]”正则表达式var reg = /[hbc]at/gi;Object.prototype.toString.call(arr);//”[object Array]”自定义类型function Person(name, age) { this.name = name; this.age = age;}var person = new Person(“Rose”, 18);Object.prototype.toString.call(arr); //”[object Object]”很明显这种方法不能准确判断person是Person类的实例，而只能用instanceof 操作符来进行判断，如下所示：console.log(person instanceof Person);//输出结果为true 判断原生JSON对象：var isNativeJSON = window.JSON &amp;&amp; Object.prototype.toString.call(JSON);console.log(isNativeJSON);//输出结果为”[object JSON]”说明JSON是原生的，否则不是； 3. 正则表达式的惰性和非捕获性 正则表达式的贪婪与懒惰贪婪匹配：当表达式中接受重复的限定符时，通常的行为是匹配尽可能多的字符。懒惰匹配：匹配尽可能少的字符。（加上？，使得整个匹配成功的前提下使用最少重复）懒惰限定符12345var str=&apos;aaba-baabb&apos;var reg=/a.b/gstr.match(reg); // [&quot;aab&quot;, &quot;a-b&quot;, &quot;aab&quot;]var reg1=/a.&#123;3,4&#125;?b/gstr.match(reg1) //[&quot;aaba-b&quot;] 正则表达式捕获语法(pattern):匹配pattern并捕获改匹配的子表达式(?:pattern):匹配pattern，与（pattern）区别在于不捕获子表达式(?=pattern):先行断言，匹配pattern但不出现在匹配结果里(?!pattern):先行否定断言，与（？=pattern）相反 12345var data=&apos;windows 98 is ok&apos;;data.match(/windows (\\d+)/); //[&quot;windows 98&quot;,&quot;98&quot;,&quot;0&quot;,&quot;windows 98 is ok&quot;]data.match(/windows (?:\\d+)/); //[&quot;windows 98&quot;,&quot;0&quot;,&quot;windows 98 is ok&quot;]data.match(/windows (?=\\d+)/); //[&quot;windows &quot;,&quot;0&quot;,&quot;windows 98 is ok&quot;]data.match(/windows (?!\\d+)/); //null ES6推出了后行断言(?&lt;=pattern):与先行断言相反，匹配顺序从右到左，匹配pattern但不出现在结果里12/(^(\\d+)(\\d+)$)/.exec(&apos;1053&apos;) //[&apos;1053&apos;,&apos;105&apos;,&apos;3&apos;]/(?&lt;=(\\d+)(\\d+))$/.exec(&apos;1053&apos;) //[&apos;&apos;,&apos;1&apos;,&apos;105&apos;] 没有后行断言时，第一个括号是贪婪模式（保证匹配到的情况下的最长匹配），第二个括号只能捕获一个字符，所以结果是105和3。而后行断言，由于执行顺序是从右到左，第二个括号时贪婪模式，第一个括号只能捕获一个字符，所以结果是1和053。 正则表达式中的exec和match方法的区别字符串的正则方法有：match(),replace(),search(),split()正则表达式的方法有：exec(),test() 1. match()match()属于String正则表达式方法语法：str.match(regexp) //str是要匹配的字符串，regexp是正则表达式match的用法区分是正则表达式有无g全局标志 如果有g全局标志，那么返回的数组保存的是所有的匹配内容，不包括子匹配 12345var objStr=&quot;我的手机号13522222222，他的手机号13288888888，她的手机号码13699999999&quot;; //设置正则表达式，匹配以13开头11位字符串，全局匹配var reg=/13(\\d)(\\d&#123;8&#125;)/g; var arr=objStr.match(reg); arr //[&quot;13522222222&quot;, &quot;13288888888&quot;, &quot;13699999999&quot;] 如果没有g全局标志，那么返回的数组arr.arr[0]保存的是完整匹配,1-n元素包含了匹配中曾经出现过的任一个子匹配，并有index(匹配开始的位置)和input(整个被查找的字符串)两个属性。 12345var objStr=&quot;我的手机号13522222222，他的手机号13288888888，她的手机号码13699999999&quot;; //非全局匹配var reg=/13(\\d)(\\d&#123;8&#125;)/; var arr=objStr.match(reg); arr //[&quot;13522222222&quot;, &quot;5&quot;, &quot;22222222&quot;, index: 5, input: &quot;我的手机号13522222222，他的手机号13288888888，她的手机号码13699999999&quot;] replace()进行字符串替换，然后返回替换后的副本(字符串本身不变)语法：str.replace(regexp,replaceText)123var objStr=&quot;我的手机号13522222222，他的手机号13288888888，她的手机号码13699999999&quot;; var reg=/13(\\d)(\\d&#123;8&#125;)/g; objStr.replace(reg,&quot;-&quot;) //&quot;我的手机号-，他的手机号-，她的手机号码-&quot; search()search()方法指明是否存在相应的匹配，如果找到，返回索引值，否则返回-1。语法：str.search(regexp)与exec()方法不同，只能执行一次，如果regexp含有全局标志将自动忽略，也忽略lastIndex属性。即只能返回第一个匹配的索引值。1234var objStr=&quot;我的手机号13522222222，他的手机号13288888888，她的手机号码13699999999&quot;; var reg=/13(\\d)(\\d&#123;8&#125;)/g; var index=objStr.search(reg);index; //5 split()方法将一个字符串分割为子字符串，结果作为数组返回。语法：str.split(seperator,limit) //limit限制返回的个数123var objStr=&quot;我的手机号13522222222，他的手机号13288888888，她的手机号码13699999999&quot;; var reg=/13(\\d)(\\d&#123;8&#125;)/g; objStr.split(reg); // [&quot;我的手机号&quot;, &quot;5&quot;, &quot;22222222&quot;, &quot;，他的手机号&quot;, &quot;2&quot;, &quot;88888888&quot;, &quot;，她的手机号码&quot;, &quot;6&quot;, &quot;99999999&quot;, &quot;&quot;] 2. exec()与match()方法不同，exec()属于正则表达式的方法语法：regexp.exec(str)exec(exec有无g都无影响)与match的关联就是exec等价于没有g标志的matchexec()只执行一次12345var objStr=&quot;我的手机号13522222222，他的手机号13288888888，她的手机号码13699999999&quot;; var reg=/13(\\d)(\\d&#123;8&#125;)/; //执行exec函数，尽管是全局匹配的正则表达式，但是exec方法只对指定的字符串进行一次匹配（有无g都只执行一次），获取字符串中第一个与正则表达式想匹配的内容，并且将匹配内容和子匹配的结果存储到返回的数组中var arr=reg.exec(objStr); arr //[&quot;13522222222&quot;, &quot;5&quot;, &quot;22222222&quot;, index: 5, input: &quot;我的手机号13522222222，他的手机号13288888888，她的手机号码13699999999&quot;] 如果将regexp设为全局标志，每次执行exec()时以lastIndex属性值表示的位置开始查找；如果没有设置全局标志，将忽略lastIndex的值，从字符串的起始位置开始搜索。如果想找到字符串的所有匹配，可以循环执行exec()方法直到找不到了为止，此时必须设置全局标志，否则是个死循环。123456789var objStr=&quot;我的手机号13522222222，他的手机号13288888888，她的手机号码13699999999&quot;; var reg=/13(\\d)(\\d&#123;8&#125;)/; var arr; while((arr=reg.exec(objStr))!=null)&#123; console.log(arr.index+&quot;-&quot;+reg.lastIndex+&quot;\\t&quot;+arr); //**注意lastIndex属性是属于reg的**zhen &#125;//5-16 13522222222,5,22222222//22-33 13288888888,2,88888888//40-51 13699999999,6,99999999 test()test()的语法与exec一致，test()方法检查在字符串中是否存在一个匹配指定模式的字符串，存在返回true，不存在返回false。123var objStr=&quot;我的手机号13522222222，他的手机号13288888888，她的手机号码13699999999&quot;; var reg=/13(\\d)(\\d&#123;8&#125;)/g; reg.test(objStr) **4. ES6的声明变量的方法ES5本身的var,function，ES65. Doctype的类型**&lt;!DOCTYPE&gt;声明位于第一行，告知浏览器文档所使用的规范。HTML 4.01规定了三种DOCTYPE类型：Strict,Transitional,Frameset stric:需要干净的标记，免于表现层混乱，与CSS配合使用 transitional：包含W3C所期望移入样式表的呈现属性和元素。不支持CSS的浏览器可以使用 frameset：被用于带有框架的文档 HTML5只有一种&lt;!DOCTYPE HTML&gt; 6. link和@import的区别1）link属于HTML标签，@import是css提供的2）页面加载时，link同时被加载，而@import页面加载完后被加载的3）link无兼容问题4）link的样式权重高于@import7. 状态码（302，304，307重点关注）8. 七层网络，各种协议属于哪一层9. css实现省略号使用text-overflow属性规定当文本溢出包含元素时发生的事情。有三种可能的值： clip:修剪文本 ellipsis：显示省略符号来代表被修剪的文本 string:使用给定的字符串来代表被修剪的文本注：要在文本所在div声明 overflow:hidden;10. null和undefined区别undefined:声明了变量但未对其初始化123var message;console.log(message); //undefinedconsole,log(typeof message); //undefined null:尚未存在的对象，常用来表示函数企图返回一个不存在的对象。从逻辑 角度来看，null值表示一个空对象指针。1234var car=null; //一般没有必要显示的将变量设为undefined，但是应该明确让变量保存null值，这样可以体现null作为空对象指针的惯例，也有助于区别undefined和nullconsole.log(typeof car); //objectnull==undefined //true,**undefined的值实际上派生自null**null===undefined //false,**==只需要值相等，===还要比较类型** NaN:即非数值(not a number)是一个特殊的数值，这个数值用于表示本来要返回数值的操作数未返回数值的情况。NaN有两个特点：1.任何涉及NaN的操作都返回NaN；2.NaN与任何值都不相等，包括NaN本身。isNaN()判断一个数是否是NaN（非数值）。123456console.log(typeof NaN) //numberNaN==NaN //falseisNaN(NaN) //trueisNaN(&quot;10&quot;) //false，可以转化成数值10isNaN(&quot;blue&quot;) //true，不能转换成数值isNaN(true) //false，可以转换成数值1 判断undefined、null和NaN的方法： 判断undefined 12var a=undefined;console.log(typeof a==&quot;undefined&quot;); true 判断null 1234var a=null;if(typeof a==&quot;object&quot;&amp;&amp;a==undefined)&#123; console.log(true);&#125; 还可以通过Object.ptototype.toString.call()方法判断是null还是undefined 判断NaN使用isNaN()方法","categories":[],"tags":[],"keywords":[]},{"title":"常见的数据结构算法","slug":"常见的数据结构算法","date":"2017-07-13T07:12:24.000Z","updated":"2017-07-14T00:40:42.967Z","comments":true,"path":"2017/07/13/常见的数据结构算法/","link":"","permalink":"https://aliceflaviawang.github.io/2017/07/13/常见的数据结构算法/","excerpt":"","text":"二分查找二分查找是基于有序表，是一种在有序数组中查找特定元素的搜索算法。查找过程可以分为： 首先从有序数组的中间的元素开始搜索，如果改元素正好的目标元素即要查找的元素，则搜索过程结束，否则进行下一步 如果目标元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半区域查找，然后重复第一步的操作 如果某一步数组为空，则表示找不到目标元素下面用js分别以递归和不递归的方法写了二分查找（还有对于有重复数组）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950var arr=[1,2,3,4,5,6,7,10,10,10,11,23,44,86]; // function search(arr,key,low,high)&#123; // if(low&gt;high)&#123; // return -1; // &#125; // var mid=parseInt((low+high)/2); // if(key==arr[mid])&#123; // while(mid&gt;=0)&#123; // mid--; // if(arr[mid]&lt;key)&#123; // return mid+1; // &#125; // &#125; // &#125;else if(key&lt;arr[mid])&#123; // high=mid-1; // return search(arr,key,low,high); // &#125; // else if(key&gt;arr[mid])&#123; // low=mid+1; // return search(arr,key,low,high) // &#125;else &#123; // return -1; // &#125; // &#125; // var result=search(arr,10,0,13); // alert(result) function search(arr,key)&#123; var low=0; var high=arr.length-1; while(low&lt;=high)&#123; var mid=parseInt((low+high)/2); if(arr[mid]==key)&#123; while(mid&gt;=0)&#123; mid--; if(arr[mid]&lt;key)&#123; return mid+1; &#125; &#125; &#125;else if(key&lt;arr[mid])&#123; high=mid-1; &#125;else if(key&gt;arr[mid])&#123; low=mid+1; &#125;else&#123; return -1; &#125; &#125; &#125; var result=search(arr,10); alert(result); 冒泡排序冒泡排序基于两两比较和交换，每次冒出一个关键字最大的记录（升序）或关键字最小的记录（降序）。第一趟：第一个和第二个比较，反序则交换，第二个和第三个比较…直到最后冒出最大的一个数放在最后；第i趟的时候，只需要第一个和第二个比较…直到第n-i个和第n-i+1个比较了。最后得出排序结果。12345678910111213141516var arr=[1,22,13,4,5,15,21,10,10,10,11,23,44,86];function bubble(arr)&#123; var n=arr.length-1; for(var i=0;i&lt;n;i++)&#123; for(var j=0;j&lt;n-i;j++)&#123; if(arr[j]&gt;arr[j+1])&#123; var temp=arr[j]; arr[j]=arr[j+1]; arr[j+1]=temp; &#125; &#125; &#125;return arr;&#125;var result=bubble(arr);alert(result); 冒泡算法的改进：如果最后面的若干记录未发生交换，那么这最后的记录已经具有了正序，不需要再进行冒泡了。因此可以通过记录最后一次交换顺序的位置，来改进冒泡算法：12345678910111213141516171819var arr=[1,22,13,4,5,15,21,10,10,10,11,23,44,86];function proBubble(arr)&#123; var i=arr.length-1; while(i&gt;0)&#123; var lastChangeIndex=0; for(var j=0;j&lt;i;j++)&#123; if(arr[j]&gt;arr[j+1])&#123; var temp=arr[j]; arr[j]=arr[j+1]; arr[j+1]=temp; lastIndexChange=j; &#125; &#125; i=lastIndexChange; &#125;return arr;&#125;var result=proBubble(arr);alert(result); 快速排序从数组的中间拿一个值，然后通过这个值挨个和数组里面的值进行比较，如果大于的放在一边，小于的放在一边，然后把这些合并，再进行比较，如此反复即可。1234567891011121314151617181920212223242526var arr=[1,22,13,4,5,15,21,10,10,10,11,23,44,86];function fast(arr)&#123; //如果只有一位，就没有必要比较 if(arr.length&lt;=1)&#123; return arr; &#125; //获取中间值的索引 var len=Math.floor(arr.length/2); //截取中间值 var cur=arr.splice(len,1); //小于中间值放这里面 var left=[]; //大于中间值放这里面 var right=[]; if(var i=0;i&lt;arr.length;i++)&#123; //判断是否大于 if(cur&gt;arr[i])&#123; left.push(arr[i]); &#125;else&#123; right.push(arr[i]); &#125; &#125;return fast(left).concat(cur,fast(right));//arrObject.concat(arrayX,arrayX,...,arrayX)用于连接两个或多个数组，返回一个新的数组。arrayX可以为具体的值也可以是数组对象 &#125;var result=fast(arr);alert(result); 后记 关于parseInt和Math.floorparseInt：解析一个字符串，并返回一个整数，这里可以简单理解成返回舍去参数的小数部分后的整数。如parseInt(5.57) //5,parseInt(-1.5) //-1.Math.floor:返回小于等于参数的最大整数。如：Math.floor(5.57) //5,Math.floor(-1.5) //-2.Math.round:四舍五入。如：Math.round(5.57) //6,Math.round(-1.5) //-1.Math.ceil:返回大于等于参数的最小整数。如：Math.ceil(5.57) //6，Math.ceil(-1.5) //-1","categories":[],"tags":[],"keywords":[]},{"title":"HTML网页布局","slug":"HTML网页布局","date":"2017-07-13T02:58:01.000Z","updated":"2017-07-13T03:31:38.248Z","comments":true,"path":"2017/07/13/HTML网页布局/","link":"","permalink":"https://aliceflaviawang.github.io/2017/07/13/HTML网页布局/","excerpt":"","text":"HTML网页的四种布局方式：静态布局、自适应布局、流式布局、响应式布局。 静态布局静态布局就是传统的网站形式：对于PC设计一个居中布局，窗口缩小时，内容被遮挡，呈现横竖向滚动条。对于移动设备，单独见一个m.域名及相应的移动网站。 自适应布局自适应布局的特点是分别为不同的屏幕分辨率定义布局（采用媒体查找）。布局切换时页面元素发生改变，但在每个布局中，页面元素不随窗口大小调整发生变化。可以把自适应布局看作是静态布局的一个系列。 流式布局流式布局的特点是页面元素的宽度按照屏幕进行适配调整，主要的问题是如果屏幕尺度跨度太大，那么相对其原始设计而言过小或过大的屏幕不能正常显示。流式布局之所以能按照屏幕进行适配是因为划分区域的参数使用百分比（搭配min-,max-属性使用）。然后后来出现弹性布局，包裹文字的个元素的尺寸采用em作单位，em的实际大小是相对于其上下文的字体大小而言的。如果给body标签设置文字大小是100%，给其他文字都使用相对单位em，那这些文字都会受body上的初始声明的影响。 响应式布局响应式布局的特点是分别为不同的屏幕分辨率定义布局，同时，在每个布局中，应用流式布局的概念，即页面元素的宽度随着窗口调整而自动适配。响应式布局看作是流式布局和自适应布局设计理念的融合。 具体效果可以参照：http://wow.techbrood.com/fiddle/1753","categories":[],"tags":[],"keywords":[]},{"title":"css3 box-sizing属性","slug":"css3-box-sizing属性","date":"2017-07-12T13:54:21.000Z","updated":"2017-07-12T14:35:29.803Z","comments":true,"path":"2017/07/12/css3-box-sizing属性/","link":"","permalink":"https://aliceflaviawang.github.io/2017/07/12/css3-box-sizing属性/","excerpt":"","text":"box-sizing属性可以为三个值之一：content-box(默认),border-box,padding-box。content-box:border和padding不计算入width之内padding-box:padding计算入width内border-box:border和padding计算如入width之内，其实就是怪异模式。1234567891011121314151617181920212223242526272829&lt;style type=&quot;text/css&quot;&gt; .content-box&#123; box-sizing:content-box; -moz-box-sizing:content-box; width: 100px; height: 100px; padding: 20px; border: 5px solid #E6A43F; background: blue; &#125; .padding-box&#123; box-sizing:padding-box; -moz-box-sizing:padding-box; width: 100px; height: 100px; padding: 20px; border: 5px solid #186645; background: red; &#125; .border-box&#123; box-sizing:border-box; -moz-box-sizing:border-box; width: 100px; height: 100px; padding: 20px; border: 5px solid #3DA3EF; background: yellow; &#125;&lt;/style&gt; 后记 CSS calc()calc()可以理解成一个函数，用来指定元素的长度。可以使用calc()给元素的border、margin、padding、font-size和width等属性设置动态值（如：width: calc(100% - 100px)）。calc()使用规则 使用”+”、 “-“、 “*”、 “/“四则运算 可以使用百分比、px、em、rem等单位 表达式中有”+”和”-“时，其前后必须有空格，如：width: calc(100%++5px)这种写法是错误的例子：使用三列布局的时候，使用calc()可以动态设定中间列的宽度12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;test&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .wrapper&#123; width: 100%; &#125; .left&#123; float: left; width: 100px; background-color: blue; &#125; .right&#123; float: left; width: 100px; background-color: red; &#125; .main&#123; float: left; width: calc(100% - 200px); background-color: #ccc; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;wrapper&quot;&gt; &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt; &lt;div class=&quot;main&quot;&gt;main&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; inline-block使用inline-block也可以实现三列布局，但是因为inline-block中会自带缝隙（是由于标签段之间的空格造成的），所以会造成main的宽度设为 calc(100% - 200px)时将right挤出去了。解决办法有很多，比如设置margin值为负，也可以将wrapper的font-size设为0，将子div的font-size设成正常值。flexflex的话要更方便123456789101112131415.wrapper&#123; display: flex; &#125; .left&#123; flex: 0 1 100px;/*设置成占据主轴的空间 */ background-color: blue; &#125; .right&#123; flex: 0 1 100px; background-color: red; &#125; .main&#123; flex:auto;/*实际上为1 1 auto */ background-color: #ccc; &#125;","categories":[],"tags":[],"keywords":[]},{"title":"Flex布局","slug":"Flex布局","date":"2017-07-12T08:43:23.000Z","updated":"2017-07-12T12:51:04.654Z","comments":true,"path":"2017/07/12/Flex布局/","link":"","permalink":"https://aliceflaviawang.github.io/2017/07/12/Flex布局/","excerpt":"","text":"网页布局是CSS的一个重点应用。布局的传统的解决方案，基于盒装模型，依赖于display属性+position属性+float属性。它对于那些特殊布局非常不方便，比如垂直居中就不容易实现。Flex布局，可以简便、完整、响应式地实现各种页面布局。 Flex布局是什么？Flex是Flexible Box的缩写，意为弹性布局，用来为盒状模型提供最大的灵活性。任何一个元素都可以指定为Flex布局，设为Flex布局之后，子元素float、clear和vertical-align属性将失效。 基本概念采用Flex布局的元素，成为Flex容器(flex container)，它的所有子元素自动成为容器成员，称为项目（flex item)。容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end;交叉轴的开始位置叫做cross start，结束位置叫做cross end。项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 容器的属性 flex-dirction flex-wrap flex-flow justify-content align-items align-contentflex-directionflex-direction决定主轴的方向（即项目的排列方向）1234567.box&#123; flex-direction:row|row-reverse|column|column-reverse //row(默认值):主轴为水平方向，起点在左端 //row-reverse:主轴在水平方向，起点在右端 //column:主轴在垂直方向，起点在上沿 //column-reverse:主轴在垂直方向，起点在下沿&#125; flex-wrap默认情况下，项目都排在一条线上（又称“轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。123456.box&#123; flex-wrap:nowrap|wrap|wrap-reverse //nowrap(默认)：不换行 //warp:换行，第一行在上方 //wrap-reverse:换行，第一行在下方&#125; flex-flowflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值是row nowrap.123.box&#123; flex-flow:&lt;flex-direction&gt;||&lt;flex-wrap&gt;&#125; justify-content属性justify-content属性定义了项目在主轴上的对齐方式。12345678.box &#123; justify-content: flex-start | flex-end | center | space-between | space-around; //flex-start（默认值）：左对齐 //flex-end：右对齐 //center：居中 //space-between：两端对齐，项目之间的间隔都相等 //space-around：每个项目两侧的间隔相等。&#125; align-itemsalign-items属性定义项目在交叉轴上如何对齐12345678.box&#123; align-items:flex-start|flex-end|center|baseline|stretch; //flex:交叉轴的起点 //flex-end:交叉轴的终点对齐 //center:交叉轴的重点对齐 //baseline:项目第一行文字的基线对齐 //stretch(默认值):如果项目未设置高度或设为auto，将占满整个容器的高度&#125; align-contentalign-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。123456789.box &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch; //flex-start：与交叉轴的起点对齐。 //flex-end：与交叉轴的终点对齐。 //center：与交叉轴的中点对齐。 //space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 //space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 //stretch（默认值）：轴线占满整个交叉轴。&#125; 项目属性◾order◾flex-grow◾flex-shrink◾flex-basis◾flex◾align-self orderorder定义项目的排列顺序。数值越小，排列越靠前，默认为0.123.item&#123; order:&lt;integer&gt;&#125; flex-growflex-grow定义了项目的放大比例，默认为0，即如果存在剩余空间，也不放大。123.item&#123; flex-grow:&lt;number&gt;&#125; 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话），如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他想多一倍。 flex-shrinkflex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。123.item&#123; flex-shrink:&lt;number&gt;;&#125; flex-basisflex-basis属性定义了分配多余空间之前，项目占据的主轴（main size）。浏览器根据这个属性，计算主轴是否有多余空间，它的默认值为auto，即项目本来大小。123.item&#123; flex-basis:&lt;length&gt;|auto;&#125; 它可以设为跟width或height属性一样的值，则项目将占据固定的空间 flexflex属性是flex-grow,flex-shrink和flex-basis的简写，默认值为0 1 auto。后两个属性可选。flex属性是flex-grow，flex-shrink和flex-basis的简写，默认值为0 1 auto。后两个属性可选。12.item&#123; flex:none|[&lt;&apos;flex-grow&apos;&gt;&lt;&apos;flex-shrink&apos;&gt;?||&lt;&apos;flex-basis&apos;&gt;] 该属性有两个快捷键：auto（1 1 auto）和none(0 0 auto) align-selfalign-self属性允许单个项目与其他项目以一样的对其方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。```.items{ align-self:auto|flex-start|flex-end|center|baseline|stretch}除auto外，其他与align-items属性完全一致。","categories":[],"tags":[],"keywords":[]},{"title":"跨站脚本攻击","slug":"跨站脚本攻击","date":"2017-07-11T08:44:29.000Z","updated":"2017-07-12T03:18:38.679Z","comments":true,"path":"2017/07/11/跨站脚本攻击/","link":"","permalink":"https://aliceflaviawang.github.io/2017/07/11/跨站脚本攻击/","excerpt":"","text":"跨站脚本攻击（XSS）跨站脚本攻击（cross-site script，为了和CSS区分，缩写XSS）。发生的原因是网站将用户输入的内容输出到页面上，在这个过程中可能有恶意代码被浏览器执行。 XSS的种类1.反射型XSS它是通过诱使用户打开一个恶意链接，服务端将链接中参数的恶意代码渲染到页面中，再传递给用户由浏览器执行，从而达到攻击的目的。 2.持久型XSS持久型xss将恶意代码提交给服务器，并且存储在服务器端，当用户访问相关内容时再渲染到页面中，以达到攻击的目的，它的危害更大。 XSS防御1.输入检查对输入数据做检查，比如用户名只允许是字母和数字，一定要在后台做检查，否则数据可能绕过前端检查直接发给服务器。一般前后端都做检查，前端能过滤掉大部分无效数据。 2.输出检查对渲染到html中内容执行htmlEncode。 其他攻击方式SQL注入SQL注入与XSS类似，用户提交的数据被当成命令来执行而造成的。 SQL注入防御防止SQL注入最好的方法是使用预编译语句。不同的语言的预编译方法不同，但基本都可以处理。如果无法使用预编译方法，只能像防止XSS那样对参数进行检查和编码。 点击劫持点击劫持是从视觉上欺骗用户。攻击者使用一个透明的iframe覆盖到网页上，诱使用户在该网页上操作，而实际点击却是点在透明的iframe页面。点击劫持延伸出很多攻击方式，有图片覆盖攻击、拖拽劫持等。 点击劫持的防御针对iframe的攻击，可使用一个http头：X-Frame-Options，它有三种可选值： DENY：禁止任何页面的frame加载 SAMEORIGIN:只有同源页面的frame可加载 ALLOW-FROM:可定义允许frame加载的地址针对图片覆盖攻击，则注意使用预防XSS的方法，防止HTML和JS注入。","categories":[],"tags":[],"keywords":[]},{"title":"CSRF攻击与防御","slug":"CSRF攻击与防御","date":"2017-07-11T06:39:07.000Z","updated":"2017-07-11T07:45:07.193Z","comments":true,"path":"2017/07/11/CSRF攻击与防御/","link":"","permalink":"https://aliceflaviawang.github.io/2017/07/11/CSRF攻击与防御/","excerpt":"","text":"CSRFCSRF:跨站点请求伪造(cross-site request forgery)。攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说是完全合法的，但是却完成了攻击者所期望的一个操作。 CSRF攻击的原理及过程 用户打开浏览器，访问网站A，输入用户名和密码请求登陆网站A 在用户信息验证通过之后，网站A产生cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A； 用户未退出网站A之前，在同一个浏览器中，打开一个Tab页访问网站B 网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A 浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带cookie信息，向网站A发出请求。网站A并不知道请求其实是由B发起的，所以会根据用户的cookie信息以用户的权限处理该请求，导致来自B的恶意被代码执行。CSRF漏洞检测检测CSRF是一项比较繁琐的工作，最简单的方法是抓取一个正常请求的数据包，去掉Referer字段后再重新提交，如果该提交有效，那么基本可以确定CSRF漏洞存在。CSRF攻击防御1.验证码验证码不单单用来防止注册机的暴力破解，还可以有效防止CSRF的攻击。不过随着html5的发展，利用canvas标签，前端也能识别验证码的字符，让CSRF生效。2.referer checkreferer记录了该http请求的来源地址，http referer是request header的一部分，当浏览器向web服务器发出请求的时候，一般会带上referer，告诉服务器从哪个站点链接过来。服务器通过判断请求头中的referer，也能避免CSRF攻击。3. tokenCSRF攻击之所以成功是因为黑客可以在不知道验证信息的情况下直接利用用户的cookie来通过安全验证。可以在http请求中以参数的形式加入一个随机产生的token。（比如get方式放拼接到url，post方式以参数方式）4.在http头中自定义属性并验证也是使用token并进行验证，但是不是以参数的形式置于http请求中，而是把它放在http头中自定义的属性里。","categories":[],"tags":[],"keywords":[]},{"title":"$.ready()与window.onload的区别","slug":"ready-与window-onload的区别","date":"2017-07-10T14:33:43.000Z","updated":"2017-07-10T14:41:27.396Z","comments":true,"path":"2017/07/10/ready-与window-onload的区别/","link":"","permalink":"https://aliceflaviawang.github.io/2017/07/10/ready-与window-onload的区别/","excerpt":"","text":"区别有三点： 1、执行时机$.ready()是网页的所有DOM结构绘制完毕后就执行，可能DOM元素关联的东西还没加载完window.onload必须等网页里所有的内容都加载完毕后（包括图片）才执行 2、编写个数$.ready()可以编写多个，每个都执行window.onload不能编写多个（编写多个时，只执行最后一个） 3、简化写法$.ready实际上是$(document).ready的简写，而window.onload没有简写 后记：DOM文档的加载过程 解析HTML结构 加载外部脚本和样式文件 解析并执行脚本代码 DOM树构建完成 //DOMContentLoaded 加载图片等外部文件 页面加载完 //load所以$.ready()是在第4步后执行，window.onload是在第6步后执行","categories":[],"tags":[],"keywords":[]},{"title":"javascript是单线程","slug":"javascript是单线程","date":"2017-07-10T11:51:27.000Z","updated":"2017-07-10T13:32:15.718Z","comments":true,"path":"2017/07/10/javascript是单线程/","link":"","permalink":"https://aliceflaviawang.github.io/2017/07/10/javascript是单线程/","excerpt":"","text":"首先看下面的代码：1234567function foo()&#123; console.log(&apos;first&apos;); setTimeout(function()&#123;console.log(&apos;second&apos;)&#125;,5);&#125;for(var i=0;i&lt;100;i++)&#123; foo();&#125; 执行结果会首先输出first，然后全部输出second；尽管中间结果会超过5ms，为什么？ javascript是单线程的因为JS运行在浏览器中，是单线程的，每个window一个JS线程，既然是单线程，在某个特定时刻只有特定的代码能够背执行，并阻塞其他代码。而浏览器是事件驱动（Event driven）的，浏览器中很多行为是异步（Asynchronized）的，会创建事件并放在执行队列中。javascript引擎是单线程处理它的任务队列，你可以理解成就是普通函数和回调函数构成的队列。当异步事件发生时，如鼠标点击事件、定时器触发事件、XMLHttpRequest完成回调触发等，将它们放入执行队列，等待当前代码执行完成。 异步事件驱动浏览器是事件驱动的，浏览器中很多行为是异步的。当一个异步事件发生时，它就进入事件队列。浏览器有个内部大消息循环，EventLoop(事件循环)，会轮询大的事件队列并处理事件。 浏览器不是单线程的虽然JS运行在浏览器中，是单线程的，每个window一个JS线程，但浏览器不是单线程的，例如Webkit或是Gecko引擎，都可能有如下线程： javascript引擎线程 界面渲染线程 浏览器触发线程 Http请求线程很多人搞不清，如果js是单线程的，那么谁去轮询大的Event Loop事件队列？答案是浏览器会有单独的线程去专门处理这个队列Ajax异步请求是否是真的异步Ajax请求确实是异步的，这请求是由浏览器新开一个线程请求，事件回调的时候放入Event loop单线程事件队列等候处理。setTimeout(func,0)的作用setTimeout(func,0)非常有用，单丝不是模拟多线程，前面已经说过一个window一个js线程，setTimeout(func,0)主要是告诉js引擎，在0ms后把func放在主事件队列中，等待当前的代码执行完毕后再执行。注：重点是改变了代码的流程，把func的执行放到了等待当前的代码执行完毕后再执行。非阻塞js的实现js在浏览器中需要被下载、解释并执行这三步。尽管浏览器可以实现多线程并行下载，但是必须依次执行。要实现非阻塞js有两个方法： html5中的defer和async关键字 123456&lt;script type=&quot;test/javascript&quot; defer src=&quot;foo.js&quot;&gt;&lt;/script&gt;//没有defer或async，浏览器会立即加载并执行指定的脚本，“立即”的意思是指不等待后续载入的文档元素，读到就立即执行&lt;script type=&quot;test/javascript&quot; async src=&quot;foo.js&quot;&gt;&lt;/script&gt;//有async，加载和渲染后续文档元素的过程将和foo.js的加载与执行并行进行（异步）&lt;script type=&quot;test/javascript&quot; defer src=&quot;foo.js&quot;&gt;&lt;/script&gt;//有defer，加载后续文档元素的过程将和foo.js的加载并行进行(异步)，但是foo.js的执行要在所有元素解析完成之后，DOMContentLoaded事件触发之前完成 动态加载js（比如：使用setTimeout方法） 后记：setTimeout和setIntervalsetTimeout和setInterval都是指过一段时间，再进行某项操作。setTimeout是让一段代码在指定时间运行（次数是一次），而setInterval是让一段代码每过指定时间就运行一次setInterval的坑：如果间隔时间可能小于定时调用的代码的执行时间，而js是单线程，将定时调用的代码插入到队列中，但是代码中如果已经有了一份没有执行的同意的代码，时间间隔或许会被跳过。","categories":[],"tags":[],"keywords":[]},{"title":"Web语义化","slug":"Web语义化","date":"2017-07-10T08:53:48.000Z","updated":"2017-07-10T09:29:13.939Z","comments":true,"path":"2017/07/10/Web语义化/","link":"","permalink":"https://aliceflaviawang.github.io/2017/07/10/Web语义化/","excerpt":"","text":"web语义化的含义web语义化是指在进行html结构、表现、行为设计时，尽量使用语义化标签，使程序简洁明了，易于进行web操作和网站SEO，方便团队协作的一种标准，以期实现一种“无障碍”的web开发。SEO:搜索引擎优化，指对网站进行站内优化和站外优化，从而提高网站关键词排名以及公司产品的曝光度。 web语义化的作用 有利于机器识别，方便SEO 代码简洁明了，利于阅读和维护，方便以后扩展 有利于团队协作，减少出错率，使工作有个统一标准web语义化分类1、HTML标签语义化HTML为网页文档提供上下文结构和含义。对于HTML体系而言，Web语义化是指使用恰当的标签，是页面有良好的结构，让页面元素有含义，便于被浏览器、搜索引擎解析。一个经典的页面结构：2、ARIA无障碍web规范应用于HTML的ARIA有两部分组成：role和aria-*其中role标识了一个元素的作用，aria-描述了与之有关的事物特征及状态比如：作用是导航3、CSS命名语义化css语义就是class和id命名的语义，用易于理解的名称对html标签附加class和id命名。如果说html语义化是给机器看的，那么css命名的语义化就是给人看的。良好的css命名减少沟通调试成本。4、URL语义化url语义化，可以使得搜索引擎或者爬虫更好的理解当前url所在目录所需要表达的内容；而对于用户来说，通过url也可以判断上一级目录或者下一级目录想要表达的内容，可以提高用户体验。","categories":[],"tags":[],"keywords":[]},{"title":"Bootsstrap实现原理","slug":"Bootsstrap实现原理","date":"2017-07-10T06:30:43.000Z","updated":"2017-07-10T08:12:44.199Z","comments":true,"path":"2017/07/10/Bootsstrap实现原理/","link":"","permalink":"https://aliceflaviawang.github.io/2017/07/10/Bootsstrap实现原理/","excerpt":"","text":"1、整体架构下图为bootstrap整体架构图，共分为六大部分 1.1、12栅格系统12栅格系统就是把网页的总宽度平分为12份，我们可以自由组合。栅格系统使用的总宽度可以不固定，Bootstrap是按百分比进行平分。12栅格系统是整个Bootstrap的核心功能，也是响应式设计核心理念的一个实现形式。 1.2、jQueryBootstrap所以的javascript插件都依赖于jQuery 1.10+，如果要使用这些插件，那就必须引入jquery库。如果只使用css组件，那就可以不引用它了。 1.3、响应式设计响应式是一个理念而非功能，Bootstrap的内容都是以响应式设计为设计理念来实现的。响应式设计的目的：让页面有能力自动响应用户的设备环境。响应式网页设计就是一个网站兼容多个终端，而不是为每个终端做一个特定的版本。实践方式：由多方面决定，包括弹性网格和布局、图片、css媒体查询的使用等 2、栅格系统2.1 实现原理通过定义容器，平分12份（默认），再调整内外边距，最后结合媒体查询，就制作出了强大的响应式的栅格系统。 2.2 工作原理 一行数据（row）必须包含在.container中，以便为其赋予合适的对其方式和内边距 使用行（row）在水平方向创建一组（column） 具体内容应放置于（column）内，而且只有列（column）可以作为行（row）的直接子元素 使用像.row和.col-xs-4这样的方式来快速创建栅格布局 通过设置padding从而创建列（column）之间的间隔，然后通过第一列和最后一列设置负值的margin从而抵消掉padding的影响 栅格系统中的列是通过指定1到12的值来表示其跨越的范围container的作用 提供宽度限制。container随着页面宽度变化而变化，由于column的宽度是基于百分比的，所以它们的宽度不用去管。 提供左右padding，以至于文本内容不会触及浏览器边缘。Row Row是column的存放容器，Row中最多能放12个左浮动的column Row有个特殊的地方就是左右-15px的margin，这样刚好抵消了父容器container中的15px的paddingColumncolumn有左右15px的padding，所以位于两边的column有15px的padding，可以是内容不会碰到container的边界嵌套由于container和column都有15px的padding，所以嵌套时column就相当于container了，这样可以实现任意嵌套","categories":[],"tags":[],"keywords":[]},{"title":"前端面试准备","slug":"前端面试准备","date":"2017-07-03T09:03:08.000Z","updated":"2017-08-17T07:00:22.167Z","comments":true,"path":"2017/07/03/前端面试准备/","link":"","permalink":"https://aliceflaviawang.github.io/2017/07/03/前端面试准备/","excerpt":"","text":"1、cookie的优点及弊端如果步骤5携带的是过期或者错误的cookie，那么将认证失败，返回至要求身份认证页面。 优点：极高的扩展性和可用性1、通过良好的编程，控制保存在cookie中的session对象的大小2、通过加密和安全传输技术（SSL），减少cookie被破解的可能性3、只在cookie中存放不敏感数据，即使被盗也不会有重大损失4、控制cookie的生命期，使之不会永远有效。 缺点：1、cookie数量和长度的限制。每个domain最多只能有20条cookie，每个cookie长度不能超过4KB，否则会被截掉。2、安全性问题。如果cookie被拦截了，就可以获取所以的session信息。即使加密也于事无补，因为拦截者不需要知道cookie的意义，只需要原样转发cookie就行了。3、有些状态不可能保存在客户端。如：为了防止重复提交表单，在服务器端保存计数器，如果计数器放在客户端就起不了任何作用。 sessionsession是一种服务器端机制，服务器类似于散列表的结构来保存信息。当程序需要为客户端请求创建一个session时，服务器首先检查这个客户端的请求是否包含了session标志（session id），如果已包含则说明服务端曾经为用户创建过session，服务器就按照session id将session检索处理（检索不到会新建），如果不包含则会新建session并生产与之关联的session id（既不重复也不容易被找到规律仿造），找个session id将在本次响应中返回给客户端保存（保存这个session id的方式可以用cookie，另外还有两种方式：基于url path parameter默认支持的，基于SSL，默认不支持）。 cookie与session的区别 cookie有大小和个数的限制，单个cookie大小不超过4kb，很多浏览器限制一个站点最多保存20个cookie cookie保存在客户端，session保存在服务器端 cookie不是很安全，别人可以分析存放在本地的cookie并进行欺骗；因此建议将登陆等重要信息保存在服务器端，其他信息放在cookie中 session会在一定时间内保存在服务器上，当访问增多，会比较占用服务器的性能，考虑到减轻服务器的负担应当使用cookie2、浏览器的本地存储（web storage）js提供了sessionStorage和globalStorage。在HTML5中提供了localStorage取代了globalStorage。sessionStorage用于本地存储一个会话（session）中的数据，这些数据只在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁，sessionStorage不是一种持久化的本地存储。而localStorage用于持久化的本地存储，除非主动删除数据，否则数据永远不会过期。3、web storage和cookie的区别web storage与cookie类似，但是它是为更大容量存储设计的。cookie的大小受限，并且每次请求一个新的页面的时候cookie都会被发送过去，这样无形浪费了带宽，另外cookie还指定了作用域，不可以跨域调用。除此之外，web storage拥有setItem, getItem, removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie,getCookie。但是cookie也是不可或缺的：cookie的作用是与服务器交互，作为HTTP规范的一部分而存在，而web storage仅仅作为本地存储数据而生。 CSS相关问题1、display:none和visibility：hidden的区别display:none 隐藏对应的元素，不给它分配空间，周围元素会合拢visibility:hidden 隐藏对应的元素，但是在文档布局空间仍保留原来的空间 2、css中link和@import的区别1）link属于HTML标签，@import是css提供的2）页面加载时，link同时被加载，而@import页面加载完后被加载的3）link无兼容问题4）link的样式权重高于@import 3、position的absolute和fixed共同点：1、改变行内元素的呈现方式，display被设置为block2、让元素脱离普通流，不占空间3、默认会覆盖到非定位元素上不同点：absolute是相对于它最近的非static定位的祖先元素来定位的fixed是根据屏幕视窗来定位的，屏幕滚动时位置不变 4、清除浮动的三种方式首先说下浮动与绝对定位的区别。float是一种不彻底的脱离文档流的方式，绝对定位是彻底的。float脱离文档流的时候，其他盒子会无视这个元素，但其他盒子内的文本依然会为这个元素让出位置，环绕在周围；而绝对定位，其他盒子内的文本都会无视它（不会让出位置）。比如：A为绝对定位，如果A使用的绝对定位，元素B会占据B之前的位置，与元素A重合在一起，并被元素A覆盖。若A为float：left，B内的文本跑到了A的右边，即实现了文字环绕浮动元素的功，元素B的背景和元素A的背景重合了一部分，这就是浮动元素脱离了正常的文档流但还是会影响布局。清楚浮动的三种方式：12345&lt;div class=&quot;outer&quot;&gt; &lt;div class=&quot;div1&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;div2&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;div3&quot;&gt;3&lt;/div&gt;&lt;/div&gt; css样式：123456789101112131415.outer&#123;border:1 px solid #ccc;background:#fc9;color:#fff;margin:50px auto;padding:50px;&#125;.div1&#123;width:80px;height:80px;background:red;float:left;&#125;.div2&#123;width:80px;height:80px;background:blue;float:left;&#125;.div3&#123;width:80px;height:80px;background:green;float:left;&#125; 方法一：增加新元素，应用clear：both123456&lt;div class=&quot;outer&quot;&gt; &lt;div class=&quot;div1&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;div2&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;div3&quot;&gt;3&lt;/div&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;&lt;/div&gt; CSS:1.clear&#123;clear:both;&#125; 在.outer的最后加入一个空的（只要是块就行，因为只有块才可以撑满），因为它在.outer的最下面，并且不是float的，它的存在定义了.outer的高度。必须有clear：both，不然只是标准流，会紧贴在第一行的底部，不能涵盖其他div。注：clear的取值如下：none：默认值，允许两边都可以浮动left：不允许左边浮动对象right：不允许右边有浮动对象both：不允许有浮动对象清除浮动只能影响清除的元素本身，不能影响其他元素，比如，div1的右边有浮动元素div2,在div1的css样式中加入clear：right不起任何作用，只能在div2的css样式中加clear：left。要想让上述三个div垂直排列，可以增加css样式：123456.div2&#123;clear:left;&#125;.div3&#123;clear:left;&#125; 方法二：overflowfloat元素的父元素设置overflow:hidden|auto|scroll(不能使用visible)，overflow不是清除float而是新建BFC，BFC类似于编程语言里的作用域，作用域变了，float就影响不到了，只有clear可以取消float的影响。123.outer&#123;overflow:auto;&#125; 方法三：伪元素：after利用:after在元素内部插入一个元素块，从而达到清除浮动的效果，其实现原理类似于clear：both。区别在于：clear是在html插入一个div.clear标签，而outer利用其伪类:after在元素内部增加了一个类似于div.clear的效果。12345678.outer:after&#123; content:&quot;.&quot;; display:block; clear:both; visibility:hidden; height:0; width:0;&#125; 5、CSS的盒子模型：W3C盒子模型和IE盒子模型盒模型：content（内容）、padding（填充）、border（边框）、margin（边界）IE的width包含padding和border，而W3C仅包含content。 在这个地方顺便提下css的box-sizing属性，box-sizing主要是允许以特定的方式定义匹配某个区域的特定元素。有三种取值：1.content-box：规定宽度高度，不包括padding、border、margin 2. border-box:规定宽度高度，包括padding和boder 3. inherit：规定从父元素继承box-sizing属性的值。 6、CSS选择符有哪些？哪些属性可以继承？优先级算法如何计算？CSS3新增的伪类？一1、id选择器 #id2、类选择器 .classname3、标签选择器 p，span4、相邻选择器 div+p5、子选择器 ul&gt;li6、后代选择器 li a7、通配符选择器 *8、属性选择器 a[rel=”external”]9、伪类选择器 a:hover, li:nth-child 二可继承的样式（大部分针对字体）：font-size,font-family,color,text-indent不可继承的样式：border，padding，margin，width，height 三CSS优先级由四个级别和四个级别出现的次数决定，四个级别分别为：行内选择符、ID选择符、类选择符、元素选择符。CSS specificity是一个四位数用来衡量优先级。如：div #id {font-size:12px;}1个div元素，specificity为0,0,0,1一个id选择符，specificity为0,1,0,0最终：specificity为0,1,0,1注意： ！important的优先级是最高的，但出现冲突时则需比较四位数 优先级相同时采取就近原则 继承得来的属性，优先级最低 specificity从左到右比较，大的优先级越高四CSS伪元素： :after匹配该元素的一个虚拟的最后子元素，配合content使用，默认为行内元素 :before匹配该元素的一个虚拟的最先子元素，与:after类似 :first-line匹配元素的第一行 :first-letter匹配元素的第一个字符 :selection匹配用户鼠标选中的部分（只应用background、color、cursor、outline属性）CSS伪类： :link未被访问的链接 :visited被访问过的链接 :hover用户鼠标移至其上方 :active被激活的元素，通常指鼠标按下到松开的那段时间 :focus元素成为焦点 :first-child元素为其父元素的第一个子元素 :last-child元素为其父元素的最后一个子元素 :nth-child(an+b)匹配为其父元素的第an+b个子元素的元素 :nth-last-child(an+b)同上但是顺序相反 :first-of-type匹配所有子元素类型第一个出现的元素 :last-of-type匹配元素中所有子元素类型最后一个出线的元素 :enabled :disabled 控制表单控件的禁用状态 ：checked 单选框或是复选框被选中注意：first-child和first-of-type的区别，first-child匹配的是其父元素的第一个子元素，而first-of-type匹配到的是该类型的第一个。举个例子：123456&lt;div&gt; &lt;p&gt;第一个子元素&lt;/p&gt; &lt;h1&gt;第二个子元素&lt;/h1&gt; &lt;span&gt;第三个子元素&lt;/span&gt; &lt;span&gt;第四个子元素&lt;/span&gt;&lt;/div&gt; p:first-child 匹配到p元素，因为p是div的第一个子元素h1:first-child 匹配不到任何元素，因为h1不是第一个子元素同理span:first-child也匹配不到p:first-of-type 匹配到p元素，因为p元素是div所有为p的子元素的第一个h1:first-of-type 匹配到h1元素，因为h1元素是div所有为h1的子元素的第一个span:first-of-type 匹配到第三个子元素span，这里div有两个为span的元素，匹配到的是第一个 7、列出display的值，说明他们的作用。position的值，relative和absolute分别是对于谁进行定位。 none 此元素不会被显示 block 此元素会显示为块级元素，前后会带有换行符 inline 此元素会被现实为内联元素，前后没有换行符 inline-block 行内块元素 list-item 此元素作为列表显示 问的比较多的就是inline,block,inline-block，详细比较一下它们： display：block block元素会独占一行，多个block元素会各自新起一行。默认情况下，block元素宽度自动填满其父元素宽度 block元素可以设置width、height属性。块级元素即使设置了宽度，仍然独占一行 block元素可以设置margin和padding属性display:inline inline元素不会独占一行，多个相邻的行内元素会排列在同一行里，直到一行排列不下，才会新换一行，其宽度随元素的内容而变化 inline元素设置width、height无效 inline元素的margin和padding属性，水平方向的padding-left,padding-right,margin-left,margin-right都产生边距效果，但竖直方向的padding-top,padding-bottom,margin-top,margin-bottom都不起作用。display：inline-block简单来说，就是将对象呈现为inline对象，但对象的内容作为block对象呈现。之后的内联对象会被排列在同一行内。比如给一个link（a元素）inline-block属性值，使其既具有block高度宽度特性又具有inline同行特性。 2. static 默认值，元素处于正常的文档流之中，top,right,bottom,left,z-index（设置元素的堆叠顺序）属性无效 relative 元素相对原本正常位置的定位，不改变布局，这样会在此元素原本所在的位置留下空白，对display为表格型的元素无效 absolute 不为元素预留空间，元素相对于与它最近的非static定位的祖先元素来定位。元素可以设置外边距（margin），并且不会与其他边距合并（即形成一个BFC） fixed 不为元素预留空间，相对屏幕视窗定位，屏幕滚动时位置不变 sticky （新属性，目前仅firefox实现）平时为relative，在特定条件下变为fixed，类似于实现浮动条-inherit 从父元素继承position属性的值8、对BFC规范的理解BFC，块级格式上下文，一个创建了新的BFC的盒子是独立布局的，盒子里面的子元素的样式不会影响到外面的元素。在同一个BFC中的两个毗邻的块级盒在垂直方向的margin会发生折叠。9、CSS spiriteCSS spirite把网页中的背景图片整合到一张图片文件中，再利用CSS的background-image, background-rep10、text-overflow(这个属性貌似问的比较多)text-overflow规定文本溢出包含元素时发生的事情。包含以下属性： clip:修剪文本 ellipsis：显示省略号来代表被修剪的文本 string：使用给定的字符串来代表被修剪的文本注意ellipsis要与overflow：hidden，white-space:nowrap一起使用(white-space规定了文本不换行) HTML1、DOCTYPE&lt;!DOCTYPE&gt;位于html文档的第一行，它并不是一个html标签。它的作用是告诉浏览器以哪种模式来解析文档。HTML 5只有一种DOCTYPE声明，&lt;!DOCTYPE html&gt;HTML 4.01有三种：strict、transitional、frameset。 2、HTML5新特性 语义化标签（header、nav、footer、aside、article、section） 拖放事件（drag类事件） 跨文档消息传递（postMessage） 媒体元素（audio、video标签） 地理位置定位（navigator、geolocation）API 历史状态管理（更新history对象，pushstate等）HTML5离线存储技术用户离线时，可以正常访问站点时，联网可以更新缓存，使用方法就是在html标签中加入manifest属性，如下：1234&lt;!DOCTYPE html&gt;&lt;html manifest=&quot;cache.manifest&quot;&gt;...&lt;/html&gt; cache.manifest文件格式如下：12345678910111213CACHE MANIFESTCACHE:js/app.jscss/style.cssNETWORK:resource/logo.pngFALLBACK:/ /offline.html 离线缓存的manifest一般由三个部分组成： CACHE:表示需要离线存储的资源列表 NETWORK:表示在它下面列出来的资源只有在有线的情况下才能访问，他们不会被离线存储 FALLBACK:(实例里’/ /‘不是注释）表示如果访问第一个资源失败，那么就使用第二个资源来替换它，比如上面这个文件表示的就是如果访问根目录下任何一个资源失败了，那么就去访问offline.html。3、iframe的优缺点优点： 重载页面时不需要重载整个页面，只需要重载页面中的一个框架页（减少了数据的传输，加快了网页下载速度 技术容易掌握，使用方便，可主要应用于不需搜索引擎来搜索的页面 方便制作导航栏缺点 最大的缺点四搜索引擎无法解读这种页面 框架结构让人迷惑 浏览器后退按钮失效（之呢个针对当前光标所在页面的前进和后退）4、如何实现浏览器多个标签页之间的通信调用localStorage、cookie等本地存储方式5、WebSocket如何兼容低浏览器WebSocket123456789101112131415161718192021//创建WebSocket实例var socket=new WebSocket(&quot;ws://licalhost:8080&quot;);//打开WebSocketsocket.onopen=function(event)&#123; //发送一个初始化消息 socket.send(&apos;I am a client and i am listening&apos;);&#125;//监听消息socket.onmessage=function(event)&#123; console.log(&apos;Client received a message&apos;); &#125;//监听关闭socket.onclose=function(event)&#123; console.log(&apos;WebSocket closed&apos;);&#125;//关闭socket//socket.close(); WebSocket是HTML5出的协议，是一个持久化的协议，相对于http这种非持久化的协议来说。WebSocket是基于http协议的，在握手阶段是一样的，不同的是http每个request接收一个response，这个response是被动的，不能主动发起。在讲WebSocket之前，先说long poll和ajax轮询。ajax轮询：让浏览器每隔几秒就发送一次请求，询问服务器是否有新消息。long pull:跟ajax轮询差不多，不过采取的是阻塞模型（不收到消息就不发response给客户端，知道有消息才返回，返回完后再次建立连接，周而复始）。这两种方式都是不断建立http连接，然后等待服务器端处理，体现了http协议的被动性。而且两种方式都非常消耗资源，ajax需要服务器有很快的处理速度和资源，long poll需要很高的并发。 WebSocket的作用WebSocket解决了http协议的被动性，服务器可以主动推送消息给客服端，只需要经过一次请求，就可以源源不断的消息传送；另外http是无状态的，每次都要传输identity info（鉴别信息）来告诉服务器你是谁，而WebSocket只需要一次握手，整个通讯过程都是建立在一次连接/状态中，避免了http的非状态性，服务器端会一直知道你的信息知道关闭请求。 如何在不支持WebSocket的客户端上使用实际上是不能，但是可以通过上面说的long poll和ajax轮询来实现类似的效果 6、null和undefined的区别nullnull表示的是一个“无”的对象，转为数值时为0典型用法： 作为函数的参数，表示该函数的参数不是对象 作为原型链的终点undefinedundefined表示的是一个“无”的原始值，转为数值是NaN典型用法： 变量被声明了，但是没有赋值时，就等于underfined 调用函数时，应该提供的参数没有提供，该参数等于undefined 对象没有赋值的属性，该属性的值为undefined 函数没有返回值时，默认返回undefined7、new操作符具体干了什么1234var Fun=function()&#123; &#125;var func=new Func();&#125; new共经历了四个阶段： 创建一个空对象1var obj=new Object(); 2、设置原型链1obj._proto_=Func.prototype;(继承构造函数的属性和方法) 3、让Func中的this指向obj，并执行Func函数体1var result=Func.call(obj); 8、跨域问题同源策略在讲跨域问题之前先说同源策略。一个url由协议、域名、端口和路径组成，如果两个url协议、域名、端口相同，则表示它们同源。浏览器的同源策略是指一个域上加载的脚本不允许访问另一个域的文档属性。 跨域方法1、跨域资源共享（CORS)创建CORS请求对象因为CORS是属于XMLHttpRequest2的一部分，所以主要要做的就是区分IE8/9和不支持XMLHttpRequest的浏览器1234567891011121314151617181920212223function createCoresRequest(method,url)&#123; var xhr=new XMLHttpRequest(); if(&apos;withCredentials&apos; in xhr)&#123; //支持CORS //检查XMLHttpRequest对象是否有&quot;withCredentials&quot;属性，withCredentials仅存在xmlHttpRequest对象里 xhr.open(method,url,true); &#125; else if(window.XDomainRequest)&#123; //XDomainRequest仅存在IE中，是IE用于支持CORS请求的方式 xhr=new C=XDomainRequest(); xhr.open(method,true); &#125; else&#123; //不支持CORS xhr=null; &#125; return xhr; &#125; var xhr=createCORSRequest(&quot;GET&quot;,url); if(!xhr)&#123; throw new Error(&apos;CORS not supported&apos;); &#125; xhr.send();//发送请求 CORS是W3C提出的跨域请求方案，需要服务器端的支持。服务器端对CORS的支持主要通过设置HTTP头Access-Control-Allow-Origin实现，如果浏览器检测到相应的设置，就能允许AJAX跨域请求。 2、通过jsonp跨域JSONP也叫填充式json，是应用json的新方法，只不过是包含在函数中调用json，例如：1callback(&#123;&quot;name&quot;,&quot;jack&quot;&#125;) JSONP由两部分组成：回调函数和数据。回调函数是当响应到来时在页面中调用的函数，数据是传入回调函数的json数据。在js中直接通过xmlHttpRequest请求不同域上的数据时，是不行的，但是，在页面上引入不同域的js脚本文件却是可以的，jsonp正是利用这个特性来实现的。123456&lt;script type=&quot;test/javascript&quot;&gt; function dosomething(jsondata)&#123; //处理json数据 &#125;&lt;/script&gt;&lt;script src=&quot;http://example.data/data.php?callback=dosomething&quot;&gt;&lt;/script&gt; js文件载入成功后会执行url中指定的函数，并把需要的json数据作为参数传入该函数。如果页面使用的是jquery，那么通过它封装的方法就能很方便的来进行JSONP操作。12345&lt;script type=&quot;text/javascript&quot;&gt; $.getJSON(&quot;http://example.data/data.php?callback=?,function(jsondata)&quot;)&#123; //处理获得json数据 &#125;）&lt;/script&gt; jQuery会自动生成一个全局函数来替换callback=？中的？，之后获取的数据又会自动销毁，实际上就是起一个临时代理函数的作用。$.getJSON方法会自动判断是否跨域，如果不跨域，就用普通的ajax方法，跨域的话，就会异步加载js文件的形式来调用jsonp的回调函数。 JSOPN的优缺点 优点：不像XMLHttpRequest对象实现得Ajax请求那样受到同源策略的限制，它的兼容性更好，不需要XMLHttpRequest或ActiveX的支持，并且在请求完毕后可以通过调用callback方式回传结果。 缺点：它支持GET请求而不支持POST等其他类型的HTTP请求，它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行javascript调用的问题。CORS和JSONP的对比 JSONP只支持GET类型的http请求，CORS支持所有类型的http请求 CORS，开发者可以使用普通的XMLHttpRequest发起请求和获取数据，有更好的错误处理 JSONP主要被老的浏览器支持，它们往往不支持CORS，对大多数现代浏览器都已经支持CORS了3、通过修改document.domain来跨域（iframe）浏览器的同源策略的两个限制：一、不能通过ajax方法去请求不同源的文档；二、浏览器中不同框架是不能进行js交互操作的。比如：有一个页面，它的地址是”http://www.example.com/a.html&quot;，这个页面里有个iframe，它的iframe的src是&quot;http://example.com/a.html&quot;，很显然这个页面与它的iframe框架是不同域的，所以无法通过js代码来获取iframe的东西。此时document.domain就排上用场了，但是document.domain的设置有限制，只能将其设置成自身或者父域，且主域必须相同。 “http://www.example.com/a.html&quot;页面设置document.domain 1234567&lt;iframe id=&quot;iframe&quot; src=&quot;http://example.com/a.html&quot; onload=&quot;test()&quot;&gt;&lt;/iframe&gt;&lt;script type=&quot;text/javascript&quot;&gt; document.domain=&quot;example.com&quot;;//设置成主域 funtion test()&#123; alert(document.getElementById(&quot;#ifrme&quot;).contentWindow);//可取得子窗口的window对象 &#125;&lt;/script&gt; “http://example.com/a.html&quot;设置document.domain 1234&lt;script type=&quot;text/javascript&quot;&gt; document.domain=&quot;example.com&quot;;//设置成主域&lt;/script&gt; 注：document.domain只适用于不同子域的框架中。 4、window.name在一个窗口的生命周期内，不同url共享同一个window.name，每个页面对window.name都有读写权限，且window.name持久存在一个窗口在载入过的所有页面中。 5、HTML5的window.postMessage方法HTML5的新特性，不能实现与服务器交换数据，只能在不同的iframe中使用。html5提供了两个重要的接口：postMessage(send)和onmessage。一个页面通过postMessage发送消息，另一个页面监听消息。例如：父页面向子页面发送消息，父页面代码：123456789101112131415161718192021222324&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;崔涣 iframe postmessage 父页面&lt;/title&gt; &lt;script type=&quot;text/JavaScript&quot;&gt; function sendIt() &#123; // 通过 postMessage 向子窗口发送数据 document.getElementById(&quot;otherPage&quot;).contentWindow .postMessage( document.getElementById(&quot;message&quot;).value, &quot;http://cuihuan.net:8003&quot; ); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 通过 iframe 嵌入子页面 --&gt;&lt;iframe src=&quot;http://cuihuan.net:8003/test.html&quot; id=&quot;otherPage&quot;&gt;&lt;/iframe&gt;&lt;br/&gt;&lt;br/&gt;&lt;input type=&quot;text&quot; id=&quot;message&quot;/&gt;&lt;input type=&quot;button&quot; value=&quot;Send to child.com&quot; onclick=&quot;sendIt()&quot;/&gt;&lt;/body&gt;&lt;/html&gt; window.postMessage(message,targetOrigin).postMessage必须包含两个参数，第一个参数是发送的信息，第二个参数是目标域名。子页面代码：123456789101112131415161718&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;崔涣测试子页面信息&lt;/title&gt; &lt;script type=&quot;text/JavaScript&quot;&gt; //event 参数中有 data 属性，就是父窗口发送过来的数据 window.addEventListener(&quot;message&quot;, function( event ) &#123; // 把父窗口发送过来的数据显示在子窗口中 document.getElementById(&quot;content&quot;).innerHTML+=event.data+&quot;&lt;br/&gt;&quot;; &#125;, false ); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; this is the 8003 port for cuixiaozhuai &lt;div id=&quot;content&quot;&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 处于安全方面的考虑，可以对域或数据规则进行安全校验：12345678910111213141516171819202122232425window.addEventListener(&apos;message&apos;, function (event) &#123; //校验函数是否合法 var checkMessage = function () &#123; // 只获取需要的域，并非所有都可以跨域 if (event.origin != &quot;need domain&quot;) &#123; return false; &#125; var message = event.data; // 传输数据类型校验 if (typeof(message) !== &apos;object&apos;) &#123; return false; &#125; // message 的rule中包含xxx则为xxx需要字段。 return message.rule === &quot;xxx&quot;; &#125;; if (checkMessage()) &#123; // 通过校验进行相关操作 addDetailFunc(event); &#125; &#125;); 9、document.write和innerHTML的区别document.write是直接写入页面的文档流，如果写之前没有调用document.open，浏览器会自动调用open，每次写完之后重新调用该函数，会导致整个页面的重绘。innerHTML能精确到某个具体的元素来更改，只对页面的部分重绘。 10、内存泄露内存泄漏：是指任何对象不再拥有或需要它之后仍然存在。javascript有自动垃圾回收机制，一旦数据不再使用，可以将其设为null来释放引用。造成内存泄漏的集中操作： 循环引用一个DOM对象被一个javascript对象引用，与此同时又引用同一个或其他的javascript对象，这个DOM对象可能会引发内存泄露。这个DOM对象的引用将不会在脚本停止的时候被垃圾回收器回收。要想破坏引用，引用DOM元素的随想或DOM对象的引用需要被赋值为null。 闭包在闭包中引入闭包外部的变量时，当闭包结束时此对象无法被垃圾回收。 123456var a=function()&#123; var largeStr=new Array(1000000).join(&quot;x&quot;); return function()&#123; return largeStr; &#125;&#125;(); DOM泄露父节点被删除时，子节点引用没有被移除则无法回收。 123456789101112131415var select=document.querySelector;var treeRef=select(&quot;#tree&quot;);var leaf=select(&quot;#leaf&quot;);//#leaf是#tree的子节点var body=select(&quot;body&quot;);body.removeChild(treeleaf);//#tree不能被回收，因为treeLeaf还在//解决方案treeRef=null;//tree不能被回收，一位内叶子leaf还在leaf=null;//现在#tree被释放了 4、Timer定时器泄露定时器也是常见的产生泄露的地方12345678910111213for(var i=0;i&lt;90000;i++)&#123; var b=&#123; callAgain:function()&#123; var ref=this; var val=setTimeout(function()&#123; ref.callAgain(); &#125;,90000); &#125; &#125;b.callAgain();//虽然很想收回但是timer还在b=null;&#125; 11、作用域链作用域链、闭包、原型链是javascript中比较重要的知识点。 javascript中的作用域每一种语言都有作用域的概念，所谓作用域就是变量和函数的可用范围，确定了变量和函数的可见性和生命周期。javascript中有两种作用域，全局作用域和局部作用域。 全局作用域以下情况一般拥有全局作用域 全局声明的函数和变量 没有定义直接赋值的变量 所以window属性局部作用域在函数内部声明的函数和变量只能在函数内部访问到，即拥有局部作用域。作用域链javascript中，一切都是对象，包括函数。而函数有一个内部属性[[scope]]，里面包含了函数的可访问的作用域对象的集合，这个集合被称为作用域链。作用域链的创建作用域链在函数执行时创建。作用域的前端，始终是当前环境的变量对象。如果这个环境是函数，则将其活动对象作为变量对象，里面包含了该函数的所有局部变量、参数及this。把作用域链当成一个对象数组，先把该函数的变量对象push进数组，然后把函数的外部环境的作用域push进数组，下一个就是外部环境的外部环境的变量对象，一直往外直到全局环境，即作用域链的最后一个对象肯定是全局环境的作用域。作用域链的作用作用域链的目的是保证当前环境对可访问的变量和函数的有序访问。具体实现是：函数内部标识符解析时会沿着作用域链一级一级地搜索。搜索的过程始终从作用域链前端开始，直到最后一个对象即全局变量对象为止，如果找不到的话，就是undefined。这样可以保证内部变量的优先级始终大于外部变量。变量提升的问题1234567var name=&quot;123&quot;;function foo()&#123; console.log(name); //undefined var name=&quot;456&quot;; console.log(name); //456&#125;foo(); 以上例子，按常规连接，应该先输出全局变量“123”，再输出局部变量“456”，然而第一个却输出了undefined，为什么呢？因为函数在执行时首先胡创建作用域链，这是在整个函数执行之前就完成的，所以第一次输出时，该函数的变量对象已经包含了name这个变量，从而导致解析时在作用域链第一个对象就停止，，而不会访问到全局变量，同时那个时候局部变量没有赋值，所以会输出undefined。这种现象叫做变量提升。注：ES6中通过let标识符可以防止这种现象的出现 作用域链的延长部分语句可以在作用域链的前端临时增加一个变量对象，该变量对象会在代码执行后移除。主要由两种情况 with语句 try-catch语句with语句平时优化需要可以把所需对象存储在局部变量中，不推荐使用with语句，可能造成bug和性能损失。12345678function foo()&#123; var he=&quot;?name=1&quot;; with(location)&#123; var url=href+he; &#125; return url;&#125;foo(); 这里with语句把location对象添加到作用域链前端，因此在访问href时，其实是访问了location.href。在with语句执行完毕后，作用域链就返回之前的状态。 catch块12345try&#123; something();&#125;catch(e)&#123; console.log(e);&#125; 当try代码块中的语句发生错误时，执行块跳转到catch语句块，并且把一个异常对象添加到作用域的头部。在catch语句执行完毕后，作用域链就返回之前的状态。注：可以把错误处理委托给一个函数。这样的话就只执行一条语句，并且没有访问局部变量，对性能影响就比较小。12345try&#123; something();&#125;catch(e)&#123; handleError(e);&#125; 12、闭包闭包的特性 函数嵌套函数 内部的函数可以引用函数外部的参数和变量 参数和变量不能被垃圾回收机制回收闭包的定义及其优缺点闭包：是指有权访问另一个函数作用域中的变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量。闭包的缺点：常驻内存，会增加大量的内存使用，使用不当会造成内存泄漏。闭包的应用：一是前面提到的读取函数内部的变量，二是让这些变量的值始终保持在内存中。看个例子：1234567891011121314function f1()&#123; var n=999; add=function()&#123; n+=1; &#125; function f2()&#123; alert(n); &#125; return f2;&#125;var result=f1();result();//999add();result(); result实际上就是闭包f2函数，它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。为什么会这样呢？因为f1是f2的复函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制回收。另外要注意add，首先add前面没有使用var关键字，因此add是一个全局变量，而不是局部变量。其次add的值是一个匿名函数，而这个匿名函数本身也是一个闭包，所以add相当于一个setter，可以在函数外部对函数内部的局部变量进行操作。 闭包使用注意点 由于闭包会使得函数中的变量都保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页性能问题，IE中可能导致内存泄漏。解决办法是，在退出函数之前，将不适用的局部变量全部删除。 闭包会在父函数外部，改变父函数内部变量的值。如果把父函数当作对象使用，把闭包当作它的公用方法，把内部变量当作它的私有属性，这是一定要小心，不要随便改变父函数内部变量的值。13、javascript中的this一般而言，javascript中this指向函数执行时的当前对象。换句话说，这个关键字与函数的执行环境有关，与声明环境无关。所以this的指向要看如何去调用这个函数而不是声明。不同的调用方式1、作为对象的方法调用把函数赋值给对象的一个属性，然后通过该对象调用该方法，此时函数的执行环境就是这个对象，所以this指向该对象。12345678var name=&quot;haha&quot;;var obj=&#123; name:&quot;hehe&quot;, show:function()&#123; console.log(this.name); &#125;&#125;obj.show(); //hehe 换种更清晰的方式，我们把声明和调用放在两个对象里面1234567891011var obj=&#123; name:&quot;hehe&quot;, show:function()&#123; console.log(this.name) &#125;&#125;var t_obj=&#123; name:&quot;lala&quot;, show:obj_show&#125;t_obj.show(); //lala 可以看到show虽然在obj中声明过，但是通过t_obj调用了这个方法，所以此时this指向t_obj。 2、作为函数调用我们将上面的代码改一下，将obj.show赋值给全局变量show再调用，此时this绑定到全局对象。123456789var name=&quot;lala&quot;;var obj=&#123; name:&quot;hehe&quot;, show:function()&#123; console.log(this.name); &#125;&#125;var show=obj.show;show(); //lala 3、独立函数调用在函数内部调用一个函数，比如在一个对象的方法里面调用一个函数时，this会指向全局对象(讲道理的话应该指向对象），实际上是不带任何修饰的函数引用进行调用时，默认this指向全局变量。这是javascript设计比较坑的地方，平时经常使用命名一个新变量ctx(context，即上下文环境)替代this。1234567891011var name=&quot;lala&quot;;var obj=&#123; name:&quot;hehe&quot;, show:function()&#123; var test=function()&#123; console.log(this.name); &#125; test(); &#125;&#125;obj.show(); //lala 修正版12345678910111213var name=&quot;lala&quot;;var obj=&#123; name:&quot;hehe&quot;, show:function()&#123; var txt=this; console.log(this);//obj var test=function()&#123; console.log(this.name); &#125; test(); &#125;&#125;obj.show(); // hehe 再看一个例子123456789var name=&quot;lala&quot;;function b()&#123; var name=&quot;hehe&quot; function a()&#123; console.log(this.name); &#125; a();&#125;b(); //lala 修改1234567891011var name=&quot;lala&quot;;function b()&#123; var cxt=this; console.log(this);//window var name=&quot;hehe&quot; function a()&#123; console.log(ctx.name); &#125; a();&#125;b(); //lala 可以看到对比上一个例子，obj.show中的this指向obj，而第二个例子由于b是独立函数，b中的this指向全局对象，有一个误区认为this指向执行的函数，实际上不是的。 4、作为构造函数使用我们常使用new构造函数名()来创建一个对象，此时函数中的this指向新创建的对象。如果不使用new，则和普通函数一样绑定到全局对象。12345function Foo()&#123; console.log(this);&#125;var test=new Foo(); //testFoo(); //window 5、在setTimeout、setInterval和匿名函数中在setTimeout,setInterval和匿名执行时的对象为全局对象，所以this也指向全局对象。12345678910var name=&quot;lala&quot;;var obj=&#123; name:&quot;hehe&quot;, show:function()&#123; setTimeout(function()&#123; console.log(this.name); &#125;,500); &#125; &#125;obj.show(); 6、函数调用call和apply方法时两者的本质就是改变函数当前的上下文环境即this，两者的区别是call接收一个个参数，而apply接受一个参数数组。注：使用call和apply函数的时候要主要，如果传递的this值不是一个对象，javascript将会尝试使用内部ToObject操作将其转换为对象。因此，如果传递的值，如果传递的值是一个原始值比如7或者”foo”，那么就会使用相关构造函数将它转换为对象，所以原始值7通过new Number(7)被转换为对象，而字符串”foo”使用new String(“foo”)转化为对象。 7、函数调用bind方法时函数调用bind方法时会创建一个有相同函数体和作用域的函数，新函数的this指向bind的第一个参数。该方法不会调用函数，而是返回新函数。 14、prototype和原型链每个函数都有一个prototype属性，这个属性是指向一个对象的引用，这个对象称为原型对象，原型对象包含函数实例共享的方法和属性，也就是说将函数用作构造函数调用的时候，新创建的对象会从原型对象上继承属性和方法。不像传统的面向对象语言，javascript的继承机制基于原型，而不是class类。 1、javascript的设计意图 私有变量、函数javascript的作用域链，在函数内定义的变量和函数如果不对外提供接口，外部将无法访问到，也就是变为私有变量和私有函数。 12345678function Obj()&#123; var a=0; //私有变量 var fn=function()&#123; //私有函数 &#125;&#125;var o=new Obj();console.log(o.a) //undefinedconsole.log(o.fn) //undefined 静态变量、函数当定义一个函数后，通过“.”为其添加属性和函数，通过对象本身仍然可以访问得到，但是其实例访问不到，这样的变量和函数分别被称为静态变量和静态函数。 12345678910function Obj()&#123;&#125; Obj.a=0; //静态变量 Obj.fn=function()&#123; //静态函数 &#125;console.log(Obj.a) //0console.log(Obj.fn) //function()&#123; //静态函数 &#125;var o=new Obj();console.log(o.a) //undefinedconsole.log(o.fn) //undefined 实例变量、函数在面向对象编程中除了一些库函数我们还希望在对象定义的时候同时定义一些属性和方法，实例化后可以访问，javascript也可以做到这样。 1234567891011function Obj()&#123; this.a=[]; //实例变量 this.fn=function()&#123; //实例函数 &#125; &#125;console.log(typeof Obj.a) //undefinedconsole.log(typeof Obj.fn) //undefinedvar o=new Obj();console.log(typeof o.a) //objectconsole.log(typeof o.fn) //function 这样可以达到目的，然而12345678910111213function Obj()&#123; this.a=[];//实例变量 this.fn=function()&#123; //实例方法 &#125;&#125;var o1=new Obj();o1.a.push(1);o1.fn=&#123;&#125;; console.log(o1.a); //[1]console.log(typeof o1.fn); //objectvar o2=new Obj();console.log(o2.a); //[]console.log(typeof o2.fn) //function 虽然可以实例访问了，但是在o1中修改了a和fn，在o2中没有改变，由于数组和函数都是对象，是引用类型，这说明o1和o2中的属性和方法虽然同名但不是一个引用，而是对Obj对象定义的属性和方法的一个复制。这对属性来说没什么问题，但是对方法来说，因为方法都是在做完全一样的功能，但是却有两份复制，如果一个函数对象有上千个实例方法，每个实例都要保持一份上千个方法的复制，这显然不科学，因此prototype应运而生。原型对象的主要目的是让所有对象实例共享它所包含的属性和方法。 2、prototype原型在javascript中，所有都是对象。但对象是有区别的，分为普通对象和函数对象。凡是通过new Funtion()的方式创建的对象都是函数对象，其他都是普通对象。每个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。prototype就是调用构造函数而创建的那个对象实例的原型对象。普通对象没有prototype，但是有proto属性。原型对象其实就是普通对象（Funtion.prototype除外，它是函数对象，但它很特殊，它没有prototype属性（前面说函数对象都有prototype属性））。举个例子：123456function f1()&#123;&#125;;console.log(f1.prototype) //f1&#123;&#125;console.log(typeof f1.prototype) //objectconsole.log(typeof Function.prototype) // function，这个特殊console.log(typeof Object.prototype) // objectconsole.log(typeof Function.prototype.prototype) //undefined 从console.log(f1.prototype)//f1{}看出，f1.prototype就是f1的实例对象。就是f1创建的时候，创建了一个实例对象并赋值给它的prototype，过程如下：12var temp=new f1();f1.prototype=temp; 所以Function.prototype为什么时函数对象就迎刃而解，上文提到凡是new Function产生的对象都是函数对象，所以temp1是函数对象：12var temp1=new Function();Function.prototype=temp1; 那原型对象是用来做什么呢？主要是用来继承，举个例子：12345678var person=function(name)&#123; this.name=name;&#125;person.prototype.getName=function()&#123; return this.name;//this指向源性对象&#125;var xpg=new Person(&quot;alice&quot;)xpg.getName() //alice 从这里看出，person.prototype设置了一个函数对象的属性，那由person实例出来的对象就继承了这个属性。具体继承机制看原型链。无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性（同时它也是一个对象），默认情况下prototype属性会默认获得一个constructor（构造函数）属性，这个属性是一个指向prototype属性所在函数的指针。12function Person()&#123; &#125; 可以看到Person对象会自动获得prototype属性，而prototype也是一个对象，会自动获得constructor属性，该属性正是指向Person对象。当调用构造函数创建一个实例的时候，实例内部将包含一个内部指针（proto）指向构造函数的prototype，这个连接存在于实例和构造函数的prototype之间，而不是实例与构造函数之间。12345678function Person(name)&#123; this.name=name;&#125;Person.prototype.printName=function()&#123; alert(this.name)&#125;var person1=new Person(&quot;Byron&quot;)var person2=new Person(&quot;Frank&quot;) Person的实例person1中包含了name属性，同时自动生成一个proto属性，该属性指向Person的prototype，可以访问到prototype内定义的printName方法： 3、原型链由于proto是任何对象都有的属性，而js里万物皆对象，所以会形成一条proto连起来的链。代码读取某个对象的属性的时候，都会执行一遍搜索，目标是具有给定名字的属性，搜索首先从对象实例开始，如果实例中找到该属性则返回，如果没有则查找prototype，如果还没有找到则继续递归prototype的prototype对象，直到找到为止，如果递归到object仍然没有怎返回错误。同理如果在实例中定义prototype同名的属性或函数，则会覆盖prototype的属性或函数。这就是javascript的原型链。12345var A = function()&#123;&#125;;var a = new A();console.log(a.__proto__); //A &#123;&#125;（即构造器function A 的原型对象）console.log(a.__proto__.__proto__); //Object &#123;&#125;（即构造器function Object 的原型对象）console.log(a.__proto__.__proto__.__proto__); //null 4、hasOwnProperty与in操作符in操作符是只要能访问到该属性就返回true，hasOwnProperty只有属性存在于实例中时才返回true。123456Object.prototype.bar=1var foo=&#123;moo:2&#125;for(var i in foo)&#123;if(foo.hasOwnProperty(i)) console.log(i) //输出两个属性： moo和bar&#125; 我们没有办法改变for in语句的行为，所以想过滤结果就只能使用hasOwnProperty方法，代码如下：1234for(var i in foo)&#123; if(foo.hasOwnProperty(i)) console.log(i) // moo&#125; 总结prototype指向该方法的原型对象，只有函数对象有prototypeproto是指向该对象的构造函数的原型对象，所有对象都有proto，proto是普通对象的隐式属性，在new的时候会指向该对象的构造函数的原型对象1234function F()&#123;&#125;var f=new F();f.__proto__==F.prototype //true 构造函数.prototype=原型对象原型对象.constructor=构造函数实例.proto=构造函数.prototypeisPrototypeof(实例对象)判断实例对象的原型是不是当前对象。","categories":[],"tags":[],"keywords":[]},{"title":"原生JavaScript实现Ajax","slug":"原生JavaScript实现Ajax","date":"2017-06-25T12:21:18.000Z","updated":"2017-08-17T02:18:36.053Z","comments":true,"path":"2017/06/25/原生JavaScript实现Ajax/","link":"","permalink":"https://aliceflaviawang.github.io/2017/06/25/原生JavaScript实现Ajax/","excerpt":"","text":"Ajax实现步骤： 创建XMLHttpRequest对象XMLHttpRequest用于在后台与服务器交换数据，可以在不重新加载整个网页的情况下，对网页的部分进行更新。12345var XHR=if(window.XMLHttpRequest)&#123; XHR=new XMLHttpRequest();&#125;else if(window.ActiveXObject)&#123;//IE6 XHR=new ActiveXobject(&apos;Microsoft.XMLHTTP&apos;);&#125; 注：ActiveXObject对象在IE11中已移除。 想服务器发送请求首先调用open方法，有五个参数（常用的前三个）： method:必须提供，用来指定发送请求的HTTP方法（GET, POST等） uri：请求的url，会被自动解析成绝对地址 async:请求是否是异步的，默认是true username, password:如果需要服务器验证用户，则设置username和password这两个参数。然后调用send方法，按照open方法设定的参数将请求进去发送123456789101112131415if(type==&apos;GET&apos;)&#123; //拼接GET方法的URL if(typeof(data)!=&apos;undefined&apos;)&#123; url+=&apos;?&apos;; for(i in data)&#123; url+=i+&apos;=&apos;+data[i]+&apos;&amp;&apos;; &#125; url=url.substring(0,url.length-1); //去掉最后一个&apos;&amp;&apos; &#125; XHR.open(type,url,true); XHR.send(null);&#125;else if(type==&apos;POST&apos;)&#123; XHR.open(type,url,true); XHR.send(data);&#125; 注：理论上GET方法也有body，但一般约定GET的参数都放在URL上，所以type为GET时，send的参数一般是null. get和post的区别它们的结构和使用方式相同，区别： get请求会将参数跟在url后进行传递，而post则是将参数作为http消息的实体内容发给web服务器 （对用户是不可见的） get对传输数据有大小限制（通常不能大于2kb），而post传递的数据量要比get大得多（理论上没有限制。但get效率更高，一般用来查询 get方式请求的数据会被浏览缓存，post则不会，get具有安全问题、 get方式和post方式传递的数据在服务器端的获取也不相同服务器响应在讲响应之前，先介绍一下readyState属性，readyState标识了当前对象正处于什么状态。另外介绍一下status属性，status属性描述了HTTP状态代码，一下常用的状态码：123456789XHR.onreadystatechange=function()&#123;//readyState的值发生改变时就会触发onreadystatechange if(readystate==4)&#123; if(XHR.status&gt;=200&amp;&amp;XHR.status&lt;300||XHR.status==304)&#123; //请求成功 &#125;else&#123; //请求失败 &#125; &#125;&#125; 注： status仅当readyState的状态是3或者4的时候才可用 send()方法必须在readyState的属性值是1，即调用open()方法以后才能调用 http 302 303 307302作为HTTP 1.0的标准，现在使用只是为了兼容性的处理。HTTP 1.1有303 307作为详细的补充，其实是对302的细化302：指示资源在另一个位置，该位置通过;Location指定303：请求的资源可以在另一个URI处找到，客户端必须使用GET方法来获取新位置的资源307：后续请求资源的方法是使用与当前交互相同的方法而不是全部使用GET Ajax的交互模型 用户发出请求 创建XMLHttpRequest对象 告诉XMLHttpRequest对象哪个函数会处理XMLHttpRequest对象状态的改变，为此要把对象的onReadyStateChange属性设置为响应该事件的JavaScript函数的引用 创建请求，用open方法指定get还是post，是否同步，url地址 发送请求，send方法 接收结果并分析 实现刷新 同步与异步的区别同步：脚本会停留等待服务器发送回复然后再继续异步：脚本允许页面继续其进程并处理可能的回复 Ajax的同步和异步ajax的open方法中，第三个参数(async)设同步或者异步，默认是true(异步)。异步的话，客户机不等待服务器的响应，需要onreadystatechange事件处理，且值为4处理下面的内容；同步的话客户机需要等待服务器返回消息后才去执行其他操作，js等待请求返回，获取status，不需要onreadystatechange事件处理函数。 同步和异步的请求代码示例如下：1234567891011121314var XHR=if(window.XMLHttpRequest)&#123; XHR=new XMLHttpRequest();&#125;else if(window.ActiveXObject)&#123;//IE6 XHR=new ActiveXobject(&apos;Microsoft.XMLHTTP&apos;);&#125;XHR.open(&apos;GET&apos;,URL,false);XHR.send(null);var result=XHR.status;//OKif(result==200)&#123; document.getElementById(&quot;left&quot;).innerHTML=XHR.responseText;&#125; XHR=null; 123456789101112131415var XHR=if(window.XMLHttpRequest)&#123; XHR=new XMLHttpRequest();&#125;else if(window.ActiveXObject)&#123;//IE6 XHR=new ActiveXobject(&apos;Microsoft.XMLHTTP&apos;);&#125;XHR.open(&apos;GET&apos;,URL,false);XHR.onreadystatechange=handleResponse;XHR.send(null);function handleResponse()&#123; if(XHR.readyState==4&amp;&amp;XHR.status==2000)&#123; document.getElementById(&quot;left&quot;).innerHTML=XHR.responseText; XHR=null; &#125;&#125;","categories":[],"tags":[],"keywords":[]},{"title":"jQuery $.proxy()方法","slug":"jQuery-proxy-方法","date":"2017-06-24T14:01:36.000Z","updated":"2017-06-24T14:30:06.774Z","comments":true,"path":"2017/06/24/jQuery-proxy-方法/","link":"","permalink":"https://aliceflaviawang.github.io/2017/06/24/jQuery-proxy-方法/","excerpt":"","text":"定义$.proxy方法接收一个已有的函数，并返回一个带特定上下文的新的函数。该方法通常用于向上下文只想不同对象的元素添加事件。 语法11$(selector).proxy(function,context) //function：要被调用的已有函数，context:函数所在对象的名称 举个例子：12345678910&lt;div&gt;div元素&lt;/div&gt;&lt;script&gt; test=function()&#123; this.text=&quot;这是一个对象属性&quot;; $(&quot;div&quot;).click(this.myClick); &#125; test.prototype.myClick=function()&#123; alert(this.text); &#125;&lt;/script&gt; 点击“div元素”，弹出undefined。这是因为执行$(“div”).click(this.myClick)后的this与test()中的this不是同一个。而使用$.proxy()可以将$(“div”).click(this.myClick)执行的this绑定到test的上下文环境中：12345678910&lt;div&gt;div元素&lt;/div&gt;&lt;script&gt; test=function()&#123; this.text=&quot;这是一个对象属性&quot;; $(&quot;div&quot;).click($.proxy(this.myClick),this); &#125; test.prototype.myClick=function()&#123; alert(this.text); &#125;&lt;/script&gt; 点击“div元素”，弹出的是“这是一个对象属性”。 语法21$(selector).proxy(context,name) //name:已有的函数，其上下文将被改变（应该是context对象的属性） 举个例子：123456789101112&lt;button&gt;执行test函数&lt;/button&gt;&lt;p&gt;&lt;/p&gt;&lt;script&gt; var objPerson=&#123; name:&quot;John&quot;, age:32, test:function()&#123; $(&quot;p&quot;).after(&quot;Name:&quot;+this.name+&quot;&lt;br&gt;Age:&quot;+this.age); &#125; &#125;$(&quot;button&quot;).click(objPerson.test.call(this));&lt;/script&gt; 点击button按钮，出现Name:undefined Age:undefined，因为test的上下文环境和objPerson的上下文环境不一样，test里面没有定义name和age对象。可以通过$.proxy()绑定test的上下文环境。123456789101112&lt;button&gt;执行test函数&lt;/button&gt;&lt;p&gt;&lt;/p&gt;&lt;script&gt; var objPerson=&#123; name:&quot;John&quot;, age:32, test:function()&#123; $(&quot;p&quot;).after(&quot;Name:&quot;+this.name+&quot;&lt;br&gt;Age:&quot;+this.age); &#125; &#125;$(&quot;button&quot;).click($.proxy(objPerson,&quot;test&quot;));&lt;/script&gt; 点击button按钮，出现Name:John Age:32。当然之前分析call函数时，也提到过call()也可以绑定上下文环境，实现与上面同样的效果：123456789101112&lt;button&gt;执行test函数&lt;/button&gt;&lt;p&gt;&lt;/p&gt;&lt;script&gt; var objPerson=&#123; name:&quot;John&quot;, age:32, test:function()&#123; $(&quot;p&quot;).after(&quot;Name:&quot;+this.name+&quot;&lt;br&gt;Age:&quot;+this.age); &#125; &#125;$(&quot;button&quot;).click(objPerson.test.call(objPerson));//将test()环境绑定到objPerson环境中&lt;/script&gt;","categories":[],"tags":[],"keywords":[]},{"title":"bind(), delegate(), on()方法区别","slug":"bind-delegate-on-方法区别","date":"2017-06-23T08:51:44.000Z","updated":"2017-06-23T09:12:23.824Z","comments":true,"path":"2017/06/23/bind-delegate-on-方法区别/","link":"","permalink":"https://aliceflaviawang.github.io/2017/06/23/bind-delegate-on-方法区别/","excerpt":"","text":"bind()：$(selector).bind(event,data,function)123$(&quot;div p&quot;).bind(&quot;click&quot;,function()&#123; &#125;) 使用bind()方法为所有div里的p元素都绑定了click事件，存在的问题：1）这里使用了隐式迭代，如果匹配到的元素特别多，影响了性能；2）对于尚未存在的元素，无法绑定。动态添加的p元素，点击会没有响应。顺便提一下，bind()的简写方式：123$(&quot;div p&quot;).click(function()&#123;&#125;) delegate():$(selector).delegate(childSelector,event,data,function)123$(&quot;div&quot;）.delegate(&quot;p&quot;,&quot;click&quot;,function()&#123; &#125;) 事件委托方式，不直接为p元素绑定事件，而是为其父元素（或祖先元素）绑定事件，当在div内任意元素点击时，事件会一层层从event.target向上冒泡，直到达到为其绑定事件的元素，如此例中的div元素。冒泡的过程中，如果事件的currentTarget与选择器匹配时就会执行代码。delegate()方法解决了bind具有的两个问题，但是如果事件目标在DOM树很深的位置，这样一层层来查找与选择器匹配的元素，又影响了性能。 on():$(selector).on(event,childselector,data,function)12$(&quot;div&quot;).on(&quot;click&quot;,&quot;p&quot;,function()&#123;&#125;) 看jQuery源代码发现，无论是bind()还是delegate()，都是通过on()方法实现的，只是参数不同。12345678910111213bind: function( types, data, fn ) &#123; return this.on( types, null, data, fn ); &#125;, unbind: function( types, fn ) &#123; return this.off( types, null, fn ); &#125;, delegate: function( selector, types, data, fn ) &#123; return this.on( types, selector, data, fn ); &#125; undelegate: function( selector, types, fn ) &#123; // ( namespace ) or ( selector, types [, fn] ) return arguments.length === 1 ? this.off( selector, &quot;**&quot; ) : this.off( types, selector || &quot;**&quot;, fn ); &#125; 总结1、选择器匹配元素较多时，不要使用bind()迭代绑定2、id选择器时，可以用bind()3、需要动态绑定时，用delegate()或on()4、用delegate()或on()，DOM树不要太深5、尽量使用on()","categories":[],"tags":[],"keywords":[]},{"title":"jQuery性能优化","slug":"jQuery性能优化","date":"2017-06-23T02:14:53.000Z","updated":"2017-06-23T08:48:32.480Z","comments":true,"path":"2017/06/23/jQuery性能优化/","link":"","permalink":"https://aliceflaviawang.github.io/2017/06/23/jQuery性能优化/","excerpt":"","text":"1、使用最新版本的jQuery类库jQuery每个新版本都会较上个版本进行bug修复和优化，同时进行一些创新。 2、使用合适的选择器jQuery提供了丰富的选择器来定位DOM元素，下面介绍几种常用的选择器及它们之间的性能差异： $(“#id”)使用id来定位DOM元素是最佳提高性能的方式，因为jQuery底层将直接调用本地方法document.getElementById()。如果不能直接找到，还可以考虑调用find()方法：1$(&quot;#content&quot;).find(&quot;div&quot;); 使用以上方法可以有效缩小定位DOM元素的范围，为了提高性能，可以从最近的ID元素开始往下搜索。 $(“p”),$(“div”),$(“input”)标签选择器是性能优化的第二选择，因为jQuery将直接调用本地方法document.getElementByTagName()来定位DOM元素。 $(“.class”)对于较新的浏览器，支持本地方法document.getElementByClassName(),老的浏览器如IE8及更早版本只能靠使用DOM搜索方式来实现，这无疑对性能产生较大的影响。所以有选择性的使用它。 $(“[attribute=value]”)利用属性定位DOM元素，本地JavaScript方法并没有直接实现，大多是使用DOM搜索方式来达到效果，很多现代浏览器支持querySelectAll()方法，但是浏览器之间还是有区别。 $(“:hidden”)和上面利用属性定位DOM方式类似，这种伪选择器也没有直接在本地JavaScript实现，并且jQuery需要搜索每一个元素来定位这个选择器，这对性能影响较大。如果一定要用这种方式，建议先用id定位父元素再使用该选择器，这样有助于优化性能。1$(&quot;#content&quot;).find(&quot;:hidden&quot;); 以上是使用选择器的基本规则，性能自上而下依次下降。 3、缓存对象开发人员经常喜欢这样写：12$(&quot;#traffic input.on&quot;).bind(&quot;click&quot;,function&#123;&#125;);$(&quot;#traffic&quot;).css(&quot;border&quot;,&quot;1px solid red&quot;)) 这样写导致的结果是jQuery会在每个选择器创建的过程中，查找DOM，创建多个jQuery对象。比较好的方式：123var $traffic=$(&quot;#traffic&quot;);$traffic.bind(&quot;click&quot;,function()&#123;&#125;).css(&quot;border&quot;,&quot;1px solid red&quot;) //使用链式结构让代码更简洁 如果希望在其他函数中使用jQuery对象，可以把它缓存放全局环境中。1234567891011//在全局范围内定义一个对象（例如window对象）window.$my=&#123; head:$(&quot;head&quot;), traffic:$(&quot;#traffic&quot;), &#125;function do()&#123; var script=document.createElement(&quot;script&quot;); $my.head.append(script); //现在可以引用存储的结果并操作它们 $my.coll=$(&quot;#ul li&quot;);//在函数内部操作时，可以继续将查询存入全局对象中 $my.coll.css(&quot;border-color&quot;,&quot;red&quot;); //将全局函数作为一个普通的jquery对象使用 &#125; 4、循环时的DOM操作使用for,while,$.each处理节点时，要注意：12345var top=[];//假设是100个字符串var list=$(&quot;#list&quot;);for(var i=0;i&lt;top.length;i++)&#123; list.append(&quot;&lt;li&gt;&quot;+top[i]+&quot;&lt;/li&gt;&quot;); &#125; 以上每添加一个新的标签元素都作为一个节点添加容器ID中，循环了100次，消耗较大。应该将整个元素字符串在插入DOM中全部创建好：1234567var top=[];//假设是100个字符串var list=$(&quot;#list&quot;);var mylist=&quot;&quot;;//暂存列表元素for(var i=0;i&lt;top.length;i++)&#123; mylist+=&quot;&lt;li&gt;&quot;+top[i]+&quot;&lt;/li&gt;&quot;; &#125;list.append(mylist); 非常类似与DOM操作中用createElementFragment一次性添加全部DOM节点，再一次性更新DOM：1234567var fragment=document.createElementFragment();for(var i=0;i&lt;items.length;i++)&#123; var item=document.createElement(&quot;li&quot;); item.append(document.createTextNode(&quot;option&quot;+i); fragment.appendChild(item); &#125;list.appendChild(fragment); 5、数组方式使用jQuery对象使用for或者while循环而不是$.each()能使代码更快。 6、事件代理每个javascript事件都会冒泡到父级节点。当需要给多个元素同个函数时，事件代理会很有用。123$(&quot;#table td&quot;).click(function()&#123; $(this).css(&apos;background&apos;,&apos;red&apos;) &#125;) 假设有100个td元素，使用上述方法，将会绑定100个事件，对性能影响很大。代替这种多元素事件监听的方法是，只需要向他们的父节点绑定一次事件，然后通过event.target获取到点击的当前元素：123$(&quot;#table&quot;).click(function(event)&#123; $(event.target).css(&apos;background&apos;,&apos;red&apos;); //event.target捕捉触发的目标元素 &#125;) 改进的方式中，只为一个元素绑定了1个事件。jQuery 1.7中提供了on方式，on(type,[selector],[data],fn)中增加了selector，如果能够匹配到该selector则执行此方法：123$(&quot;#table&quot;).on(&quot;click&quot;,&quot;td&quot;,function()&#123; $(this).css(&apos;background&apos;,&apos;red&apos;);&#125;) 7、将代码转化成jQuery插件将代码转化成插件能让代码具有更好的重用性。 8、使用join()来拼接字符串使用join来拼接字符串比使用”+“来拼接长字符串性能更优。首先创建一个数组，然后循环，最后通过join()将数组转化成字符串：12345var array=[];for(int i=0;i&lt;100;i++)&#123; array[i]=&apos;&lt;li&gt;&apos;+i+&apos;&lt;/li&gt;&apos;; &#125;$(&apos;#list&apos;).html(array.join(&apos;&apos;)); 9、合理利用HTML5的Data属性HTML5的data属性可以帮助我们插入数据，特别是前后端的数据交换。jQuery的data（）方法，有效的利用HTML5的属性，来自动得到数据。12345&lt;div id=&quot;dl&quot; data-role=&quot;page&quot; data-last=&quot;43&quot; data-options=&apos;&#123;&quot;name&quot;:&quot;John&quot;&#125;&apos;&gt;&lt;/div&gt;//读取数据$(&quot;#dl&quot;).data(&quot;role&quot;); //&quot;page&quot;$(&quot;#dl&quot;).data(&quot;last&quot;); //43$(&quot;#dl&quot;).data(&quot;options&quot;).name; //&quot;John&apos; 10、尽量使用原生的JavaScript方法123456var $cr=$(&quot;#cr&quot;);$cr.click(function()&#123; if($cr.is(&quot;:checked&quot;))&#123; //jQuery方式判断 &#125;&#125;) 它使用了jQuery提供的is方法来判断多选框是否被选中，但是这里可以直接使用原生的JavaScript方法：123456var $cr=$(&quot;#cr&quot;); //jQuery对象var cr=$cr.get(0); //DOM对象$cr.click(function()&#123; if(cr.checked)&#123; //原生的js方式判断 &#125;&#125;) 第二种方式比第一种方式效率高，因为它不需要拐弯抹角去调用许多函数。 11、压缩JavaScript一方面使用Gzip，另一方面去除JS文件里的注释、空白。","categories":[],"tags":[],"keywords":[]},{"title":"页面内跳转方法总结","slug":"页面内跳转方法总结","date":"2017-06-22T08:31:43.000Z","updated":"2017-06-22T09:04:27.613Z","comments":true,"path":"2017/06/22/页面内跳转方法总结/","link":"","permalink":"https://aliceflaviawang.github.io/2017/06/22/页面内跳转方法总结/","excerpt":"","text":"方法一：用标签，在href里写入定位的DIV的id.如：1234&lt;a href=&quot;#div1&quot;&gt;scroll to div1&gt;&lt;/a&gt; //定位到div1&lt;div id=&quot;div1&quot;&gt;div1&lt;/div&gt;&lt;div id=&quot;div2&quot;&gt;div2&lt;/div&gt;&lt;div id=&quot;div3&quot;&gt;div3&lt;/div&gt; 缺点：点击锚点后，浏览器的URL会发生变化，刷新会出现问题。 方法二：使用js中的window.location.hash=”divId”跳转，但地址也会发生变化，跟第一种方法差不多。123456&lt;a href=&quot;javascript:void(0)&quot; onclick=&quot;locate()&quot;&gt;&lt;/a&gt;&lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; funtion locate()&#123; window.location.hash=&quot;#div1&quot;;&#125; 方法三：用animate属性，当点击锚点后，页面滚动到相应的div。12345678&lt;a href=&quot;javascript:void(0)&quot; onclick=&quot;locate()&quot;&gt;&lt;/a&gt;&lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function lacate()&#123; $(&quot;html&quot;,&quot;body&quot;).animate(&#123; scrollTop:$(&quot;#div1&quot;).offset().top &#125;,&#123;duration:500,easing:&quot;swing&quot;&#125;) &#125; 优点：url地址不会改变，同时点击锚点会自动响应scroll事件，不需要重新绑定。缺点：如果页面复杂的话，偏移值可能会发生变化需要算法辅助。 方法四：用js的scrollIntoView方法，直接用：123456&lt;a href=&quot;javascript:void(0)&quot; onclick=&quot;locate()&quot;&gt;&lt;/a&gt;&lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;function lacate()&#123; docuemnt.getElementById(&quot;div1&quot;).scrollIntoView();&#125; 优点：url不会变，同时能够响应scroll事件，不需要算法什么的。注意：scrollIntoView是js方法，不能使用$(“#div1”).scrollIntoView().","categories":[],"tags":[],"keywords":[]},{"title":"JSON.parse()和Json.stringify()","slug":"JSON-parse-和Json-stringify","date":"2017-06-22T02:01:30.000Z","updated":"2017-07-16T14:10:59.037Z","comments":true,"path":"2017/06/22/JSON-parse-和Json-stringify/","link":"","permalink":"https://aliceflaviawang.github.io/2017/06/22/JSON-parse-和Json-stringify/","excerpt":"","text":"JSON.parse()parse是用一个字符串中解析出json对象，如：var str=’{“name”:”alice”,”age”:”23”}’结果：JSON.parse(str)Objectage:”23”name:”alice”proto:Object 注意：单引号写在{}外面，每个属性名必须用双引号，否则会报错 JSON.stringify()stringify是从对象解析出字符串，如：var a={a:1,b:2}JSON.stringify(a)‘{“a”:1,”b”:2}’ JSON.stringify和JSON.parse在IE8及以上支持","categories":[],"tags":[],"keywords":[]},{"title":"serialize()系列方法","slug":"serialize-系列方法","date":"2017-06-17T11:22:16.000Z","updated":"2017-06-17T13:25:38.569Z","comments":true,"path":"2017/06/17/serialize-系列方法/","link":"","permalink":"https://aliceflaviawang.github.io/2017/06/17/serialize-系列方法/","excerpt":"","text":"serialize()jQuery有方法$.fn.serialize()，可以将表单序列化成字符串。提交表单的时候，将表单的每个元素表达成如：username:$(“#username”).val(),content:$(“#content”).val()…无疑随着表单元素越来越复杂，这种方式在增大工作量的同时也使表单元素缺乏弹性。采用serialize（）方法可以将需要提交的字段内容序列化为字符串，username:$(“#username”).val(),content:$(“#content”).val()…可以用一个语句代替:$(“#form”).serialize(),其中#form是表单的id。 serialize()的其他两种方法–serializeArray()和serializeObject()serializeArray()是将表单序列化为JSON格式的数据，输出的是对象数组。而serializeObject()是基于serializeArray（）编写的。下面例子能非常清晰的看出其中的区别：123$(&quot;#form&quot;).serialize(); //username=&amp;content=$(&quot;#form&quot;).serializeArray(); //[&#123;name:&quot;username&quot;,value:&quot;&quot;&#125;,&#123;name:&quot;content&quot;,value:&quot;&quot;&#125;]$(&quot;#form&quot;).serializeObject(); //&#123;username:&quot;&quot;,content:&quot;&quot;&#125; 注意1、serializeObject()直接使用的话，会提示serializeObject()is not a funtion.因为serializeObject()本身并不是一个jQuery自带的功能，而是基于serializeArray（）的添加功能，需要对其进行定义如下：12345678910111213141516$.fn.serializeObject()&#123; var o=&#123;&#125;; //保存对象 var a=this.serializeArray(); //先将元素序列化为对象数组 $.each(a,function()&#123; if(o[this.name])&#123;//表单中可能有多个相同的label，在插入第一个label后，还有继续插入，这个时候o[label]已经存在了，所以要把o[label]做嵌套处理 if（！o[this.name].push)&#123; //如果o[label]不是嵌套在数组里面，实际上就是看o[this.name]是不是一个数组，数组有push方法，对象没有 o[thos.name]=[o[this.name]];将o[label]初始为嵌套数组 &#125; o[this.name].push(this.value||&apos;&apos;); //将值插入o[label]数组里 &#125; else&#123; o[this.name]=this.value||&apos;&apos;;//第一次在o中插入o[label] &#125; &#125;) return o;&#125; 举个例子,对于下面的表单：123456&lt;form id=&quot;form&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt; &lt;input type=&quot;text&quot; name=&quot;content&quot; /&gt; &lt;input type=&quot;button&quot; id=&quot;send&quot; onclick=&quot;sen();&quot;&gt;&lt;/form&gt; 执行三个函数，分别结果为：12345var a=$(&quot;#form&quot;).serialize(); //username=alice&amp;username=bob&amp;content=123 var b=$(&quot;#form&quot;).serializeArray(); //[&#123;name:&quot;username&quot;,value=&quot;alice&quot;&#125;,&#123;name:&quot;username&quot;,value=&quot;bob&quot;&#125;,&#123;name:&quot;content&quot;,value=&quot;123&quot;&#125;]var c=$(&quot;#form&quot;).serializeObject(); //&#123;username:[&quot;alice&quot;,&quot;bob&quot;],content:&quot;123&quot;&#125; 2、表单元素要序列化必须要使用name属性，form里的name不能用js、jquery的关键字，否则获取不到值。3、不光表单能用到serialize()方法，其他选择器元素也可以。比如：1$(&quot;:checkbox,:radio&quot;).serialize()","categories":[],"tags":[],"keywords":[]},{"title":"EasyUI更改弹出框位置","slug":"EasyUI更改弹出框位置","date":"2017-06-15T02:15:18.000Z","updated":"2017-06-15T02:21:15.667Z","comments":true,"path":"2017/06/15/EasyUI更改弹出框位置/","link":"","permalink":"https://aliceflaviawang.github.io/2017/06/15/EasyUI更改弹出框位置/","excerpt":"","text":"EasyUI的dialog弹出一般用的是$(‘#dlg’).dialog(‘open’)，要想调整其位置，可以采用$(‘#dlg’).window(‘open’)，再用window的resize方法重新布局就可以了。如：1$(&apos;#dlg&apos;).dialog(&apos;open&apos;).dialog(&apos;center&apos;).dialog(&apos;setTitle&apos;, &apos;添加题目&apos;); 可以改成：1$(&apos;#dlg&apos;).window(&apos;open&apos;).window(&apos;setTitle&apos;,&apos;添加题目&apos;).window(&apos;resize&apos;,&#123;width:&apos;500px&apos;,height:&apos;800px&apos;,top:&apos;30px&apos;&#125;","categories":[],"tags":[],"keywords":[]},{"title":"a标签中href=''的几种用法","slug":"a标签中href-的几种用法","date":"2017-06-13T06:54:22.000Z","updated":"2017-06-13T12:29:08.779Z","comments":true,"path":"2017/06/13/a标签中href-的几种用法/","link":"","permalink":"https://aliceflaviawang.github.io/2017/06/13/a标签中href-的几种用法/","excerpt":"","text":"a标签的主要作用是实现超链接和锚点，下面总结下a标签href的几种用法。 一、href的几种调用方法1、a href=”javascript:js_method();”这是常用的方法，但是这种方法在传递this等参数的时候很容易出问题，而且javascript：协议作为a的href属性的时候不仅会导致不必要的触发window.onbeforeunload事件，在IE里面更会使gif动画图片停止播放。W3C标准不推荐在href里面执行javascript语句。 2、a href=”javascript:void(0);” onclick=”js_method()”这种方法是很多网站最常用的方法，也是最周全的方法，onclick方法负责执行js函数，而void是一个操作符，void(0)返回undefined，地址不发生跳转。而且这种方法不会像第一种方法一样直接js方法暴露在浏览器的状态栏。 3、a href=”javascript:;” onclick=”js_method()”这种方法跟2类似，区别只是执行了一条空的js代码 4、a href=”#” onclick=”js_method()”这种方法也是网上很常见的代码，#是标签内置的一个方法，”#”包含了一个位置信息，默认的锚点是#top,就是点击后返回页面的顶端。（如果希望不返回页面顶端，可以在#后面加任意无效的位置信息，如###） 5、a href=”#” onclick=”js_method();return false;”这种方法点击执行了js函数后return false,页面不发生跳转，执行后还是在页面的当前位置。","categories":[],"tags":[],"keywords":[]},{"title":"return false实现同时对事件对象停止冒泡和默认行为","slug":"return-false实现同时对事件对象停止冒泡和默认行为","date":"2017-06-12T08:06:54.000Z","updated":"2017-06-12T09:17:10.934Z","comments":true,"path":"2017/06/12/return-false实现同时对事件对象停止冒泡和默认行为/","link":"","permalink":"https://aliceflaviawang.github.io/2017/06/12/return-false实现同时对事件对象停止冒泡和默认行为/","excerpt":"","text":"冒泡网页上有两个元素，其中一个元素嵌套在另一个元素里面，并且都被绑定了click事件，那么点击内层元素，会冒泡到外层元素上。1234567891011121314151617181920212223242526&lt;body&gt;&lt;div id=&quot;content&quot;&gt; 外层div元素 &lt;span&gt;内层div元素&lt;/span&gt; 外层div元素&lt;/div&gt;&lt;div id=&apos;msg&apos;&gt;&lt;/div&gt;&lt;script&gt;$(function()&#123; $(&apos;span&apos;).bind(&apos;click&apos;,function()&#123; var txt=$(&apos;#msg&apos;).html()+&apos;&lt;p&gt;内层div元素被单击。&lt;/p&gt;&apos;; $(&apos;#msg&apos;).html(txt); &#125;) $(&apos;#content&apos;).bind(&apos;click&apos;,function()&#123; var txt=$(&apos;#msg&apos;).html()+&apos;&lt;p&gt;外层div元素被单击。&lt;/p&gt;&apos;; $(&apos;#msg&apos;).html(txt) &#125;) $(&apos;body&apos;).bind(&apos;click&apos;,function()&#123; var txt=$(&apos;#msg&apos;).html()+&apos;&lt;p&gt;body元素被单击。&lt;/p&gt;&apos;; $(&apos;#msg&apos;).html(txt) &#125;)&#125;)&lt;/script&gt;&lt;/body&gt; 效果如图：点击span元素点击外层div元素点击内层元素，会冒泡到外层的点击事件。 阻止冒泡stopPropagation()方法可以停止事件冒泡。12345$(&apos;span&apos;).bind(&apos;click&apos;,function(event)&#123; var txt=$(&apos;#msg&apos;).html()+&apos;&lt;p&gt;内层div元素被单击。&lt;/p&gt;&apos;; $(&apos;#msg&apos;).html(txt); event.stopPropagation(); &#125;) 点击span元素 阻止默认行为网页中的元素有自己的默认行为，例如，单击“提交”按钮后表单会提交，有时需要阻止元素的默认行为。1234567891011121314151617&lt;form action=&quot;test.html&quot;&gt;用户名：&lt;input type=&quot;text&quot; id=&quot;username&quot;&gt;&lt;br/&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot; id=&quot;sub&quot;&gt;&lt;/form&gt;&lt;div id=&quot;msg&quot;&gt;&lt;/div&gt;&lt;script&gt;$(function()&#123; $(&apos;#sub&apos;).bind(&apos;click&apos;,function()&#123; var username=$(&apos;#username&apos;).val(); if(username==&apos;&apos;)&#123; $(&apos;#msg&apos;).html(&apos;&lt;p&gt;文本框的值不能为空。&lt;/p&gt;&apos;); &#125; &#125;)&#125;)&lt;/script&gt; 如果不阻止默认行为，用户名为空的时候，也能提交表单。阻止默认行为使用preventDefault()方法。1234567$(&apos;#sub&apos;).bind(&apos;click&apos;,function(event)&#123; var username=$(&apos;#username&apos;).val(); if(username==&apos;&apos;)&#123; $(&apos;#msg&apos;).html(&apos;&lt;p&gt;文本框的值不能为空。&lt;/p&gt;&apos;); event.preventDefault(); &#125; &#125;) 同时对事件对象停止冒泡和默认行为——return false将event.stopPropagation()和event.preventDefault()替换为return false就可以实现同样的效果。 return false到底做了什么1、event.preventDefault()2、event.stopPropagation()3、停止回调函数执行并立即返回return false看似实现了阻止冒泡或者阻止默认事件，实际上还做了另外的操作，阻止浏览器默认行为的只有preventDefault()，除非你想停止事件冒泡，否则使用return false会为你的代码埋下很大的隐患。 ###扩展-stopImmediatePropagation()stopImmediatePropagagtion()函数用于阻止剩余的事件处理函数的执行(为同一对象绑定了多个事件处理函数)，并防止当前事件在DOM树上冒泡。12345678910111213141516171819202122232425&lt;p&gt;段落文本内容 &lt;input type=&quot;button&quot; value=&quot;点击&quot; /&gt;&lt;/p&gt;&lt;script&gt;// 为所有p元素绑定click事件$(&quot;p&quot;).click( function(event)&#123; alert(&quot;p-click&quot;);&#125; );// 为所有button元素的click事件绑定第一个事件处理函数$(&quot;:button&quot;).click( function(event)&#123; alert(&quot;button-click-1&quot;); // 阻止事件冒泡到DOM树上，并阻止剩余的事件处理函数的执行 // 只执行button-click-1，如果注释掉该行，将执行button-click-1、button-click-2和p-click // 如果换成event.stopPropagation() 将执行button-click-1和button-click-2 event.stopImmediatePropagation();&#125; );// 为所有button元素的click事件绑定第二个事件处理函数$(&quot;:button&quot;).click( function(event)&#123; alert(&quot;button-click-2&quot;);&#125; );&lt;/script&gt; 与stopPropagation()相比，stopImmediatePropagation()还能阻止剩余事件处理函数的执行。","categories":[],"tags":[],"keywords":[]},{"title":"ajax dataType","slug":"ajax-dataType","date":"2017-06-08T02:42:09.000Z","updated":"2017-06-09T06:30:48.124Z","comments":true,"path":"2017/06/08/ajax-dataType/","link":"","permalink":"https://aliceflaviawang.github.io/2017/06/08/ajax-dataType/","excerpt":"","text":"遇到一个很奇怪的问题12345678910$.ajax(&#123; type:&quot;POST&quot;, async:false, contentType: &quot;application/json; charset=utf-8&quot;, // dataType: &apos;json&apos;, url:baseUrl+&quot;/office/getEmploymentPeriod.do&quot;, success:function(data)&#123; console.log(data) //&#123;&quot;body&quot;:&quot;2017年3月-2017年7月&quot;,&quot;message&quot;:&quot;成功&quot;,&quot;status&quot;:0&#125; console.log(data.body) // undefined &#125; 如果没有dataType:’json’,返回的data是json对象，访问data.body是undefined。加上dataType:’json’，返回的是普通对象，访问data.body可以获取到。疑问是，dataType:’json’是指定返回数据的格式是’json’，为什么会返回数据的格式是普通对象，不指定反而返回的是’json’对象，另外返回数据无论是普通对象还是json对象，按理都应该能通过对象.属性访问到。12345678910$.ajax(&#123; type:&quot;POST&quot;, async:false, contentType: &quot;application/json; charset=utf-8&quot;, dataType: &apos;json&apos;, url:baseUrl+&quot;/office/getEmploymentPeriod.do&quot;, success:function(data)&#123; console.log(data) //&#123;body: &quot;2017年3月-2017年7月&quot;, message: &quot;成功&quot;, status: 0&#125; console.log(data.body) // 2017年3月-2017年7月 &#125;","categories":[],"tags":[],"keywords":[]},{"title":"apply,call,bind用法","slug":"apply-call-bind用法","date":"2017-06-06T03:10:43.000Z","updated":"2017-06-06T06:45:04.789Z","comments":true,"path":"2017/06/06/apply-call-bind用法/","link":"","permalink":"https://aliceflaviawang.github.io/2017/06/06/apply-call-bind用法/","excerpt":"","text":"1、apply()方法——apply([thisObj[,argArray]])apply()接收两个参数：一个是运行函数的作用域，另一个是参数数组。其中第二个参数可以是Array的实例，也可以是arguments对象。 2、call()方法——call([thisObj[,arg1[, arg2[, [,.argN]]]]])与apply作用相同，区别在于接收参数方式不同。第一个参数this的值没有变化，其余参数是以列举的方式直接传递给函数。 apply, call共同之处都可以用来代替另一个对象调用一个方法，将一个函数的对象上下文从初始上下文改变为由thisObj指定的新对象。 不同之处apply最多只能有两个参数——新this对象和一个数组argArray，如果argArray不是一个有效的数组或者不是arguments对象，那么将导致一个TypeError，如果没有提供argArray和thisObj任何一个参数，那么Global对象将被用作thisObj，并且无法被传递任何参数call传递的是参数列表，。如果没有提供thisObj参数，那么Global对象被用作thisObj。apply和call功能一样，只是传入参数列表形式不同，如果某个参数数量是不固定的，当参数明确时用call，不明确时用apply，然后把参数push进数组传递，函数内部也可以通过arguments数组来遍历所有参数。 3、bind()方法——fun.bind(thisObj[,arg1[, arg2[, [,.argN]]]]])与apply和call不同的是，bind会返回一个改变this指向的新函数，新函数与之前的使用的不是同一块内存地址，所以需要重复使用这个函数的时候，必须将其保存到一个变量，方便下次调用。而apply和call都是调用即执行。另外，bind函数中的首个参数，会自动成为返回新函数中参数的默认值，那么正式调用的时候，只需给出除首个参数外，剩余参数即可。 123456function f(x,y)&#123; console.log(x+y);&#125;f.call(null,1,1) //return 2var new_f=f.bind(null,1,1);new_f(2); //return 2 上面实例中thisArg参数均用null代替了，在未给出指定thisArg对象情况下，null与undefined下this指向的是全局对象，即js代码执行环境。 apply, call, bind比较123456789101112var obj=&#123;bar:&apos;hello&apos;&#125;var foo=&#123; get:function()&#123; return this.bar; &#125;&#125;var bind=foo.get.bind(obj), call=foo.get.call(obj), apply=foo.get.apply(obj);console.log(bind(),call,apply); //hello hello helloconsole.log(bind,call,apply); //function()&#123;return this.bar;&#125; &quot;hello&quot; &quot;hello&quot;console.log(typeof bind,typeof call,typeof apply); function string stringconsole.log(typeof bind(),typeof call,typeof apply); //string string string 三者的区别是：当你希望改变上下文环境之后并非立即执行，而是回调执行的时候，使用bind()方法，而apply/call则会立即执行函数。1234apply, call, bind三者都是用来改变函数的this对象的指向apply, call, bind三者第一个参数都是this要指向的对象，也就是想指定的上下文apply, call, bind三者都可以利用后续参数传参bind是返回对应的函数，便于稍后调用；apply, call则立即调用","categories":[],"tags":[],"keywords":[]},{"title":"JS定义变量的三种方式","slug":"JS定义变量的三种方式","date":"2017-06-05T03:05:49.000Z","updated":"2017-06-05T03:18:28.496Z","comments":true,"path":"2017/06/05/JS定义变量的三种方式/","link":"","permalink":"https://aliceflaviawang.github.io/2017/06/05/JS定义变量的三种方式/","excerpt":"","text":"1、最常见的var定义变量，可以修改，如果不初始化会输出undefined,但不会报错。12345678var a=1;console.log(&apos;函数外定义a:&apos;+a); //输出a=1function change()&#123; a=4; console.log(&apos;函数内定义a:&apos;+a); //可以输出a=4;&#125;change();console.log(&apos;函数调用后var定义a为函数内部修改值:&apos;+a); //输出a=4 2、const定义的变量不可以修改，而且必须初始化。12345const b=2;// const b; //错误，必须初始化console.log(b); //有输出值// b=5;console.log(b); //报错，不能给常量赋值 3、let是块级作用域，函数内部使用let定义后，对函数外部无影响。12345678let c=3;console.log(&apos;函数外定义c:&apos;+c); //输出c=3;function change()&#123; let c=6; console.log(&apos;函数内定义c:&apos;+c); //输出c=6;&#125;change();console.log(&apos;函数调用后let定义c不受函数内部定义的影响：&apos;+c); //输出c=3;","categories":[],"tags":[],"keywords":[]},{"title":"从输入URL到浏览器显示页面发生了什么","slug":"从输入URL到浏览器显示页面发生了什么","date":"2017-05-27T02:06:07.000Z","updated":"2017-05-27T07:15:26.824Z","comments":true,"path":"2017/05/27/从输入URL到浏览器显示页面发生了什么/","link":"","permalink":"https://aliceflaviawang.github.io/2017/05/27/从输入URL到浏览器显示页面发生了什么/","excerpt":"","text":"从输入URL到浏览器显示页面，这个过程分为两个部分：网络通信和页面渲染。 一、网络通信互联网内各网络设备间的通信都遵循TCP/IP协议，利用TCP/IP协议族进行网络通信时，会通过分层顺序与对方进行通信。分层由高到低分别为：应用层、传输层、网络层、数据链路层。发送端从应用层往下走，接收端从数据链路层往上走。如下图所示： 1.在浏览器中输入URL用户输入URL，例如http://www.baidu.com。其中http为协议，www.baidu.com为网络地址，及指出需要的资源在那台计算机上。一般网络地址可以为域名或IP地址，此处为域名。使用域名是为了方便记忆，但是为了让计算机理解这个地址还需要把它解析为IP地址。 2.应用层DNS解析域名客户端先检查本地是否有对应的IP地址，若找到则返回响应的IP地址。若没找到则请求上级DNS服务器，直至找到根节点。 3.应用层客户端发送HTTP请求HTTP请求包括请求报头和请求主体两个部分，其中请求报头包含了至关重要的信息，包括请求的方法（GET/POST)、目标URL、遵循的协议（HTTP/HTTPS/FTP…),返回的信息是否需要缓存，以及客户端是否发送cookie等。 4.传输层TCP传输报文位于传输层的TCP协议为传输报文提供可靠的字节流服务。它为了方便传输，将大块的数据分割成以报文段位单位的数据包进行管理，并为它们编号，方便服务器接收时能准确地还原报文信息。TCP协议通过“三次握手”等方法保证传输的安全可靠。“三次握手”的过程是，发送端先发送一个带有SYN标志的数据包给接收端，在一定的延迟时间内等待接收的回复。接收端收到数据包后，传回一个带有SYN/ACK标志的数据包以示传达确认信息。接收方收到后再发送一个带有ACL标志的数据包给接收端以示握手成功。在这个过程中，如果发送端在规定延迟时间内没有收到回复则默认接收方没有收到请求，而再次发送，直到收到回复为止。 5.网络层IP协议查询MAC地址IP协议的作用是把TCP分割好的各种数据包传送给接收方。而要保证确实能传到接收方还需要接收方的MAC地址，也就是物理地址。IP地址和MAC地址是一一对应的关系，一个网络设备的IP地址可以更换，但是MAC地址一般是固定不变的。ARP协议可以将IP地址解析成对应的MAC地址。当通信的双方不在同一个局域网时，需要多次中转才能到达最终的目标，在中转的过程中需要通过下一个中转站的MAC地址来搜索下一个中转目标。 6.数据到达数据链路层在找到对方的MAC地址后，就将数据发送到数据链路层传输。这时客户端发送请求的阶段结束。 7.服务器接收数据接收端的服务器在链路层接收到数据包，再层层向上直到应用层。这过程中包括在运输层通过TCP协议将分段的数据包重新组成原来得HTTP请求报文。 8.服务器响应请求服务接收到客户端发送的HTTP请求后，查找客户端请求的资源，并返回响应报文，响应报文中包括一个重要的信息————状态码。状态码由三位数字组成，其中比较常见的是200 OK表示请求成功。301表示永久重定向，即请求的资源已经永久转移到新的位置。在返回301状态码的同时，响应报文也会附带重定向的URL，客户端接收后将HTTP请求的URL做相应的改变再重新发送。404 not found表示客户端请求的资源找不到。 9.服务器返回相应文件请求成功后，服务器会返回相应的HTML文件。接下来就到了页面渲染阶段了。 二、页面渲染现代浏览器渲染页面的过程是这样的：解析HTML以构建DOM树——&gt;构建渲染树——&gt;布局渲染树——&gt;绘制渲染树。DOM树是由HTML文件中的标签排列组成，渲染树是在DOM树种加入CSS或HTML中的style样式而形成。渲染树只包含显示在页面中的DOM元素，像元素或display属性值为none的元素都不在渲染树中。在浏览器还没接收到完整的HTML文件时，它就开始渲染页面了，在遇到外部链入的脚本标签或样式标签或图片时，会再次发送HTTP请求重复上述的步骤。在收到CSS文件后会对已经渲染的页面重新渲染，加入它们应有的样式，图片文件加载完立刻显示在相应位置。在这一过程中可能会触发页面的重绘或重排。","categories":[],"tags":[],"keywords":[]},{"title":"DOM性能提升","slug":"DOM性能提升","date":"2017-05-26T07:42:01.000Z","updated":"2017-05-26T08:51:27.848Z","comments":true,"path":"2017/05/26/DOM性能提升/","link":"","permalink":"https://aliceflaviawang.github.io/2017/05/26/DOM性能提升/","excerpt":"","text":"DOM(文档对象模型)是针对HTNL和XML文档的一个API（应用程序编程接口），DOM可以将任何一个HTML或XML文档描绘成一个由多层节点构成的节点树，允许开发人员添加、移除和修改页面的某一部分。 DOM的核心问题DOM会导致一系列的重绘(repaint)、重新排版(reflow)操作。为了确保执行结果的准确性，所有的修改是按顺序同步进行的，大部分浏览器都不会在执行过程中更新DOM。相应的，这些浏览器将对DOM的操作放在一个队列，并在JavaScript脚本执行完毕以后按顺序一次执行完毕。也就是说，在JavaScript执行的过程，直到发生重新排版，用户一直被阻塞。一般的浏览器中（不含IE），repaint的速度远快于reflow，所以避免reflow更重要。reflow:例如某个子元素样式发生改变，直接影响到了其父元素以及往上追溯很多祖先元素（包括兄弟元素），这时候浏览器要重新渲染这个子元素相关联的所有元素的过程。reflow几乎无法避免。repaint:如果只是改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性，将只会引起浏览器的repaint。 解决方案关键：减少DOM操作引起的reflow。 1、使用DoucumentFragment一次性更新DOM12345678//使用容器保存临时变更，最后一次性更新DOMvar fragment=document.createDocumentFragment();for(var i=0;i&lt;items,length;i++)&#123; var item=document.createElement(&quot;li&quot;); item.appendChild(document.createTextNode(&quot;Option&quot;+i); fragment.appendChild(item); &#125;list.appendChild(fragment); 2、操作DOM前，先把DOM节点删除或隐藏，因为隐藏的节点不会发生重排1234567list.style.display=&quot;none&quot;;for(var i=0;i&lt;items,length;i++)&#123; var item=document.createElement(&quot;li&quot;); item.appendChild(document.createTextNode(&quot;Option&quot;+i); list.appendChild(item); &#125;list.style.display=&quot;&quot;; 3、一次性修改样式属性1234//这样做很引起多次重排element.style.backgroundColor=&quot;blue&quot;;element.style.color=&quot;red&quot;;element.style.fontSize=&quot;12em&quot;; 1234567//更好的做法是，把样式放在一个class下.newStyle&#123; background-color:blue; color:red; font-size:12em;&#125;element.className=&quot;newStyle&quot;; 4、使用缓存，缓存临时节点12//不好的做法document.getElementById(&quot;myDiv&quot;).style.left=document.getElementById(&quot;myDiv&quot;).offsetLeft+document.getElementById(&quot;myDiv&quot;).offsetWidth+&quot;px&quot;; 123//更好的做法var myDiv=document.getElementById(&quot;myDiv&quot;);myDiv.style.left=myDiv.offsetLeft+myDiv.offsetWidth+&quot;px&quot;;","categories":[],"tags":[],"keywords":[]},{"title":"跨浏览器事件对象———EventUtil","slug":"跨浏览器事件对象———EventUtil","date":"2017-05-24T02:12:22.000Z","updated":"2017-07-25T12:46:22.763Z","comments":true,"path":"2017/05/24/跨浏览器事件对象———EventUtil/","link":"","permalink":"https://aliceflaviawang.github.io/2017/05/24/跨浏览器事件对象———EventUtil/","excerpt":"","text":"前言EventUtil:在JavaScript中，DOM0级、DOM2级与旧版本IE（8-）为对象添加事件的方法不同，为了以跨浏览器的方式处理时间，需要编写一段“通用代码”，即跨浏览器的事件处理程序，这个方法属于一个名为EventUtil的对象，编写并使用该对象后，可保证处理事件的代码能在大多数浏览器下一致地运行。 EventUtil对象123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106var EventUtil=&#123; addHandler:function(element,type,handler)&#123;//添加事件 if(element.addEventListener)&#123; element.addEventListener(type,handler,false); //使用DOM2级方法添加事件，三个参数分别是：要处理的事件名、作为事件处理的函数和一个布尔值（布尔值表示在捕获阶段(true)还是冒泡阶段(false)调用事件处理程序） &#125; else if(element.attachEvent)&#123; element.attachEvent(&quot;on&quot;+type,handler); //使用IE方法添加事件，两个参数分别为：事件处理程序名称和事件处理程序的函数 &#125; else&#123; element[&quot;on&quot;+type]=handler; //使用DOM0级方法添加事件 &#125; &#125;， removeHandler:function(element,type,handler)&#123; //取消事件 if(element.removeEventListener)&#123; element.removeEventListener(type,handler,false); &#125; else if(element.detachEvent)&#123; element.detachEvent(&quot;on&quot;+type,handler); &#125; else&#123; element[&quot;on&quot;+type]=null; &#125; &#125;, getEvent:function(event)&#123; //使用这个方法跨浏览器取得event对象 return event?event:window.event; //在IE中，使用DOM0级添加事件处理程序时，event对象作为window对象的一个属性存在，而且在IE中，event对象的一些属性/方法跟其他支持DOM的浏览器不同，正是由于这些差异，EventUtil中的getEvent方法应运而生 &#125;, getTarget:function(event)&#123; //返回事件的实际目标 return event.target||event.srcEelment; //在IE中，获取事件的目标对象的方法为event.srcElement，而其他兼容DOM的浏览器中，获取事件目标对象的方法却为event.target &#125;, preventDefault:function(event)&#123; //阻止事件的默认行为 if(event.preventDefault)&#123; //在其他兼容DOM的浏览器中，阻止特定事件的默认行为只需要使用event对象自带的preventDefault()方法 event.preventDefault(); &#125;else&#123; //而IE中，则需要赋予event.returnValue的值为false才能阻止特定事件的默认行为 event.returnValue=false; &#125; &#125; stopPropagation:function(event)&#123; if(event.stopPropagation)&#123; event.stopPropagation(); //DOMO级或DOM2级取消事件进一步冒泡或者捕获 &#125;else&#123; event.cancelBubble=true; //IE中取消时间冒泡 &#125; &#125;, getRelatedTarget:function(event)&#123; //获取mouseover和mouseout相关元素//mouseover与mouseout有“主目标”和“相关元素”的概念，因为在发生mouseover或mouseout事件时，还会涉及到其他元素，这两个事件都会涉及把鼠标指针从一个元素移到另一个元素。具体来说，对mouseover事件，事件的主目标是获得光标的元素，而相关元素是那个失去光标的元素，对mouseout事件而言，事件的主目标是失去光标的元素，而相关元素是那个获得光标的元素。 if(event.relatedTarget)&#123; return event.relatedTarget; &#125; else if(event.toElement)&#123; //mouseout触发时，IE的toElement保存的相关元素属性 return event.toElement; &#125; else if(event.formElement)&#123; //mouseover触发时，IE的formElement保存相关元素属性 return event.formElement; &#125; else&#123; return null; &#125; &#125;, getButton:function(event)&#123; //获取mousedown或mouseup按下或释放的按钮是鼠标的哪一个 if(document.implementation.hasFeature(&quot;MouseEvents&quot;,&quot;2.0&quot;))&#123; return event.button; &#125;else&#123; switch(event.button)&#123;//将IE模型下的button属性映射为DOM模型下的button属性 case 0: case 1; case 3; case 5; case 7; return 0; //按下的是鼠标主按钮（一般是左键） case 2: case 6: return 2; //按下的是中间的鼠标按钮 case 4: return 1; //鼠标次按钮（一般是右键） &#125; &#125; &#125;, getWheelDelta:function(event)&#123; //获取表示鼠标滚轮滚动方向的数值//解决的是与Firefox的差异 if(event.wheelDelta)&#123; return event.wheelDelta; &#125; else&#123; return -event.detail*40; &#125; &#125;, getCharCode:function(event)&#123; //跨浏览器取得相同的字符编码，需在keypress事件中使用//在所有浏览器中，按下能够插入或删除的字符的按键都会触发keypress事件，但IE8-及Opera取得字符编码的方式与其他浏览器有差异 if(typeof event.charCode==&quot;number&quot;)&#123; return event.charCode; &#125;else&#123; return event.keyCode; &#125; &#125;&#125; 举例用法1234567//添加了EventUtil之后，获取了event对象、取消了事件进一步捕获或者冒泡、指定了事件的处理程序而无须担心浏览器兼容问题var btn=document.getElementById(&quot;#btn&quot;);var handler=function(event)&#123; event=EventUtil.getEvent(event); EventUtil.stopPropagation(event); &#125;Event.addHandler(btn,&quot;click&quot;,handler); 补充addEventListener的第三个参数useCapture事件有三个阶段：捕获阶段：外–&gt;里目标阶段：冒泡阶段：里–&gt;外useCapture是一个布尔值，默认是false。如果是true的话表示在事件捕获阶段调用事件处理程序；如果是false表示在事件冒泡阶段处理程序。","categories":[],"tags":[],"keywords":[]},{"title":"为什么js没有函数签名","slug":"为什么js没有函数签名","date":"2017-05-01T02:30:42.000Z","updated":"2017-05-02T01:18:01.450Z","comments":true,"path":"2017/05/01/为什么js没有函数签名/","link":"","permalink":"https://aliceflaviawang.github.io/2017/05/01/为什么js没有函数签名/","excerpt":"","text":"什么是函数签名MDN上关于函数签名的说明：A function signature(or type signature, or method signature) defines input and putput of functions or methods.A signature can include: parameters and their types a return value and type exceptions that might be thrown or passed back information about the availability of the method in an object-oriented program(such as the keywords public, static, or prototype).翻译过来就是函数签名定义了函数或方法的输入输出，签名包括参数个数和类型、返回值和类型、抛出或者往后传的异常、面向对象程序方法可行性的信息。为什么js没有函数签名在其他语言中，命名参数必须要求事先创建函数签名，将来调用也必须与该签名一致；而js的参数是由包含0个或多个值的数组来表示的，命名参数只是提供便利，但不是必须的，解析器也不会验证命名参数，所以js没有签名。举个例子：1234function sayHi()&#123; alert(&quot;Hi &quot;+arguments[0]+&quot;, &quot;+arguments[1]);&#125;sayHi(&quot;Alice&quot;,&quot;how are you?&quot;); 对这个例子，命名参数为空，但是照样可以按照两个参数的格式去调用该方法，是因为对ECMAScript，无论传递给函数的参数是什么，函数接收到的始终都是数组，通过arguments对象访问的参数数组。所谓的参数类型、参数个数、参数位置、出入参数，js都不关心，它所有的值都被放倒arguments中了，需要返回值的话直接return，不用声明。","categories":[],"tags":[],"keywords":[]},{"title":"slice(), substring(), substr()总结","slug":"slice-substring-substr-总结","date":"2017-04-25T13:47:05.000Z","updated":"2017-04-25T13:56:07.132Z","comments":true,"path":"2017/04/25/slice-substring-substr-总结/","link":"","permalink":"https://aliceflaviawang.github.io/2017/04/25/slice-substring-substr-总结/","excerpt":"","text":"slice(), substring(), substr()都是用来获取子字符串，，且不会修改字符串本身的值。区别：1、参数不同slice: slice(start, end) //start表示子字符串开始的位置，end是子字符串最后一个字符后面的位置substring: substring(start, end) //同slicesubstr: substr(start, num) //num表示返回字符的个数2、参数是负值的情况不同slice: 将负值与字符串长度相加substring： 将所有的负值转换成0，且会将较小的数作为开始位置，较大的数作为结束位置substr: 将负的第一个参数加上字符串长度，负数第二个参数转换为0```var s=”hello world”;s.slice(3,-4); //“lo w”s.substring(3,-4); //“hel”s.substr(3,-4); //“”（空字符串）","categories":[],"tags":[],"keywords":[]},{"title":"append和prepend","slug":"append和prepend","date":"2017-04-24T14:09:07.000Z","updated":"2017-04-24T14:17:54.922Z","comments":true,"path":"2017/04/24/append和prepend/","link":"","permalink":"https://aliceflaviawang.github.io/2017/04/24/append和prepend/","excerpt":"","text":"append()和prepend()方法都是jQuery文档操作方法，append()在被选元素的结尾插入指定内容，而prepend()则是在被选元素的前面插入制定内容。比如：1234&lt;div id=&quot;console&quot;&gt; &lt;h2&gt;Console Log&lt;/h2&gt; &lt;ul&gt;&lt;/ul&gt;&lt;/div&gt; 添加元素到ul中123456var $consoleLog = $(&quot;#console ul&quot;); var show = function(msg) &#123; var $msg = $(&quot;&lt;li&gt;&lt;/li&gt;&quot;); $msg.text(msg); $consoleLog.prepend($msg); &#125;; 此处采用prepend是从下往上的添加元素，最新添加的元素显示在最上面.注：$(&quot;&lt;li&gt;&lt;/li&gt;&quot;)是创建一个li元素并返回jQuery对象，不是选中它，因为这样创建的元素还不在html结构中，只是在内存中存在。","categories":[],"tags":[],"keywords":[]},{"title":"transform-origin,rotate实现绕中心旋转","slug":"transform-origin-rotate实现绕中心旋转","date":"2017-04-24T13:40:49.000Z","updated":"2017-04-24T14:00:43.434Z","comments":true,"path":"2017/04/24/transform-origin-rotate实现绕中心旋转/","link":"","permalink":"https://aliceflaviawang.github.io/2017/04/24/transform-origin-rotate实现绕中心旋转/","excerpt":"","text":"一般实现环形旋转可以通过animation动画的方式举个例子：1&lt;img src=&quot;images/min-iconfont-rocket-active.png&quot;&gt; 通过animation，对应的css代码为：1234567891011121314@keyframes spin&#123; to&#123; transform: rotate(1turn); &#125;&#125;img&#123; position: absolute; top:50px; left:50px; width:50px; height:50px; animation:spin 10s infinite linear; transform-origin:150px 150px;&#125; 也可以通过transform-origin+rotate的js实现，transform-origin对应旋转中心的位置，rotate可以设置旋转的角度。设置一个图片进行旋转，对于的css代码12345678img&#123; position: absolute; top:50px; left:50px; width:50px; height:50px; transform-origin: 150px 150px; //设置旋转的中心位置 &#125; 对应的js123456789var deg=0;var timer=setInterval(function()&#123; deg+=10; rotate(deg);&#125;,20)function rotate(deg)&#123; var my=&quot;rotate(&quot;+deg+&quot;deg)&quot; $(&quot;img&quot;).css(&quot;transform&quot;,my)&#125; 对于transform-orgin其默认的位置是元素的中心位置，可以通过设置重新确定中心。注：想了解更多transform实现环形路径平移动画，可以参看 http://www.open-open.com/lib/view/open1478661385568.html.","categories":[],"tags":[],"keywords":[]},{"title":"apply()和call()用法","slug":"apply-和call-用法","date":"2017-04-24T03:10:47.000Z","updated":"2017-04-24T06:38:18.222Z","comments":true,"path":"2017/04/24/apply-和call-用法/","link":"","permalink":"https://aliceflaviawang.github.io/2017/04/24/apply-和call-用法/","excerpt":"","text":"每个函数都有两个非继承的方法：apply（）和call()。这两个方法都是在特定作用域中调用函数，实际上等于设置函数体内this对象的值。 方法定义1、apply()方法——apply([thisObj[,argArray]])apply()接收两个参数：一个是运行函数的作用域，另一个是参数数组。其中第二个参数可以是Array的实例，也可以是arguments对象。 2、call()方法——call([thisObj[,arg1[, arg2[, [,.argN]]]]])与apply作用相同，区别在于接收参数方式不同。第一个参数this的值没有变化，其余参数是以列举的方式直接传递给函数。 作用1、扩充函数赖以运行的作用域12345678910window.color=&quot;red&quot;;var o=&#123;color:&quot;blue&quot;&#125;;function sayColor()&#123;alert(this.color)&#125;sayColor(); //redsayColor.call(this); //redsayColor.call(window); //redsayColor.call(o); //blue sayColor.call(o)与o.sayColor()效果一样，但是使用call()(或apply())是的对象不需要与方法有任何耦合关系。 2、实现继承1234567891011function Animal(name)&#123;this.name=name;this.showName=function()&#123;alert(this.name);&#125;&#125;function Cat(name)&#123;Animal.call(this,name);&#125;var cat=new Cat(&apos;Black Cat&apos;);cat.showName(); //Black Cat 3、实现多重继承12345678910111213141516171819202122var s1=function(name)&#123;this.name=name;&#125;var s2=function(sex)&#123;this.sex=sex;&#125;var s3=function(age)&#123;this.age=age;&#125;var Student=function(name,sex,age,score)&#123;s1.call(this,name);s2.call(this,sex);s3.call(this,age);this.score=score;&#125;Student.prototype.construction=Student;var s=new Student(&apos;jack&apos;,&apos;male&apos;,&apos;32&apos;,&apos;100&apos;);console.log(s.name); //jackconsole.log(s.sex); //maleconsole.log(s.age); //32console.log(s.score); //100","categories":[],"tags":[],"keywords":[]},{"title":"理解arguments","slug":"理解arguments","date":"2017-04-24T02:02:40.000Z","updated":"2017-04-24T02:38:43.554Z","comments":true,"path":"2017/04/24/理解arguments/","link":"","permalink":"https://aliceflaviawang.github.io/2017/04/24/理解arguments/","excerpt":"","text":"ECMAScript中的参数是用一个数组表示的。无论传递给函数的参数是什么（有或者没有），函数接收到的始终都是这个数组。在函数体内通过arguments对象来访问这个参数数组，从而获取传递给函数的每个参数。例如：1234function sayHi(name,message)&#123;return;alert(&quot;Hello &quot;+name+&quot;,&quot;+message);&#125; 可以用arguments重写不显示的使用命名参数：1234function sayHi()&#123;return;alert(&quot;Hello &quot;+arguments[0]+&quot;,&quot;+arguments[1]);&#125; arguments特性1、arguments对象的长度是由传入的参数的长度决定的，不是由定义函数时的命名参数的个数决定的123456function howManyArgs(&#123;alert(arguments.length);&#125;howManyArgs(&quot;string&quot;,45); //2howManyArgs(); //0howManyArgs(12) //1 2、arguments的值永远与对应命名参数的值保持同步1234function doAdd(num1,num2)&#123;arguments[1]=10;alert(arguments[0]+num2);&#125; 每次执行doAdd函数都会重写第二个参数（将其修改为10），因为arguments[1]的对象的值会自动反映到对应的命名参数，所以修改了arguments[1]也就修改了num2，他们的值会同步（但内存空间是独立的）。如果只传入了一个参数，arguments[1]的值不会反映到命名参数中（因为特性1）。 3、arguments对象有个callee属性callee属性是一个指针，指向拥有这个arguments对象的函数。1234567fucntion factorial(num)&#123;if(num&lt;=1)&#123;return 1;&#125;else&#123;return num*factorial(num-1);&#125;&#125; 上面的函数的执行与函数名紧紧耦合在一起，为了消除这种紧密耦合现象，可以用arguments.callee。1234567function factorial(num)&#123;if(num&lt;=1)&#123;return 1;&#125;else&#123;return num*arguments.callee(num-1);&#125;&#125; 这样，无论引用函数是时使用的什么名字，都可以保证正常递归调用。看一个例子：12345678910111213function factorial(num)&#123;if(num&lt;=1)&#123;return 1;&#125;else&#123;return num*arguments.callee(num-1);&#125;&#125;var trueFactoral=factorial;factorial=function()&#123;return 0;&#125;alert(trueFactoral(5)); //120alert(factorial(5)); //0 而使用函数名，则：12345678910111213function factorial(num)&#123;if(num&lt;=1)&#123;return 1;&#125;else&#123;return num*factorial(num-1);&#125;&#125;var trueFactoral=factorial;factorial=function()&#123;return 0;&#125;alert(trueFactoral(5)); //0alert(factorial(5)); //0 后记——函数对象的caller属性当一个函数调用另一个函数时，被调用的函数会自动生成一个caller属性，指向调用它的函数对象。若该函数未被调用或没有被其他函数调用，caller为null。而arguments.callee是函数被调用时，arguments.callee对象指向自身，是对自己的引用。注：arguments在函数调用时才有效，因为arguments.callee在函数未调用时是不存在的（即null.callee)。","categories":[],"tags":[],"keywords":[]},{"title":"translate(-50%,-50%)的作用","slug":"translate-50-50-的作用","date":"2017-04-22T14:01:12.000Z","updated":"2017-04-22T14:01:34.391Z","comments":true,"path":"2017/04/22/translate-50-50-的作用/","link":"","permalink":"https://aliceflaviawang.github.io/2017/04/22/translate-50-50-的作用/","excerpt":"","text":"当使用top:50%;left:50%的时候，是以左上角为原点，故元素不处于中心位置。translate(-50%,-50%)的作用是往上（x轴），左（y轴）移动自身长宽的50%，使得元素处于中心位置。例如：1234&lt;div id=&quot;outer&quot;&gt; &lt;div id=&quot;inner&quot;&gt; &lt;/div&gt;&lt;/div&gt; 如果不加transform属性1234567891011121314#outer&#123; position: relative; width: 500px; height: 500px; border: 1px solid black;&#125;#inner&#123; position: absolute; top: 50%; left: 50%; width: 100px; height: 100px; background-color: red;&#125; inner框的左上角处于中心位置，如果希望其中心居于中心位置，将应该向上和向左移动一半的边长长度。加上transform属性，就可以实现这个效果：123456789101112#inner &#123; position: absolute; top: 50%; left: 50%; width: 100px; height: 100px; background-color: red; -ms-transform: translate(-50%,-50%); -moz-transform: translate(-50%,-50%); -o-transform: translate(-50%,-50%); transform: translate(-50%,-50%); &#125;","categories":[],"tags":[],"keywords":[]},{"title":"阿里暑期前端面试总结","slug":"阿里暑期前端面试总结","date":"2017-04-19T10:40:53.000Z","updated":"2017-04-19T10:40:53.645Z","comments":true,"path":"2017/04/19/阿里暑期前端面试总结/","link":"","permalink":"https://aliceflaviawang.github.io/2017/04/19/阿里暑期前端面试总结/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"腾讯暑期实习面试前端面试总结","slug":"腾讯暑期实习面试前端面试总结","date":"2017-04-19T07:36:12.000Z","updated":"2017-04-19T08:25:23.576Z","comments":true,"path":"2017/04/19/腾讯暑期实习面试前端面试总结/","link":"","permalink":"https://aliceflaviawang.github.io/2017/04/19/腾讯暑期实习面试前端面试总结/","excerpt":"","text":"4月13号参加的腾讯面试，不得不说面试机制还是比较完善，通知的10点面试，9点20到达酒店之后，差不多10点就通知了面试地点去候场。因为房间门是开的，所以听到了前一个人的部分面试问题：1、http状态码有哪些，代表的什么意思2、用过缓存没有，local storage和session storage有什么区别3、你说你学过node js，讲一下于是我在门外默默的准备了一下，进去之后面试官看了我的简历上写本科是信息安全，于是问我公钥加密和私钥加密有什么区别。。。我大概记得，但是说反了，然后开始问我一串安全相关的问题，安全掌握的不怎么好，面试官大概没有很多兴趣，就简单问了下css和一个逻辑题就完了：1、Web安全2、url是怎么加密的3、css的优先级4、逻辑题：给一个不规则的5L和6L的桶，装一个3升的水然后很显然就没有然后了，通过此次面试，觉得自己还是要多注意Web安全方面的知识，另外简历上处处都有可能问到，主要看面试官比较擅长哪方面，所以只要写上去都要有所准备。","categories":[],"tags":[],"keywords":[]},{"title":"easyui两个datagrid的问题","slug":"easyui两个datagrid的问题","date":"2017-04-11T11:11:39.000Z","updated":"2017-04-11T11:21:49.478Z","comments":true,"path":"2017/04/11/easyui两个datagrid的问题/","link":"","permalink":"https://aliceflaviawang.github.io/2017/04/11/easyui两个datagrid的问题/","excerpt":"","text":"问题easyui框架下，当一个页面出现两个datagrid，或者说出现两个table的时候，datagrid的某些属性会失效，比如说pagination分页会失效. 解决办法使用两个div将两个datagrid分开，但是使用两个div后，页面不能填充整个屏幕，所以解决两个datagrid分页失效的问题转化为了如何让div填充整个屏幕的问题。解决方法如下：123456789&lt;style&gt;html, body&#123;margin:0;padding:0;&#125;div&#123;width:100%;&#125;&lt;/style&gt;","categories":[],"tags":[],"keywords":[]},{"title":"easyui表格查询","slug":"easyui表格查询","date":"2017-04-10T13:09:22.000Z","updated":"2017-04-10T13:24:40.892Z","comments":true,"path":"2017/04/10/easyui表格查询/","link":"","permalink":"https://aliceflaviawang.github.io/2017/04/10/easyui表格查询/","excerpt":"","text":"easyui表格查询非常简单，比如说对于一个datagrid如下1234567891011121314151617181920212223242526272829303132333435363738&lt;div id=&quot;toolbar1&quot;&gt; &lt;div style=&quot;padding:3px&quot;&gt; &lt;span&gt;部门 ID:&lt;/span&gt; &lt;input id=&quot;deptId&quot; style=&quot;line-height:26px;border:1px solid #ccc&quot;&gt; --&gt; &lt;span&gt;部门名称:&lt;/span&gt; &lt;input id=&apos;dd&apos; &gt; &lt;span&gt;岗位类型:&lt;/span&gt; &lt;input id=&apos;dd3&apos; &gt; &lt;span&gt;设岗科室名称:&lt;/span&gt; &lt;input id=&apos;dd2&apos; style=&quot;line-height:22px;border:1px solid #ccc;border-radius:5px;&quot;&gt; &lt;span&gt;指导老师:&lt;/span&gt; &lt;input id=&apos;dd1&apos; style=&quot;line-height:22px;border:1px solid #ccc;border-radius:5px;&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;easyui-linkbutton&quot; plain=&quot;true&quot; iconCls=&quot;icon-search&quot; onclick=&quot;doFind()&quot;&gt;查询&lt;/a&gt; &lt;/div&gt; &lt;div&gt;&lt;table id=&quot;tt1&quot; title=&quot;岗位申请&quot; class=&quot;easyui-datagrid&quot; style=&quot;width:100%;height:auto;&quot; singleSelect=&quot;true&quot; data-options=&quot;fit:true&quot; rownumbers=&quot;true&quot; idField=&apos;deptId&apos; method=&apos;post&apos; toolbar=&apos;#toolbar1&apos;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th rowspan=&quot;2&quot; field=&quot;deptId&quot; width=&quot;5%&quot; align=&quot;center&quot;&gt;学院/部门ID&lt;/th&gt; &lt;th rowspan=&quot;2&quot; field=&quot;deptName&quot; width=&quot;6%&quot; align=&quot;center&quot;&gt;学院/部门名称&lt;/th&gt; &lt;th rowspan=&quot;2&quot; field=&quot;jobTime&quot; width=&quot;6%&quot; align=&quot;center&quot;&gt;岗位时间&lt;/th&gt; &lt;th rowspan=&quot;2&quot; field=&quot;teacherName&quot; width=&quot;6%&quot; align=&quot;center&quot;&gt;指导老师&lt;/th&gt; &lt;th rowspan=&quot;2&quot; field=&quot;telephone&quot; width=&quot;7%&quot; align=&quot;center&quot;&gt;指导老师电话&lt;/th&gt; &lt;th rowspan=&quot;2&quot; field=&quot;guideTrain&quot; width=&quot;10%&quot; align=&quot;center&quot;&gt;指导与培训体系&lt;/th&gt; &lt;th colspan=&quot;6&quot; align=&quot;center&quot; &gt;岗位要求&lt;/th&gt; &lt;th rowspan=&quot;2&quot; field=&quot;statusCodeName&quot; align=&quot;center&quot; width=&quot;5%&quot;&gt;审核状态&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th field=&quot;officeName&quot; align=&quot;center&quot; width=&quot;9%&quot;&gt;设岗科室名称&lt;/th&gt; &lt;th field=&quot;typeName&quot; align=&quot;center&quot; width=&quot;8%&quot;&gt;岗位类型&lt;/th&gt; &lt;th field=&quot;jobNum&quot; align=&quot;center&quot; width=&quot;8%&quot;&gt;设岗科室岗位数&lt;/th&gt; &lt;th field=&quot;jobWork&quot; align=&quot;center&quot; width=&quot;8%&quot;&gt;科室工作量&lt;/th&gt; &lt;th field=&quot;responsibility&quot; align=&quot;center&quot; width=&quot;10%&quot;&gt;科室工作职责&lt;/th&gt; &lt;th field=&quot;ability&quot; align=&quot;center&quot; width=&quot;12%&quot;&gt;科室岗位培养的综合素质&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;/table&gt; 查询部分的js代码12345678910111213function doFind()&#123;//获取查询条件 var val = $(&apos;#dd&apos;).combobox(&apos;getValue&apos;); var teacherName = $(&apos;#dd1&apos;).val(); var officeName = $(&apos;#dd2&apos;).val(); var type = $(&apos;#dd3&apos;).combobox(&apos;getValue&apos;);//根据查询条件在表格tt中load出来$(&quot;#tt1&quot;).datagrid(&apos;load&apos;,&#123;deptId:val,teacherName:teacherName,officeName:officeName,type:type&#125;) 但是发现这样有问题，如果某项没填，比如teacherName为空，那么将会在表格中查询teacherName为空的项，从而查不到结果。因此采取先判断查询项是否为空，才能得出正确结果。123456789101112131415161718192021222324252627function doFind()&#123; var val = $(&apos;#dd&apos;).combobox(&apos;getValues&apos;);//允许多选的情况，首先要在id为dd的combobox设置multipl为true if (val[0] == &apos;&apos;) &#123; val = val.slice(1) &#125; var teacherName = $(&apos;#dd1&apos;).val(); var officeName = $(&apos;#dd2&apos;).val(); var type = $(&apos;#dd3&apos;).combobox(&apos;getValue&apos;) var deptIds = val.join(&apos;,&apos;);//将每项用,分开 var query = &#123;&#125; //判断查询条件是否为空，将查询条件保存到对象中 if(teacherName)&#123; query.teacherName=teacherName; &#125; if(officeName)&#123; query.officeName=officeName; &#125; if(type)&#123; query.type=type; &#125; if(deptIds)&#123; query.deptId=deptIds; &#125; $(&apos;#tt1&apos;).datagrid(&apos;load&apos;, query); &#125;","categories":[],"tags":[],"keywords":[]},{"title":"easyui的dialog中插入下拉框","slug":"easyui的dialog中插入下拉框","date":"2017-04-10T12:53:55.000Z","updated":"2017-04-10T13:06:30.491Z","comments":true,"path":"2017/04/10/easyui的dialog中插入下拉框/","link":"","permalink":"https://aliceflaviawang.github.io/2017/04/10/easyui的dialog中插入下拉框/","excerpt":"","text":"easyui是一个集成了各种用户界面的插件的框架，特别使用各种表格的开发，能大大节省时间。在项目中遇到的问题时，下dialog中无法使用combobox生成下拉框，于是只能通过打开dialog时插入一个下拉框。1234567891011121314151617181920212223$(&apos;#fm_deptId&apos;).append(&apos;&lt;option&gt;bitem6&lt;/option&gt;&apos;); var depts = []; var query = &#123; rows: 200, page: 1 &#125; var newHtml = &apos;&apos;; $.ajax(&#123; type: &apos;POST&apos;, async: false, url: url_queryDept,//向接口请求下拉框数据 contentType: &quot;application/json; charset=utf-8&quot;, data: JSON.stringify(query), dataType: &apos;json&apos;, success: function(data) &#123; $.each(data.result, function(i, val) &#123; var temp = val.deptId + val.deptName;数据由一个id和name组成 var option = &apos;&lt;option value=&apos; + val.deptId + &apos;&gt;&apos; + temp + &apos;&lt;/option&gt;&apos;; newHtml = newHtml + option; &#125;) $(&apos;#fm_deptId&apos;)[0].innerHTML = newHtml; &#125;&#125;) 注：如果想要选中下拉框的某一个选项作为下拉框的默认值1$(&apos;#fm_deptId option[value=&apos;+ current_deptId+&apos;] &apos;).attr(&quot;selected&quot;,true);","categories":[],"tags":[],"keywords":[]},{"title":"win10永久激活方方法","slug":"win10永久激活方方法","date":"2017-04-10T12:44:58.000Z","updated":"2017-04-10T12:48:18.180Z","comments":true,"path":"2017/04/10/win10永久激活方方法/","link":"","permalink":"https://aliceflaviawang.github.io/2017/04/10/win10永久激活方方法/","excerpt":"","text":"今天提示win10许可证要过期了，于是尝试了各种工具，Microsoft Toolkit、HEU_KMS_Activator、KMS10_Crack2都不行，最后在网上找到了这个方法，一分钟不到就搞定了，分享一下网址https://jingyan.baidu.com/article/73c3ce282431dbe50343d9a9.html。","categories":[],"tags":[],"keywords":[]},{"title":"JS与jQuery显示和隐藏div","slug":"JS与jQuery显示和隐藏div","date":"2017-04-10T12:25:07.000Z","updated":"2017-04-10T12:39:10.062Z","comments":true,"path":"2017/04/10/JS与jQuery显示和隐藏div/","link":"","permalink":"https://aliceflaviawang.github.io/2017/04/10/JS与jQuery显示和隐藏div/","excerpt":"","text":"关于div隐藏很显示的问题，经常遇到，JS和jQuery有不同的处理方式。1&lt;div id=&quot;div&quot;&gt;&lt;/div&gt; JS方式123document.getElementById(&quot;div&quot;).style.display=&quot;block&quot;;document.getElementById(&quot;div&quot;).style.display=&quot;none&quot;;//不占用空间document.getElementById(&quot;div&quot;).style.display=&quot;hidden&quot;;//仍然占用空间 jQuery方式123456//通过css方法设置属性$(&quot;#div&quot;).css(&quot;diaplay&quot;,&quot;block&quot;);//给元素换class，提前将换的class样式定义好display属性$(&quot;#div&quot;).attr(&quot;class&quot;,&quot;blockclass&quot;);//通过attr方法$(&quot;#div&quot;).attr(&quot;display&quot;,&quot;block&quot;); 注：jQuery的css方法和attr方法的区别,css顾名思义就是标签自带的css属性，atrr只能取自己定义的属性，例如，如果div中没有diaplay这个属性的话，不能用过attr给其赋值，但是可以用css方法。","categories":[],"tags":[],"keywords":[]},{"title":"JS与jQuery清空输入框","slug":"JS与jQuery清空输入框","date":"2017-04-10T12:12:09.000Z","updated":"2017-04-10T12:16:41.820Z","comments":true,"path":"2017/04/10/JS与jQuery清空输入框/","link":"","permalink":"https://aliceflaviawang.github.io/2017/04/10/JS与jQuery清空输入框/","excerpt":"","text":"input输入框输入之后，再次输入的时候需要清空输入框。对于input输入框，JS与jQuery清空方式不同。1&lt;input id=&quot;input&quot; type=&quot;text&quot; name=&quot;input&quot;&gt; JS方式1document.getElementById(&quot;input&quot;).value=&quot;&quot;; jQuery方式1$(&quot;#input&quot;).val(&quot;&quot;);","categories":[],"tags":[],"keywords":[]},{"title":"java二维排序数组查找元素","slug":"java二维排序数组查找元素","date":"2017-04-09T13:09:30.000Z","updated":"2017-04-09T13:14:14.944Z","comments":true,"path":"2017/04/09/java二维排序数组查找元素/","link":"","permalink":"https://aliceflaviawang.github.io/2017/04/09/java二维排序数组查找元素/","excerpt":"","text":"题目描述在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 简单做法看到这个题目，如果不考虑数组元素的排序，只考虑能不能找到的话，非常简单。12345678910public boolean Find(int target, int [][] array) &#123; for(int i=0;i&lt;array.length;i++)&#123; for(int j=0;j&lt;array[0].length;j++)&#123; if(array[i][j]==target)&#123; return true; &#125; &#125; &#125; return false; &#125; 运行效果 题目的本质因为数组是排序的，所以考虑用二分查找，而查找不能盲目的查找，比如从第一个元素开始查找，如果比目标元素小，是往下找还是往右找呢，同里也不能从最后一个元素开始查找，可以从第一行最右边开始查找，如果比目标元素大就往左查找，反之往下查找，同理也可以从第一列最下边开始查找。举例从第一行最右边开始查找，代码如下：12345678910111213141516public boolean Find(int target, int [][] array) &#123; int row=0; int col=array[0].length-1; while(row&lt;array.length&amp;&amp;col&gt;=0)&#123; if(array[row][col]==target) &#123; return true; &#125; else if(array[row][col]&lt;target)&#123; row++; &#125; else&#123; col--; &#125; &#125; return false; &#125; 运行效果 完整代码1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.company;import java.util.Scanner;public class Solution &#123; public boolean Find(int target, int [][] array) &#123; int row=0; int col=array[0].length-1; while(row&lt;array.length&amp;&amp;col&gt;=0)&#123; if(array[row][col]==target) &#123; return true; &#125; else if(array[row][col]&lt;target)&#123; row++; &#125; else&#123; col--; &#125; &#125; return false; &#125; public static void main(String srgs[])&#123; Scanner s=new Scanner(System.in); System.out.println(&quot;请输入数组的行和列&quot;); int x=s.nextInt(); int y=s.nextInt(); int [][]arr=new int[x][y]; System.out.println(&quot;请输入数组元素&quot;); for(int i=0;i&lt;x;i++)&#123; for(int j=0;j&lt;y;j++)&#123; arr[i][j]=s.nextInt(); &#125; &#125; System.out.println(&quot;请输入你想查找的数：&quot;); int t=s.nextInt(); Solution a=new Solution(); if(a.Find(t,arr))&#123; System.out.println(&quot;数组&quot;+arr+&quot;中有数&quot;+t); &#125;else&#123; System.out.println(&quot;数组&quot;+arr+&quot;中没有数&quot;+t); &#125; &#125;&#125;","categories":[],"tags":[],"keywords":[]},{"title":"基于easyui项目学习的总结（一）","slug":"基于easyui项目学习的总结（一）","date":"2017-04-09T12:59:26.000Z","updated":"2017-04-09T13:02:35.130Z","comments":true,"path":"2017/04/09/基于easyui项目学习的总结（一）/","link":"","permalink":"https://aliceflaviawang.github.io/2017/04/09/基于easyui项目学习的总结（一）/","excerpt":"","text":"最近在做的项目，是基于easyui框架，项目进度非常紧张，并没有太多时间来总结，就用零碎时间一点点总结吧，主要是从网上及大神同学身上学到了很多。 easyui placeholder解决方案因为easyui经常用到table、textbox，因此会遇到需要用placeholder来提示输入内容的时候，但是easyui不支持h5的placeholder,因此，为了实现这个效果，在网上找到了解决方案。1、给input标签添加placeholder1&lt;input id=&quot;fm_jobTime&quot;&quot; name=&quot;jobTime&quot; class=&quot;easyui-textbox&quot; required=&quot;true&quot; label=&quot;岗位时间:&quot; style=&quot;width:100%&quot; placeholder=&quot;xxxx年x月-xxxx年x月&quot;&gt; 2、页面加载完毕的时候，将easyui生成的input标签的placeholder重置12345678910111213141516$(function()&#123;window.onload = inputPlaceholder();&#125;);/**easyui number placeholder*/function numberinputPlaceholder()&#123;$(&quot;.easyui-textbox&quot;).each(function(i)&#123;var span = $(this).siblings(&quot;span&quot;)[0];var targetInput = $(span).find(&quot;input:first&quot;);if(targetInput)&#123;$(targetInput).attr(&quot;placeholder&quot;, $(this).attr(&quot;placeholder&quot;));&#125;&#125;);&#125;","categories":[],"tags":[],"keywords":[]},{"title":"git bash命令上传下载代代码","slug":"git bash命令上传下载代代码","date":"2017-04-08T12:37:28.000Z","updated":"2017-04-08T12:38:13.134Z","comments":true,"path":"2017/04/08/git bash命令上传下载代代码/","link":"","permalink":"https://aliceflaviawang.github.io/2017/04/08/git bash命令上传下载代代码/","excerpt":"","text":"git bash是window下的命令行工具，在官网上下载git for windows安装即可。如何通过git bash将代码传到git上和下载到本地的呢remote 上传到git1、安装完成后，在命令行输入下面的代码进行配置12$ git config --global user.name &quot;your real name&quot;$ git config --global user.email &quot;your eamil address&quot; 注：”your real name“是你的真实姓名，”your eamil address”是你的注册github的邮箱2、在主用户目录下，输入下面的代码1$ ssh-keygen -t rsa -C &quot;your eamil address 然后在自己电脑的C盘下找到.ssh文件夹，用记事本打开里面的id_rsa.pub,复制里面的内容。登陆Github，在账户设置里找到SSH keys页面，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容。3、利用”cd”命令将路径切换到你要上传的代码所在的文件夹下面（或者打开你要上传的代码的文件夹，右键git bash here）,输入一下代码：123$git init //把目录变成git可以管理的仓库$git add . //add后面加&quot;.&quot;表示上传所以的代码，如果想上传指定的，只需要把&quot;.&quot;改成文件名即可$git commit -m &quot;你对文件的描述&quot; //提交你对文件的描述 4、在本地仓库目录下输入下面命令将本地仓库和远程仓库关联（如果已经上传过代码了，可以直接跳到第6步）1$git remote add orgin git@github.com:yonghuming/kuming.git origin可是换成你想要的任何名字，但是要记住这个源名字（与第6步的origin对应，我每次都是新起一个名字因为经常提示origin已经存在了）5、输入如下代码，将自己的文件上传1$git push -u origin master 其实github上每次创建一个新的仓库的时候，都有命令提示 从git上下载$git clone git@github.com:yonghuming/kuming.git 更新$git pull origin master 经常遇到的问题error:src refspec master does not match any原因：本地版本库为空，空目录不能提交","categories":[],"tags":[],"keywords":[]},{"title":"Github Pages+Hexo搭建教程","slug":"Github-Pages-Hexo搭建教程","date":"2017-04-04T13:44:17.000Z","updated":"2017-04-07T03:11:41.888Z","comments":true,"path":"2017/04/04/Github-Pages-Hexo搭建教程/","link":"","permalink":"https://aliceflaviawang.github.io/2017/04/04/Github-Pages-Hexo搭建教程/","excerpt":"","text":"前言越来越感觉世界真是太大了，每天学习很多东西，希望能够记录下来自己学习的点点滴滴，也能分享给更多的人，因此搭建了这个博客。关于为什么选择github pages而不是wordpress，因为github pages有300M免费空间，资料自己管理，保存可靠，而且现在的项目开发，团队协作都需要用到github，通过搭建博客也更好的学习了如何使用github。 github安装在官网https://git-for-windows.github.io/上下载git，安装比较简单。访问http://www.github.com/，注册username和邮箱，注册过程也比较简单。 使用GitHub Pages建立博客github建立仓库登陆系统后，在github首页，点击页面右下角New Repository填写项目信息：project name:aliceflaviawang.github.io注：GitHub Pages的Repository名字是特定的，比如我的Github账号是aliceflaviawang,那么我的GitHub Pages Repository名字就是aliceflaviawang.github.io。点击Create Reposity完成创建。进入创建的仓库，打开Settings选择一个主题选择完毕，回到仓库页面，发现多了两个文件，_config.yml是配置文件。此时打开aliceflaviawang.github.io，可以看到index.md显示的内容。 安装node.js参考教程http://www.runoob.com/nodejs/nodejs-install-setup.html，非常简单。 用Hexo克隆主题Hexo介绍Hexo是一个简单、快速、强大的博客发布工具，支持Markdown格式 安装Hexo打开git bash或者cmd,进入node文件夹，安装hexo注：-g是全局安装的意思 部署Hexo在我的电脑中建立一个名叫Hexo的文件夹，然后在此文件夹中右键打开Git Bash.Hexo会自动在目标文件夹建立网站所需要的所有文件。 复制主题建立Hexo之后就可以复制主题了，网上有很多好看的主题可以自己选择。此处选择的是wuchong的主题。 启用主题修改Hexo目录下的_config.yml,将theme属性设置为jacman。 更新主题 本地查看调试 hexo g是生成，hexo d是部署，可是先后使用或者直接使用组合命令hexo d -g，发现Hexo文件夹生成了public文件。 查看搭建效果浏览器输入http://localhost:4000,查看搭建效果。如果localhost:4000无法访问，是因为你的电脑端口被占用了，而hexo默认的端口是4000，可以通过修改端口来解决这个问题。 比如将端口改成4040现在就可以看到效果了 Hexo设置网站搭建完成之后，可以根据需要对Hexo生产的网站进行设置，设置是修改_config.yml，我复制一下别人的设置，可以参考一下。 Hexo Configuration123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: XTong notessubtitle: Live beautifully, dream passionately, love completelydescription: You Never Know Who You Areauthor: X T Wlanguage: zh-Hanstimezone: Asia/Shanghai# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: https://aliceflaviawang.github.io/root: /permalink: :year/:month/:day/:title/permalink_defaults:# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: false tab_replace:# Category &amp; Tagdefault_category: othercategory_map:tag_map:# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 8pagination_dir: page# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: jacman# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/aliceflaviawang/aliceflaviawang.github.io.git branch: masterfeed: type: atom path: atom.xml limit: 20 hub: baidusitemap: path: baidusitemap.xmlsearch: path: search.xml field: post format: html limit: 10000 注：与gitgub pages建立关联（非常关键） 发表新文章使用hexo发表文章1$ hexo n #写文章 写完之后，推送到服务器上，执行12$ hexo g #生成$ hexo d #部署 或者hexo d -g 或者使用markdown来写文章常用命令1$ hexo new post &quot;postname&quot; #新建文章 注：如果 $ hexo d命令提示ERROR Deployer not found: git，解决办法 $ npm install hexo-deployer-git –save,然后再重新生成部署。hexo d实际上就是将博客部署到gitgub上去。hexo new post执行后会在项目source_posts中生成postname.md文件，用编辑器打开即可编辑，也可以直接在source_posts中新建一个md文件。写完之后，部署到服务器上12$ hexo g$ hexo d 打开aliceflaviawang.github.io,可以看到第一篇博客了 域名其实搭建博客不一定需要域名，当然如果你嫌github.io不够高大上，当然可以买个域名来装x.很多地方可以买域名，不只是godaddy，像腾讯云、万网…很多，我在godaddy中文网站上上买了aliceflaviawang.com这个网站，因为中文网站指引比较明确，就不详说了。 将域名与Github Pages空间绑定GitHub pages设置方法一：在Repository的根目录下面，新建一个名为CNAME的文本文件，里面写入你想要绑定的域名，比如aliceflaviawang.com方法二：点击setting，在custom domain下面天上你想要绑定的域名，点击save，会自动生成一个CNAME文件，里面保存的就是你的域名了。 DNS设置用DNSpod，我在腾讯云上注册了下，注意必须实名认证了才让你解析域名，由于我的域名已经退了，就直接使用别人的图片 添加域名，如下图设置其中A的两条记录指向的ip地址是github pages提供的地址，这个记录是云解析解析出来的结果，云解析会提示去godaddy修改dns地址。我采用的方式是自己添加，首先ping http://aliceflaviawang.github.io的地址，获得A的地址添加，然后添加www域名地址。 godaddy修改DNS点击我的账户里–&gt;点击域名–&gt;将godaddy的NameServer更改成f1g1ns1.dnspod.net和f1g1ns2.dnspod.net （域名解析后提示）。 访问博客现在就不需要访问aliceflaviawang.github.io了，可以直接访问aliceflaviawang.com注：如果访问的时候发现页面是github首页，说明需要清除一下缓存了。 后记本博客主要参考的是http://blog.sina.com.cn/s/blog_617ccc0c0101h84p.html。","categories":[],"tags":[],"keywords":[]},{"title":"我的第一篇博客","slug":"我的第一篇博客","date":"2017-04-04T13:28:41.000Z","updated":"2017-04-04T13:42:27.261Z","comments":true,"path":"2017/04/04/我的第一篇博客/","link":"","permalink":"https://aliceflaviawang.github.io/2017/04/04/我的第一篇博客/","excerpt":"","text":"感想清明节放假的最后一天，终于搭建了这个博客，心情还是比较激动的，希望以后能够通过博客这种方式记录下每天的进步！","categories":[],"tags":[],"keywords":[]}]}